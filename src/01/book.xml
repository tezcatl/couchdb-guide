<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book
  PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<book id="I_book_d1e1"><title>CouchDB: The Definitive Guide</title><bookinfo><othercredit role="productionservices"><firstname>Appingo, Inc.</firstname></othercredit><othercredit role="interiordesigner"><firstname>David</firstname><surname>Futato</surname></othercredit><othercredit role="illustrator"><firstname>Robert</firstname><surname>Romano</surname></othercredit><!-- All rights reserved. --><publisher><publishername>O’Reilly Media, Inc.</publishername><address format="linespecific">
      <street>1005 Gravenstein Highway North</street>
      <city>Sebastopol</city>
      <state>CA</state>
      <postcode>95472</postcode>
    </address></publisher><legalnotice role="printlocation"><para>Printed in the United States of America.</para></legalnotice><legalnotice role="printer"><para>[M]</para></legalnotice><legalnotice role="repkover"><para>This book uses RepKover™, a durable and flexible lay-flat
    binding.</para></legalnotice><legalnotice role="use"><para>O’Reilly books may be purchased for educational, business, or sales
    promotional use. Online editions are also available for most titles
    (<ulink role="orm:hideurl:ital" url="http://my.safaribooksonline.com/?portal=oreilly">http://my.safaribooksonline.com</ulink>).
    For more information, contact our corporate/institutional sales
    department: 800-998-9938 or <email>corporate@oreilly.com</email>.</para></legalnotice><legalnotice role="trademarks"><para>O’Reilly and the O’Reilly logo are registered trademarks of O’Reilly
    Media, Inc. <citetitle>CouchDB: The Definitive Guide</citetitle>, the
    image of a Pomeranian dog, and related trade dress are trademarks of
    O’Reilly Media, Inc.</para><para>Many of the designations used by manufacturers and sellers to
    distinguish their products are claimed as trademarks. Where those
    designations appear in this book, and O’Reilly Media, Inc. was aware of a
    trademark claim, the designations have been printed in caps or initial
    caps.</para></legalnotice><legalnotice role="damages"><para>While every precaution has been taken in the preparation of this
    book, the publisher and authors assume no responsibility for errors or
    omissions, or for damages resulting from the use of the information
    contained herein. This work has been released under the Creative Commons
    Attribution License. To view a copy of this license, visit <ulink url="http://creativecommons.org/licenses/by/2.0/legalcode">http://creativecommons.org/licenses/by/2.0/legalcode</ulink>
    or send a letter to Creative Commons, 171 2nd Street, Suite 300, San
    Francisco, California, 94105, USA.</para></legalnotice><isbn>9780596155896</isbn><edition>1</edition><author><firstname>J. Chris</firstname><surname>Anderson</surname><authorblurb><para><phrase role="bold">J. Chris Anderson</phrase> is an Apache
      CouchDB committer and cofounder of Relaxed, Inc. Chris is obsessed with
      JavaScript CouchApps and bending the physics of the Web to give control
      back to users.</para></authorblurb></author><author><firstname>Jan</firstname><surname>Lehnardt</surname><authorblurb><para><phrase role="bold">Jan Lehnardt</phrase> is an Apache CouchDB
      committer and cofounder of Relaxed, Inc. Jan hacks on all parts of the
      web technology stack and focuses on making developers’ lives
      easier.</para></authorblurb></author><author><firstname>Noah</firstname><surname>Slater</surname><authorblurb><para><phrase role="bold">Noah Slater</phrase> is an Apache CouchDB
      committer and release manager. He works with the community to get
      CouchDB running in as many places as possible.</para></authorblurb></author><editor><firstname>Mike</firstname><surname>Loukides</surname></editor><copyright><year>2010</year><holder>J. Chris Anderson, Jan Lehnardt, and Noah Slater</holder></copyright><editor role="production"><firstname>Sarah</firstname><surname>Schneider</surname></editor><othercredit role="coverdesigner"><firstname>Karen</firstname><surname>Montgomery</surname></othercredit><printhistory><formalpara><title>First Edition</title><para>January, 2010</para></formalpara></printhistory><mediaobject role="cover" id="coverd1e4"><imageobject role="front-large" remap="lrg"><imagedata format="JPG" fileref="covers/9780596155896_lrg.jpg"/></imageobject><imageobject role="front" remap="s"><imagedata format="GIF" fileref="covers/9780596155896_s.gif"/></imageobject><imageobject role="front-small" remap="xs"><imagedata format="GIF" fileref="covers/9780596155896_xs.gif"/></imageobject><imageobject role="thumbnail" remap="cs"><imagedata format="GIF" fileref="covers/9780596155896_cs.gif"/></imageobject></mediaobject></bookinfo><dedication id="dedication"><title>Dedication</title><blockquote><attribution>J. Chris</attribution><para>For the Web, and all the people who helped me along the way. Thank
    you.</para></blockquote><blockquote><attribution>Jan</attribution><para>Für Marita und Kalle.</para></blockquote><blockquote><attribution>Noah</attribution><para>For my parents, God and Damien Katz.</para></blockquote></dedication><preface id="foreword" role="foreword"><prefaceinfo><author><firstname>Damien</firstname><surname>Katz</surname><affiliation><jobtitle>Creator of CouchDB</jobtitle></affiliation></author></prefaceinfo><title>Foreword</title><para>As the creator of CouchDB, it gives me great pleasure to write this
  Foreword. This book has been a long time coming. I’ve worked on CouchDB
  since 2005, when it was only a vision in my head and only my wife Laura
  believed I could make it happen.</para><para>Now the project has taken on a life of its own, and code is literally
  running on millions of machines. I couldn’t stop it now if I tried.</para><para>A great analogy J. Chris uses is that CouchDB has felt like a boulder
  we’ve been pushing up a hill. Over time, it’s been moving faster and getting
  easier to push, and now it’s moving so fast it’s starting to feel like it
  could get loose and crush some unlucky villagers. Or something. Hey,
  remember “Tales of the Runaway Boulder” with Robert Wagner on
  <emphasis>Saturday Night Live</emphasis>? Good times.</para><para>Well, now we are trying to safely guide that boulder. Because of the
  villagers. You know what? This boulder analogy just isn’t working. Let’s
  move on.</para><para>The reason for this book is that CouchDB is a very different way of
  approaching data storage. A way that isn’t inherently better or worse than
  the ways before—it’s just another tool, another way of thinking about
  things. It’s missing some features you might be used to, but it’s gained
  some abilities you’ve maybe never seen. Sometimes it’s an excellent fit for
  your problems; sometimes it’s terrible.</para><para>And sometimes you may be thinking about your problems all wrong. You
  just need to approach them from a different angle.</para><para>Hopefully this book will help you understand CouchDB and the approach
  that it takes, and also understand how and when it can be used for the
  problems you face.</para><para>Otherwise, someday it could become a runaway boulder, being misused
  and causing disasters that could have been avoided.</para><para>And I’ll be doing my best Charlton Heston imitation, on the ground,
  pounding the dirt, yelling, “You maniacs! You blew it up! Ah, damn you! God
  damn you all to hell!” Or something like that.</para></preface><preface id="I_preface_d1e189"><title>Preface</title><para>Thanks for purchasing this book! If it was a gift, then
  congratulations. If, on the other hand, you downloaded it without paying,
  well, actually, we’re pretty happy about that too! This book is available
  under a free license, and that’s important because we want it to serve the
  community as documentation—and documentation should be free.</para><para>So, why pay for a free book? Well, you might like the warm fuzzy
  feeling you get from holding a book in your hands, as you cosy up on the
  couch with a cup of coffee. On the couch...get it? Bad jokes aside, whatever
  your reasons, buying the book helps support us, so we have more time to work
  on improvements for both the book and CouchDB. So thank you!</para><para>We set out to compile the best and most comprehensive collection of
  CouchDB information there is, and yet we know we failed. CouchDB is a
  fast-moving target and grew significantly during the time we were writing
  the book. We were able to adapt quickly and keep things up-to-date, but we
  also had to draw the line somewhere if we ever hoped to publish it.</para><para>At the time of this writing, CouchDB 0.10.1 is the latest release, but
  you might already be seeing 0.10.2 or even 0.11.0 released or being
  prepared—maybe even 1.0. Although we have some ideas about how future
  releases will look, we don’t know for certain and didn’t want to make any
  wild guesses. CouchDB is a community project, so ultimately it’s up to you,
  our readers, to help shape the project.</para><para>On the plus side, many people successfully run CouchDB 0.10 in
  production, and you will have more than enough on your hands to run a solid
  project. Future releases of CouchDB will make things easier in places, but
  the core features should remain the same. Besides, learning the core
  features helps you understand and appreciate the shortcuts and allows you to
  roll your own hand-tailored solutions.</para><para>Writing an open book was great fun. We’re happy O’Reilly supported our
  decision in every way possible. The best part—besides giving the CouchDB
  community early access to the material—was the commenting functionality we
  implemented on the <ulink role="orm:hideurl" url="http://books.couchdb.org/relax">book’s website</ulink>. It allows
  anybody to comment on any paragraph in the book with a simple click. We used
  some simple JavaScript and Google Groups to allow painless commenting. The
  result was astounding. As of today, 866 people have sent more than 1,100
  messages to our little group. Submissions have ranged from pointing out
  small typos to deep technical discussions. Feedback on our original first
  chapter led us to a complete rewrite in order to make sure the points we
  wanted to get across did, indeed, get across. This system allowed us to
  clearly formulate what we wanted to say in a way that worked for you, our
  readers.</para><para>Overall, the book has become so much better because of the help of
  hundreds of volunteers who took the time to send in their suggestions. We
  understand the immense value this model has, and we want to keep it up. New
  features in CouchDB should make it into the book without us necessarily
  having to do a reprint every thee months. The publishing industry is not
  ready for that yet, but we want to continue to release new and revised
  content and listen closely to the feedback. The specifics of how we’ll do
  this are still in flux, but we’ll be posting the information to the book’s
  website the first moment we know it. That’s a promise! So make sure to visit
  the book’s website at <ulink url="http://books.couchdb.org/relax">http://books.couchdb.org/relax</ulink>
  to keep up-to-date.</para><para>Before we let you dive into the book, we want to make sure you’re well
  prepared. CouchDB is written in Erlang, but you don’t need to know anything
  about Erlang to use CouchDB. CouchDB also heavily relies on web technologies
  like HTTP and JavaScript, and some experience with those does help when
  following the examples throughout the book. If you have built a website
  before—simple or complex—you should be ready to go.</para><para>If you are an experienced developer or systems architect, the
  introduction to CouchDB should be comforting, as you already know everything
  involved—all you need to learn are the ways CouchDB puts them together.
  Toward the end of the book, we ramp up the experience level to help you get
  as comfortable building large-scale CouchDB systems as you are with personal
  projects.</para><para>If you are a beginning web developer, don’t worry—by the time you get
  to the later parts of the book, you should be able to follow along with the
  harder stuff.</para><para>Now, sit back, relax, and enjoy the ride through the wonderful world
  of CouchDB.</para><sect1 id="I_sect1_d1e221"><title>Using Code Examples</title><para>This book is here to help you get your job done. In general, you may
    use the code in this book in your programs and documentation. You do not
    need to contact us for permission unless you’re reproducing a significant
    portion of the code. For example, writing a program that uses several
    chunks of code from this book does not require permission. Selling or
    distributing a CD-ROM of examples from O’Reilly books does require
    permission. Answering a question by citing this book and quoting example
    code does not require permission. Incorporating a significant amount of
    example code from this book into your product’s documentation does require
    permission.<indexterm id="I_indexterm_d1e226" significance="normal"><primary>code examples from this book</primary></indexterm></para><para>This work is licensed under the Creative Commons Attribution
    License. To view a copy of this license, visit <ulink url="http://creativecommons.org/licenses/by/2.0/legalcode">http://creativecommons.org/licenses/by/2.0/legalcode</ulink>
    or send a letter to Creative Commons, 171 2nd Street, Suite 300, San
    Francisco, California, 94105, USA.</para><para>An attribution usually includes the title, author, publisher, and
    ISBN. For example: “<emphasis>CouchDB: The Definitive Guide</emphasis> by
    J. Chris Anderson, Jan Lehnardt, and Noah Slater. Copyright 2010 J. Chris
    Anderson, Jan Lehnardt, and Noah Slater, 978-0-596-15589-6.”</para><para>If you feel your use of code examples falls outside fair use or the
    permission given above, feel free to contact us at
    <email>permissions@oreilly.com</email>.</para></sect1><sect1 id="I_sect1_d1e244"><title>Conventions Used in This Book</title><para>The following typographical conventions are used in this
    book:</para><variablelist><varlistentry><term>Italic</term><listitem><para>Indicates new terms, URLs, email addresses, filenames, and
          file extensions.</para></listitem></varlistentry><varlistentry><term><literal moreinfo="none">Constant width</literal></term><listitem><para>Used for program listings, as well as within paragraphs to
          refer to program elements such as variable or function names,
          databases, data types, environment variables, statements, and
          keywords.</para></listitem></varlistentry><varlistentry><term><userinput moreinfo="none">Constant width bold</userinput></term><listitem><para>Shows commands or other text that should be typed literally by
          the user.</para></listitem></varlistentry><varlistentry><term><replaceable>Constant width italic</replaceable></term><listitem><para>Shows text that should be replaced with user-supplied values
          or by values determined by context.</para></listitem></varlistentry></variablelist><tip><para>This icon signifies a tip, suggestion, or general note.</para></tip><caution><para>This icon indicates a warning or caution.</para></caution></sect1><sect1 id="I_sect1_d1e283"><title>Safari® Books Online</title><note role="safarienabled"><para>Safari Books Online is an on-demand digital library that lets you
      easily search over 7,500 technology and creative reference books and
      videos to find the answers you need quickly.</para></note><para>With a subscription, you can read any page and watch any video from
    our library online. Read books on your cell phone and mobile devices.
    Access new titles before they are available for print, and get exclusive
    access to manuscripts in development and post feedback for the authors.
    Copy and paste code samples, organize your favorites, <phrase role="keep-together">download</phrase> chapters, bookmark key sections,
    create notes, print out pages, and benefit from tons of other time-saving
    features.</para><para>O’Reilly Media has uploaded this book to the Safari Books Online
    service. To have full digital access to this book and others on similar
    topics from O’Reilly and other publishers, sign up for free at <ulink role="orm:hideurl:ital" url="http://my.safaribooksonline.com/?portal=oreilly">http://my.safaribooksonline.com</ulink>.</para></sect1><sect1 id="I_sect1_d1e299"><title>How to Contact Us</title><para>Please address comments and questions concerning this book to the
    publisher:</para><simplelist type="vert"><member>O’Reilly Media, Inc.</member><member>1005 Gravenstein Highway North</member><member>Sebastopol, CA 95472</member><member>800-998-9938 (in the United States or Canada)</member><member>707-829-0515 (international or local)</member><member>707-829-0104 (fax)</member></simplelist><para>We have a web page for this book, where we list errata, examples,
    and any additional information. You can access this page at:<indexterm id="I_indexterm_d1e319" significance="normal"><primary>web page for this book</primary></indexterm></para><simplelist type="vert"><member><ulink url="http://www.oreilly.com/catalog/9780596155896"/></member></simplelist><para>To comment or ask technical questions about this book, send email
    to:</para><simplelist type="vert"><member><email>bookquestions@oreilly.com</email></member></simplelist><para>For more information about our books, conferences, Resource Centers,
    and the <phrase role="keep-together">O’Reilly</phrase> Network, see our
    website at:</para><simplelist type="vert"><member><ulink url="http://www.oreilly.com"/></member></simplelist></sect1><sect1 id="I_sect1_d1e339"><title>Acknowledgments</title><sect2><title>J. Chris</title><para>I would like to acknowledge all the committers of CouchDB, the
      people sending patches, and the rest of the community. I couldn’t have
      done it without my wife, Amy, who helps me think about the big picture;
      without the patience and support of my coauthors and O’Reilly; nor
      without the help of everyone who helped us hammer out book content
      details on the mailing lists. And a shout-out to the copyeditor, who was
      awesome!</para></sect2><sect2><title>Jan</title><para>I would like to thank the CouchDB community. Special thanks go out
      to a number of nice people all over the place who invited me to attend
      or talk at a conference, who let me sleep on their couches (pun most
      definitely intended), and who made sure I had a good time when I was
      abroad presenting CouchDB. There are too many to name, but all of you in
      Dublin, Portland, Lisbon, London, Zurich, San Francisco, Mountain View,
      Dortmund, Stockholm, Hamburg, Frankfurt, Salt Lake City, Blacksburg, San
      Diego, and Amsterdam: you know who you are—thanks!</para><para>To my family, friends, and coworkers: thanks you for your support
      and your patience with me over the last year. You won’t hear, “I’ve got
      to leave early, I have a book to write” from me anytime soon,
      promise!</para><para>Anna, you believe in me; I couldn’t have done this without
      you.</para></sect2><sect2><title>Noah</title><para>I would like to thank O’Reilly for their enthusiasm in CouchDB and
      for realizing the importance of free documentation. And of course, I’d
      like to thank Jan and J. Chris for being so great to work with. But a
      special thanks goes out to the whole CouchDB community, for making
      everything so fun and rewarding. Without you guys, none of this would be
      possible. And if you’re reading this, that means you!</para></sect2></sect1></preface><part id="part1"><title>Introduction</title><chapter id="whycouchdb"><title>Why CouchDB?</title><para>Apache CouchDB is one of a new breed of database management systems.
  This chapter explains why there’s a need for new systems as well as the
  motivations behind building CouchDB.</para><para>As CouchDB developers, we’re naturally very excited to be using
  CouchDB. In this chapter we’ll share with you the reasons for our
  enthusiasm. We’ll show you how CouchDB’s schema-free document model is a
  better fit for common applications, <phrase role="keep-together">how the
  built-in</phrase> query engine is a powerful way to use and process your
  data, and how CouchDB’s design lends itself to modularization and
  scalability.</para><sect1 id="relax"><title>Relax</title><para>If there’s one word to describe CouchDB, it is
    <emphasis>relax</emphasis>. It is in the title of this book, it is the
    byline to CouchDB’s official logo, and when you start CouchDB, you
    see:</para><screen format="linespecific">Apache CouchDB has started. Time to relax.</screen><para>Why is relaxation important? Developer productivity roughly doubled
    in the last five years. The chief reason for the boost is more powerful
    tools that are easier to use. Take Ruby on Rails as an example. It is an
    infinitely complex framework, but it’s easy to get started with. Rails is
    a success story because of the core design focus on ease of use. This is
    one reason why CouchDB is relaxing: learning CouchDB and understanding its
    core concepts should feel natural to most everybody who has been doing any
    work on the Web. And it is still pretty easy to explain to non-technical
    people.<indexterm id="I_indexterm1_d1e386" significance="normal"><primary>CouchDB</primary><seealso>installing CouchDB</seealso></indexterm></para><para>Getting out of the way when creative people try to build specialized
    solutions is in itself a core feature and one thing that CouchDB aims to
    get right. We found existing tools too cumbersome to work with during
    development or in production, and decided to focus on making CouchDB easy,
    even a pleasure, to use. Chapters <xref linkend="gettingstarted" xrefstyle="select: labelnumber"/> and <xref linkend="thecoreapi" xrefstyle="select: labelnumber"/> will demonstrate the intuitive
    HTTP-based REST API.<indexterm id="I_indexterm1_d1e397" significance="normal"><primary>RESTful API</primary></indexterm><indexterm id="I_indexterm1_d1e400" significance="normal"><primary>HTTP</primary></indexterm></para><para>Another area of relaxation for CouchDB users is the production
    setting. If you have a live running application, CouchDB again goes out of
    its way to avoid troubling you. Its internal architecture is
    fault-tolerant, and failures occur in a controlled environment and are
    dealt with gracefully. Single problems do not cascade through an entire
    server system but stay isolated in single requests.</para><para>CouchDB’s core concepts are simple (yet powerful) and well
    understood. Operations teams (if you have a team; otherwise, that’s you)
    do not have to fear random behavior and untraceable errors. If anything
    should go wrong, you can easily find out what the problem is—but these
    situations are rare.</para><para>CouchDB is also designed to handle varying traffic gracefully. For
    instance, if a website is experiencing a sudden spike in traffic, CouchDB
    will generally absorb a lot of concurrent requests without falling over.
    It may take a little more time for each request, but they all get
    answered. When the spike is over, CouchDB will work with regular speed
    again.<indexterm id="I_indexterm1_d1e409" significance="normal"><primary>scaling</primary></indexterm></para><para>The third area of relaxation is growing and shrinking the underlying
    hardware of your application. This is commonly referred to as
    <emphasis>scaling</emphasis>. CouchDB enforces a set of limits on the
    programmer. On first look, CouchDB might seem inflexible, but some
    features are left out by design for the simple reason that if CouchDB
    supported them, it would allow a programmer to create applications that
    couldn’t deal with scaling up or down. We’ll explore the whole matter of
    scaling CouchDB in <xref linkend="part4" xrefstyle="part-num-title"/>.</para><para>In a nutshell: CouchDB doesn’t let you do things that would get you
    in trouble later on. This sometimes means you’ll have to unlearn best
    practices you might have picked up in your current or past work. <xref linkend="recipes"/> contains a list of common tasks and how to solve them
    in CouchDB.</para></sect1><sect1 id="I_sect11_d1e423"><title>A Different Way to Model Your Data</title><para>We believe that CouchDB will drastically change the way you build
    document-based applications. CouchDB combines an intuitive document
    storage model with a powerful query engine in a way that’s so simple
    you’ll probably be tempted to ask, “Why has no one built something like
    this before?”<indexterm id="I_indexterm1_d1e428" significance="normal"><primary>data modeling</primary></indexterm></para><blockquote><attribution>Jacob Kaplan-Moss, Django developer</attribution><para>Django may be built <emphasis>for</emphasis> the Web, but CouchDB
      is built <emphasis>of</emphasis> the Web. I’ve never seen software that
      so completely embraces the philosophies behind HTTP. CouchDB makes
      Django look old-school in the same way that Django makes ASP look
      outdated.</para></blockquote><para>CouchDB’s design borrows heavily from web architecture and the
    concepts of resources, methods, and representations. It augments this with
    powerful ways to query, map, combine, and filter your data. Add fault
    tolerance, extreme scalability, and incremental replication, and CouchDB
    defines a sweet spot for document databases.</para></sect1><sect1 id="I_sect11_d1e444"><title>A Better Fit for Common Applications</title><para>We write software to improve our lives and the lives of others.
    Usually this involves taking some mundane information—such as contacts,
    invoices, or receipts—and manipulating it using a computer application.
    CouchDB is a great fit for common applications like this because it
    embraces the natural idea of evolving, self-contained documents as the
    very core of its data model.</para><sect2><title>Self-Contained Data</title><para>An invoice contains all the pertinent information about a single
      transaction—the seller, the buyer, the date, and a list of the items or
      services sold. As shown in <xref linkend="figure_1_1"/>, there’s no
      abstract reference on this piece of paper that points to some other
      piece of paper with the seller’s name and address. Accountants
      appreciate the simplicity of having everything in one place. And given
      the choice, programmers appreciate that, too.<indexterm id="I_indexterm1_d1e456" significance="normal"><primary>self-contained data</primary></indexterm></para><figure float="none" id="figure_1_1"><title>Self-contained documents</title><mediaobject id="I_mediaobject1_d1e462"><imageobject role="print"><imagedata fileref="figs/print/codb_0101.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0101.png" format="PNG"/></imageobject></mediaobject></figure><para>Yet using references is exactly how we model our data in a
      relational database! Each invoice is stored in a table as a row that
      refers to other rows in other tables—one row for seller information, one
      for the buyer, one row for each item billed, and more rows still to
      describe the item details, manufacturer details, and so on and so
      forth.</para><para>This isn’t meant as a detraction of the relational model, which is
      widely applicable and extremely useful for a number of reasons.
      Hopefully, though, it illustrates the point that sometimes your model
      may not “fit” your data in the way it occurs in the real world.</para><para>Let’s take a look at the humble contact database to illustrate a
      different way of modeling data, one that more closely “fits” its
      real-world counterpart—a pile of business cards. Much like our invoice
      example, a business card contains all the important information, right
      there on the cardstock. We call this “self-contained” data, and it’s an
      important concept in understanding document databases like
      CouchDB.</para></sect2><sect2><title>Syntax and Semantics</title><para>Most business cards contain roughly the same information—someone’s
      identity, an affiliation, and some contact information. While the exact
      form of this information can vary between business cards, the general
      information being conveyed remains the same, and we’re easily able to
      recognize it as a business card. In this sense, we can describe a
      business card as a <emphasis>real-world document</emphasis>.</para><para>Jan’s business card might contain a phone number but no fax
      number, whereas J. Chris’s business card contains both a phone and a fax
      number. Jan does not have to make his lack of a fax machine explicit by
      writing something as ridiculous as “Fax: None” on the business card.
      Instead, simply omitting a fax number implies that he doesn’t have
      one.</para><para>We can see that real-world documents of the same type, such as
      business cards, tend to be very similar in
      <emphasis>semantics</emphasis>—the sort of information they carry—but
      can vary hugely in <emphasis>syntax</emphasis>, or how that information
      is structured. As human beings, we’re naturally comfortable dealing with
      this kind of variation.<indexterm id="I_indexterm1_d1e491" significance="normal"><primary>syntax and semantics</primary></indexterm></para><para>While a traditional relational database requires you to model your
      data <emphasis>up front</emphasis>, CouchDB’s schema-free design
      unburdens you with a powerful way to aggregate your data <emphasis>after
      the fact</emphasis>, just like we do with real-world documents. We’ll
      look in depth at how to design applications with this underlying storage
      paradigm.</para></sect2></sect1><sect1 id="I_sect11_d1e502"><title>Building Blocks for Larger Systems</title><para>CouchDB is a storage system useful on its own. You can build many
    applications with the tools CouchDB gives you. But CouchDB is designed
    with a bigger picture in mind. Its components can be used as building
    blocks that solve storage problems in slightly different ways for larger
    and more complex systems.</para><para>Whether you need a system that’s crazy fast but isn’t too concerned
    with reliability (think logging), or one that guarantees storage in two or
    more physically separated locations for reliability, but you’re willing to
    take a performance hit, CouchDB lets you build these systems.<indexterm id="I_indexterm1_d1e509" significance="normal"><primary>latency, concurrency, and throughput</primary></indexterm><indexterm id="I_indexterm1_d1e512" significance="normal"><primary>throughput, latency, and concurrency</primary></indexterm></para><para>There are a multitude of knobs you could turn to make a system work
    better in one area, but you’ll affect another area when doing so. One
    example would be the CAP theorem discussed in the next chapter. To give
    you an idea of other things that affect storage systems, see Figures <xref linkend="figure_1_8" xrefstyle="select: labelnumber"/> and <xref linkend="figure_1_9" xrefstyle="select: labelnumber"/>.</para><para>By reducing latency for a given system (and that is true not only
    for storage systems), you affect concurrency and throughput
    capabilities.<indexterm id="I_indexterm1_d1e523" significance="normal"><primary>data, scaling</primary></indexterm><indexterm id="I_indexterm1_d1e526" significance="normal"><primary>read requests</primary><secondary>scaling</secondary></indexterm><indexterm id="I_indexterm1_d1e531" significance="normal"><primary>write requests, scaling</primary></indexterm><indexterm id="I_indexterm1_d1e534" significance="normal"><primary>scaling</primary><secondary>read requests, write requests, or data</secondary></indexterm></para><figure float="none" id="figure_1_8"><title>Throughput, latency, or concurrency</title><mediaobject id="I_mediaobject1_d1e542"><imageobject role="print"><imagedata fileref="figs/print/codb_0102.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0102.png" format="PNG"/></imageobject></mediaobject></figure><figure float="none" id="figure_1_9"><title>Scaling: read requests, write requests, or data</title><mediaobject id="I_mediaobject1_d1e550"><imageobject role="print"><imagedata fileref="figs/print/codb_0103.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0103.png" format="PNG"/></imageobject></mediaobject></figure><para>When you want to scale out, there are three distinct issues to deal
    with: scaling read requests, write requests, and data. Orthogonal to all
    three and to the items shown in Figures <xref linkend="figure_1_8" xrefstyle="select: labelnumber"/> and <xref linkend="figure_1_9" xrefstyle="select: labelnumber"/> are many more attributes like
    reliability or simplicity. You can draw many of these graphs that show how
    different features or attributes pull into different directions and thus
    shape the system they describe.</para><para>CouchDB is very flexible and gives you enough building blocks to
    create a system shaped to suit your exact problem. That’s not saying that
    CouchDB can be bent to solve any problem—CouchDB is no silver bullet—but
    in the area of data storage, it can get you a long way.</para><sect2><title>CouchDB Replication</title><para>CouchDB replication is one of these building blocks. Its
      fundamental function is to synchronize two or more CouchDB databases.
      This may sound simple, but the simplicity is key to allowing replication
      to solve a number of problems: reliably synchronize databases between
      multiple machines for redundant data storage; distribute data to a
      cluster of CouchDB instances that share a subset of the total number of
      requests that hit the cluster (load balancing); and distribute data
      between physically distant locations, such as one office in New York and
      another in Tokyo.<indexterm id="I_indexterm1_d1e568" significance="normal"><primary>replication</primary></indexterm></para><para>CouchDB replication uses the same REST API all clients use. HTTP
      is ubiquitous and well understood. Replication works incrementally; that
      is, if during replication anything goes wrong, like dropping your
      network connection, it will pick up where it left off the next time it
      runs. It also only transfers data that is needed to synchronize <phrase role="keep-together">databases</phrase>.<indexterm id="I_indexterm1_d1e576" significance="normal"><primary>distributed computing, fallacies of</primary></indexterm></para><para>A core assumption CouchDB makes is that things can go wrong, like
      network connection troubles, and it is designed for graceful error
      recovery instead of assuming all will be well. The replication system’s
      incremental design shows that best. The ideas behind “things that can go
      wrong” are embodied in the Fallacies of Distributed Computing:<footnote><para><ulink url="http://en.wikipedia.org/wiki/Fallacies_of_Distributed_Computing">http://en.wikipedia.org/wiki/Fallacies_of_Distributed_Computing</ulink></para></footnote></para><orderedlist numeration="arabic" inheritnum="ignore" continuation="restarts"><listitem><para>The network is reliable.</para></listitem><listitem><para>Latency is zero.</para></listitem><listitem><para>Bandwidth is infinite.</para></listitem><listitem><para>The network is secure.</para></listitem><listitem><para>Topology doesn’t change.</para></listitem><listitem><para>There is one administrator.</para></listitem><listitem><para>Transport cost is zero.</para></listitem><listitem><para>The network is homogeneous.</para></listitem></orderedlist><para>Existing tools often try to hide the fact that there is a network
      and that any or all of the previous conditions don’t exist for a
      particular system. This usually results in fatal error scenarios when
      something finally goes wrong. In contrast, CouchDB doesn’t try to hide
      the network; it just handles errors gracefully and lets you know when
      actions on your end are <phrase role="keep-together">required.</phrase></para></sect2></sect1><sect1 id="I_sect11_d1e614"><title>Local Data Is King</title><para>CouchDB takes quite a few lessons learned from the Web, but there is
    one thing that could be improved about the Web: latency. Whenever you have
    to wait for an application to respond or a website to render, you almost
    always wait for a network connection that isn’t as fast as you want it at
    that point. Waiting a few seconds instead of milliseconds greatly affects
    user experience and thus user satisfaction.<indexterm id="I_indexterm1_d1e619" significance="normal"><primary>local data</primary></indexterm></para><para>What do you do when you are offline? This happens all the time—your
    DSL or cable provider has issues, or your iPhone, G1, or Blackberry has no
    bars, and no connectivity means no way to get to your data.</para><para>CouchDB can solve this scenario as well, and this is where scaling
    is important again. This time it is scaling down. Imagine CouchDB
    installed on phones and other mobile devices that can synchronize data
    with centrally hosted CouchDBs when they are on a network. The
    synchronization is not bound by user interface constraints like subsecond
    response times. It is easier to tune for high bandwidth and higher latency
    than for low bandwidth and very low latency. Mobile applications can then
    use the local CouchDB to fetch data, and since no remote networking is
    required for that, latency is low by default.</para><para>Can you really use CouchDB on a phone? Erlang, CouchDB’s
    implementation language has been designed to run on embedded devices
    magnitudes smaller and less powerful than today’s phones.<indexterm id="I_indexterm1_d1e628" significance="normal"><primary>Erlang</primary></indexterm></para></sect1><sect1 id="I_sect11_d1e631"><title>Wrapping Up</title><para>The next chapter further explores the distributed nature of CouchDB.
    We should have given you enough bites to whet your interest. Let’s
    go!</para></sect1></chapter><chapter id="eventualconsistency"><title>Eventual Consistency</title><para>In the previous chapter, we saw that CouchDB’s flexibility allows us
  to evolve our data as our applications grow and change. In this chapter,
  we’ll explore how working “with the grain” of CouchDB promotes simplicity in
  our applications and helps us naturally build scalable, distributed
  systems.</para><sect1 id="I_sect12_d1e641"><title>Working with the Grain</title><para>A <emphasis>distributed system</emphasis> is a system that operates
    robustly over a wide network. A particular feature of network computing is
    that network links can potentially disappear, and there are plenty of
    strategies for managing this type of network segmentation. CouchDB differs
    from others by accepting eventual consistency, as opposed to putting
    absolute consistency ahead of raw availability, like RDBMS or Paxos. What
    these systems have in common is an awareness that data acts differently
    when many people are accessing it simultaneously. Their approaches differ
    when it comes to which aspects of <emphasis>consistency</emphasis>,
    <emphasis>availability</emphasis>, or <emphasis>partition
    tolerance</emphasis> they prioritize.<indexterm id="I_indexterm2_d1e658" significance="normal"><primary>partition tolerance</primary></indexterm><indexterm id="I_indexterm2_d1e661" significance="normal"><primary>availability</primary></indexterm><indexterm id="I_indexterm2_d1e665" significance="normal"><primary>consistency</primary></indexterm><indexterm id="I_indexterm2_d1e668" significance="normal"><primary>distributed systems</primary></indexterm></para><para>Engineering distributed systems is tricky. Many of the caveats and
    “gotchas” you will face over time aren’t immediately obvious. We don’t
    have all the solutions, and CouchDB isn’t a panacea, but when you work
    with CouchDB’s grain rather than against it, the path of least resistance
    leads you to naturally scalable applications.</para><para>Of course, building a distributed system is only the beginning. A
    website with a database that is available only half the time is next to
    worthless. Unfortunately, the traditional relational database approach to
    consistency makes it very easy for application programmers to rely on
    global state, global clocks, and other high availability no-nos, without
    even realizing that they’re doing so. Before examining how CouchDB
    promotes scalability, we’ll look at the constraints faced by a distributed
    system. After we’ve seen the problems that arise when parts of your
    application can’t rely on being in constant contact with each other, we’ll
    see that CouchDB provides an intuitive and useful way for modeling
    applications around high availability.<indexterm id="I_indexterm2_d1e675" significance="normal"><primary>scalability</primary></indexterm></para></sect1><sect1 id="I_sect12_d1e678"><title>The CAP Theorem</title><para>The CAP theorem describes a few different strategies for
    distributing application logic across networks. CouchDB’s solution uses
    replication to propagate application changes across participating nodes.
    This is a fundamentally different approach from consensus algorithms and
    relational databases, which operate at different intersections of
    consistency, availability, and partition tolerance.<indexterm id="I_indexterm2_d1e683" significance="normal"><primary>relational databases</primary><secondary>consistency, availability, and partition
        tolerance</secondary></indexterm><indexterm id="I_indexterm2_d1e688" significance="normal"><primary>consistency, availability, and partition tolerance (CAP
        theorem)</primary></indexterm><indexterm id="I_indexterm2_d1e691" significance="normal"><primary>CAP theorem</primary></indexterm></para><para>The CAP theorem, shown in <xref linkend="figure_2_1"/>, identifies
    three distinct concerns:</para><variablelist><varlistentry><term>Consistency</term><listitem><para>All database clients see the same data, even with concurrent
          updates.<indexterm id="I_indexterm2_d1e705" significance="normal"><primary>consistency</primary><secondary>defined</secondary></indexterm></para></listitem></varlistentry><varlistentry><term>Availability</term><listitem><para>All database clients are able to access some version of the
          data.<indexterm id="I_indexterm2_d1e716" significance="normal"><primary>availability</primary></indexterm></para></listitem></varlistentry><varlistentry><term>Partition tolerance</term><listitem><para>The database can be split over multiple servers.<indexterm id="I_indexterm2_d1e725" significance="normal"><primary>partition tolerance</primary></indexterm></para></listitem></varlistentry></variablelist><para>Pick two.</para><figure float="none" id="figure_2_1"><title>The CAP theorem</title><mediaobject id="I_mediaobject2_d1e733"><imageobject role="print"><imagedata fileref="figs/print/codb_0201.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0201.png" format="PNG"/></imageobject></mediaobject></figure><para>When a system grows large enough that a single database node is
    unable to handle the load placed on it, a sensible solution is to add more
    servers. When we add nodes, we have to start thinking about how to
    partition data between them. Do we have a few databases that share exactly
    the same data? Do we put different sets of data on different database
    servers? Do we let only certain database servers write data and let others
    handle the reads?</para><para>Regardless of which approach we take, the one problem we’ll keep
    bumping into is that of keeping all these database servers in
    synchronization. If you write some information to one node, how are you
    going to make sure that a read request to another database server reflects
    this newest information? These events might be milliseconds apart. Even
    with a modest collection of database servers, this problem can become
    extremely complex.<indexterm id="I_indexterm2_d1e742" significance="normal"><primary>read requests</primary><secondary>reflecting newest information</secondary></indexterm></para><para>When it’s absolutely critical that all clients see a consistent view
    of the database, the users of one node will have to wait for any other
    nodes to come into agreement before being able to read or write to the
    database. In this instance, we see that <emphasis>availability</emphasis>
    takes a backseat to <emphasis>consistency</emphasis>. However, there are
    situations where availability trumps consistency:</para><blockquote><attribution>Werner Vogels, Amazon CTO and Vice President</attribution><para>Each node in a system should be able to make decisions purely
      based on local state. If you need to do something under high load with
      failures occurring and you need to reach agreement, you’re lost. If
      you’re concerned about scalability, any algorithm that forces you to run
      agreement will eventually become your bottleneck. Take that as a
      given.</para></blockquote><para>If availability is a priority, we can let clients write data to one
    node of the database without waiting for other nodes to come into
    agreement. If the database knows how to take care of reconciling these
    operations between nodes, we achieve a sort of “eventual consistency” in
    exchange for high availability. This is a surprisingly applicable
    trade-off for many applications.</para><para>Unlike traditional relational databases, where each action performed
    is necessarily subject to database-wide consistency checks, CouchDB makes
    it really simple to build applications that sacrifice immediate
    consistency for the huge performance improvements that come with simple
    distribution.</para></sect1><sect1 id="I_sect12_d1e765"><title>Local Consistency</title><para>Before we attempt to understand how CouchDB operates in a cluster,
    it’s important that we understand the inner workings of a single CouchDB
    node. The CouchDB API is designed to provide a convenient but thin wrapper
    around the database core. By taking a closer look at the structure of the
    database core, we’ll have a better understanding of the API that surrounds
    it.<indexterm class="startofrange" id="ch02_consistencylocal" significance="normal"><primary>consistency</primary><secondary>local</secondary></indexterm></para><sect2><title>The Key to Your Data</title><para>At the heart of CouchDB is a powerful <emphasis>B-tree</emphasis>
      storage engine. A B-tree is a sorted data structure that allows for
      searches, insertions, and deletions in logarithmic time. As <xref linkend="figure_2_2"/> illustrates, CouchDB uses this B-tree storage
      engine for all internal data, documents, and views. If we understand
      one, we will understand them all.<indexterm id="I_indexterm2_d1e785" significance="normal"><primary>view request, anatomy of</primary></indexterm><indexterm id="I_indexterm2_d1e788" significance="normal"><primary>B-trees</primary><secondary>CouchDB storage engine</secondary></indexterm></para><figure float="none" id="figure_2_2"><title>Anatomy of a view request</title><mediaobject id="I_mediaobject2_d1e796"><imageobject role="print"><imagedata fileref="figs/print/codb_0202.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0202.png" format="PNG"/></imageobject></mediaobject></figure><para>CouchDB uses MapReduce to compute the results of a view. MapReduce
      makes use of two functions, “map” and “reduce,” which are applied to
      each document in isolation. Being able to isolate these operations means
      that view computation lends itself to parallel and incremental
      computation. More important, because these functions produce key/value
      pairs, CouchDB is able to insert them into the B-tree storage engine,
      sorted by key. Lookups by key, or key range, are extremely efficient
      operations with a B-tree, described in <emphasis>big O
      notation</emphasis> as <emphasis>O(log N)</emphasis> and <emphasis>O(log
      N + K)</emphasis>, respectively.<indexterm id="I_indexterm2_d1e812" significance="normal"><primary>MapReduce</primary><secondary>use by CouchDB</secondary></indexterm></para><para>In CouchDB, we access documents and view results by key or key
      range. This is a direct mapping to the underlying operations performed
      on CouchDB’s B-tree storage engine. Along with document inserts and
      updates, this direct mapping is the reason we describe CouchDB’s API as
      being a thin wrapper around the database core.</para><para>Being able to access results by key alone is a very important
      restriction because it allows us to make huge performance gains. As well
      as the massive speed improvements, we can partition our data over
      multiple nodes, without affecting our ability to query each node in
      isolation. <emphasis>BigTable</emphasis>, <emphasis>Hadoop</emphasis>,
      <emphasis>SimpleDB</emphasis>, and <emphasis>memcached</emphasis>
      restrict object lookups by key for exactly these reasons.</para></sect2><sect2><title>No Locking</title><para>A table in a relational database is a single data structure. If
      you want to modify a <phrase role="keep-together">table—</phrase>say,
      update a row—the database system must ensure that nobody else is trying
      to update that row and that nobody can read from that row while it is
      being updated. The common way to handle this uses what’s known as a
      <emphasis>lock</emphasis>. If multiple clients want to access a table,
      the first client gets the lock, making everybody else wait. When the
      first client’s request is processed, the next client is given access
      while everybody else waits, and so on. This serial execution of
      requests, even when they arrived in parallel, wastes a significant
      amount of your server’s processing power. Under high load, a relational
      database can spend more time figuring out who is allowed to do what, and
      in which order, than it does doing any actual work.<indexterm id="I_indexterm2_d1e844" significance="normal"><primary>concurrency control</primary><secondary>MVCC versus locking</secondary></indexterm><indexterm id="I_indexterm2_d1e849" significance="normal"><primary>locking, MVCC versus</primary></indexterm></para><para>Instead of locks, CouchDB uses <emphasis>Multi-Version Concurrency
      Control (MVCC)</emphasis> to manage concurrent access to the database.
      <xref linkend="figure_2_3"/> illustrates the differences between MVCC
      and traditional locking mechanisms. MVCC means that CouchDB can run at
      full speed, all the time, even under high load. Requests are run in
      parallel, making excellent use of every last drop of processing power
      your server has to offer.<indexterm id="I_indexterm2_d1e859" significance="normal"><primary>MVCC (Multi-Version Concurrency Control)</primary></indexterm></para><figure float="none" id="figure_2_3"><title>MVCC means no locking</title><mediaobject id="I_mediaobject2_d1e865"><imageobject role="print"><imagedata fileref="figs/print/codb_0203.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0203.png" format="PNG"/></imageobject></mediaobject></figure><para>Documents in CouchDB are versioned, much like they would be in a
      regular version control system such as Subversion. If you want to change
      a value in a document, you create an entire new version of that document
      and save it over the old one. After doing this, you end up with two
      versions of the same document, one old and one new.<indexterm id="I_indexterm2_d1e872" significance="normal"><primary>versioned documents</primary></indexterm><indexterm id="I_indexterm2_d1e875" significance="normal"><primary>documents</primary><secondary>versioned, in CouchDB</secondary></indexterm></para><para>How does this offer an improvement over locks? Consider a set of
      requests wanting to access a document. The first request reads the
      document. While this is being processed, a second request changes the
      document. Since the second request includes a completely new version of
      the document, CouchDB can simply append it to the database without
      having to wait for the read request to finish.</para><para>When a third request wants to read the same document, CouchDB will
      point it to the new version that has just been written. During this
      whole process, the first request could still be reading the original
      version.</para><para>A read request will always see the most recent snapshot of your
      database.<indexterm id="I_indexterm2_d1e886" significance="normal"><primary>concurrency control</primary><seealso>MVCC</seealso></indexterm></para></sect2><sect2><title>Validation</title><para>As application developers, we have to think about what sort of
      input we should accept and what we should reject. The expressive power
      to do this type of validation over complex data
      <emphasis>within</emphasis> a traditional relational database leaves a
      lot to be desired. Fortunately, CouchDB provides a powerful way to
      perform per-document validation from within the database.<indexterm id="I_indexterm2_d1e899" significance="normal"><primary>validation</primary></indexterm></para><para>CouchDB can validate documents using JavaScript functions similar
      to those used for MapReduce. Each time you try to modify a document,
      CouchDB will pass the validation function a copy of the existing
      document, a copy of the new document, and a collection of additional
      information, such as user authentication details. The validation
      function now has the opportunity to approve or deny the
      update.<indexterm id="I_indexterm2_d1e904" significance="normal"><primary>JavaScript</primary><secondary>document validation using</secondary></indexterm></para><para>By working with the grain and letting CouchDB do this for us, we
      save ourselves a tremendous amount of CPU cycles that would otherwise
      have been spent serializing object graphs from SQL, converting them into
      domain objects, and using those objects to do application-level
      validation.<indexterm id="I_indexterm2_d1e911" class="endofrange" startref="ch02_consistencylocal" significance="normal"/></para></sect2></sect1><sect1 id="I_sect12_d1e912"><title>Distributed Consistency</title><para>Maintaining consistency within a single database node is relatively
    easy for most <phrase role="keep-together">databases</phrase>. The real
    problems start to surface when you try to maintain consistency between
    multiple database servers. If a client makes a write operation on server
    <emphasis>A</emphasis>, how do we make sure that this is consistent with
    server <emphasis>B</emphasis>, or <emphasis>C</emphasis>, or
    <emphasis>D</emphasis>? For relational databases, this is a very complex
    problem with entire books devoted to its solution. You could use
    multi-master, master/slave, partitioning, sharding, write-through caches,
    and all sorts of other complex techniques.<indexterm class="startofrange" id="ch02_consistencydist" significance="normal"><primary>consistency</primary><secondary>distributed</secondary></indexterm></para><sect2><title>Incremental Replication</title><para>Because CouchDB operations take place within the context of a
      single document, if you want to use two database nodes, you no longer
      have to worry about them staying in constant communication. CouchDB
      achieves <emphasis>eventual consistency</emphasis> between <phrase role="keep-together">data</phrase><phrase role="keep-together">bases</phrase> by using incremental replication, a
      process where document changes are periodically copied between servers.
      We are able to build what’s known as a <emphasis>shared
      nothing</emphasis> cluster of databases where each node is independent
      and self-sufficient, leaving no single point of contention across the
      system.<indexterm id="I_indexterm2_d1e954" significance="normal"><primary>incremental replication</primary></indexterm><indexterm id="I_indexterm2_d1e957" significance="normal"><primary>replication</primary><secondary>incremental, between CouchDB nodes</secondary></indexterm><indexterm id="I_indexterm2_d1e962" significance="normal"><primary>eventual consistency</primary></indexterm></para><para>Need to scale out your CouchDB database cluster? Just throw in
      another server.</para><para>As illustrated in <xref linkend="figure_2_4"/>, with CouchDB’s
      incremental replication, you can synchronize your data between any two
      databases however you like and whenever you like. After replication,
      each database is able to work independently.</para><para>You could use this feature to synchronize database servers within
      a cluster or between data centers using a job scheduler such as
      <emphasis>cron</emphasis>, or you could use it to synchronize data with
      your laptop for offline work as you travel. Each database can be used in
      the usual fashion, and changes between databases can be synchronized
      later in both directions.<indexterm id="I_indexterm2_d1e976" significance="normal"><primary>conflict detection and resolution</primary></indexterm></para><figure float="none" id="figure_2_4"><title>Incremental replication between CouchDB nodes</title><mediaobject id="I_mediaobject2_d1e982"><imageobject role="print"><imagedata fileref="figs/print/codb_0204.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0204.png" format="PNG"/></imageobject></mediaobject></figure><para>What happens when you change the same document in two different
      databases and want to synchronize these with each other? CouchDB’s
      replication system comes with automatic conflict detection
      <emphasis>and</emphasis> resolution. When CouchDB detects that a
      document has been changed in both databases, it flags this document as
      being in conflict, much like they would be in a regular version control
      system.</para><para>This isn’t as troublesome as it might first sound. When two
      versions of a document conflict during replication, the
      <emphasis>winning</emphasis> version is saved as the most recent version
      in the document’s history. Instead of throwing the
      <emphasis>losing</emphasis> version away, as you might expect, CouchDB
      saves this as a previous version in the document’s history, so that you
      can access it if you need to. This happens automatically and
      consistently, so both databases will make exactly the same
      choice.</para><para>It is up to you to handle conflicts in a way that makes sense for
      your application. You can leave the chosen document versions in place,
      revert to the older version, or try to merge the two versions and save
      the result.</para></sect2><sect2><title>Case Study</title><para>Greg Borenstein, a friend and coworker, built a small library for
      converting Songbird playlists to JSON objects and decided to store these
      in CouchDB as part of a backup application. The completed software uses
      CouchDB’s MVCC and document revisions to ensure that Songbird playlists
      are backed up robustly between nodes.</para><note><para>Songbird is a free software media player with an integrated web
        browser, based on the Mozilla XULRunner platform. Songbird is
        available for Microsoft Windows, Apple Mac OS X, Solaris, and
        Linux.</para></note><?dbfo-need height=”1in”
?><para>Let’s examine the workflow of the Songbird backup application,
      first as a user backing up from a single computer, and then using
      Songbird to synchronize playlists between multiple computers. We’ll see
      how document revisions turn what could have been a hairy problem into
      something that <emphasis>just works</emphasis>.</para><para>The first time we use this backup application, we feed our
      playlists to the application and initiate a backup. Each playlist is
      converted to a JSON object and handed to a CouchDB database. As
      illustrated in <xref linkend="figure_2_5"/>, CouchDB hands back the
      document ID and revision of each playlist as it’s saved to the
      database.</para><figure float="none" id="figure_2_5"><title>Backing up to a single database</title><mediaobject id="I_mediaobject2_d1e1023"><imageobject role="print"><imagedata fileref="figs/print/codb_0205.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0205.png" format="PNG"/></imageobject></mediaobject></figure><para>After a few days, we find that our playlists have been updated and
      we want to back up our changes. After we have fed our playlists to the
      backup application, it fetches the latest versions from CouchDB, along
      with the corresponding document revisions. When the application hands
      back the new playlist document, CouchDB requires that the document
      revision is included in the request.</para><para>CouchDB then makes sure that the document revision handed to it in
      the request matches the current revision held in the database. Because
      CouchDB updates the revision with every modification, if these two are
      out of synchronization it suggests that someone else has made changes to
      the document between the time we requested it from the database and the
      time we sent our updates. Making changes to a document after someone
      else has modified it without first inspecting those changes is usually a
      bad idea.<indexterm id="I_indexterm2_d1e1032" significance="normal"><primary>synchronization, database</primary></indexterm></para><para>Forcing clients to hand back the correct document revision is the
      heart of CouchDB’s optimistic concurrency.</para><para>We have a laptop we want to keep synchronized with our desktop
      computer. With all our playlists on our desktop, the first step is to
      “restore from backup” onto our laptop. This is the first time we’ve done
      this, so afterward our laptop should hold an exact replica of our
      desktop playlist collection.</para><para>After editing our Argentine Tango playlist on our laptop to add a
      few new songs we’ve purchased, we want to save our changes. The backup
      application replaces the playlist document in our laptop CouchDB
      database and a new document revision is generated. A few days later, we
      remember our new songs and want to copy the playlist across to our
      desktop computer. As illustrated in <xref linkend="figure_2_6"/>, the
      backup application copies the new document and the new revision to the
      desktop CouchDB database. Both CouchDB databases now have the same
      document revision.</para><figure float="none" id="figure_2_6"><title>Synchronizing between two databases</title><mediaobject id="I_mediaobject2_d1e1047"><imageobject role="print"><imagedata fileref="figs/print/codb_0206.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0206.png" format="PNG"/></imageobject></mediaobject></figure><para>Because CouchDB tracks document revisions, it ensures that updates
      like these will work only if they are based on current information. If
      we had made modifications to the playlist backups between
      synchronization, things wouldn’t go as smoothly.</para><para>We back up some changes on our laptop and forget to synchronize. A
      few days later, we’re editing playlists on our desktop computer, make a
      backup, and want to synchronize this to our laptop. As illustrated in
      <xref linkend="figure_2_7"/>, when our backup application tries to
      replicate between the two databases, CouchDB sees that the changes being
      sent from our desktop computer are modifications of out-of-date
      documents and helpfully informs us that there has been a
      conflict.</para><para>Recovering from this error is easy to accomplish from an
      application perspective. Just download CouchDB’s version of the playlist
      and provide an opportunity to merge the changes or save local
      modifications into a new playlist.<indexterm id="I_indexterm2_d1e1060" class="endofrange" startref="ch02_consistencydist" significance="normal"/></para><figure float="none" id="figure_2_7"><title>Synchronization conflicts between two databases</title><mediaobject id="I_mediaobject2_d1e1064"><imageobject role="print"><imagedata fileref="figs/print/codb_0207.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0207.png" format="PNG"/></imageobject></mediaobject></figure></sect2></sect1><sect1 id="I_sect12_d1e1069"><title>Wrapping Up</title><para>CouchDB’s design borrows heavily from web architecture and the
    lessons learned deploying massively distributed systems on that
    architecture. By understanding why this architecture works the way it
    does, and by learning to spot which parts of your application can be
    easily distributed and which parts cannot, you’ll enhance your ability to
    design distributed and scalable applications, with CouchDB or without
    it.</para><para>We’ve covered the main issues surrounding CouchDB’s consistency
    model and hinted at some of the benefits to be had when you work
    <emphasis>with</emphasis> CouchDB and not against it. But enough
    theory—let’s get up and running and see what all the fuss is about!</para></sect1></chapter><chapter id="gettingstarted"><title>Getting Started</title><para>In this chapter, we’ll take a quick tour of CouchDB’s features,
  familiarizing ourselves with <emphasis>Futon</emphasis>, the built-in
  administration interface. We’ll create our first document and experiment
  with CouchDB views. Before we start, skip to <xref linkend="installingfromsource"/> and look for your operating system. You
  will need to follow those instructions and get CouchDB installed before you
  can progress.</para><sect1 id="I_sect13_d1e1089"><title>All Systems Are Go!</title><para>We’ll have a very quick look at CouchDB’s bare-bones
    <emphasis>Application Programming Interface (API)</emphasis> by using the
    command-line utility <literal moreinfo="none">curl</literal>. Please note that this is
    only one way of talking to CouchDB. We will show you plenty more
    throughout the rest of the book. What’s interesting about
    <literal moreinfo="none">curl</literal> is that it gives you control over raw HTTP
    requests, and you can see exactly what is going on “underneath the hood”
    of your database.<indexterm id="I_indexterm3_d1e1103" significance="normal"><primary>HTTP requests</primary></indexterm><indexterm class="startofrange" id="ch03_getstartAPI" significance="normal"><primary>getting started with CouchDB</primary><secondary>bare-bones API</secondary></indexterm><indexterm class="startofrange" id="ch03_APIcurl" significance="normal"><primary>API</primary><secondary>exploring bare-bones CouchDB API using curl
        utility</secondary></indexterm><indexterm id="I_indexterm3_d1e1116" significance="normal"><primary>GET requests</primary><secondary>issuing with curl</secondary></indexterm><indexterm id="I_indexterm3_d1e1122" significance="normal"><primary>curl command</primary></indexterm></para><para>Make sure CouchDB is still running, and then do:</para><screen format="linespecific">curl http://127.0.0.1:5984/</screen><para>This issues a <literal moreinfo="none">GET</literal> request to your newly installed
    CouchDB instance.</para><para>The reply should look something like:</para><programlisting id="I_programlisting3_d1e1136" language="javascript" linenumbering="unnumbered" format="linespecific">{"couchdb":"Welcome","version":"0.10.1"}</programlisting><para>Not all that spectacular. CouchDB is saying “hello” with the running
    version number.</para><para>Next, we can get a list of databases:<indexterm id="I_indexterm3_d1e1142" significance="normal"><primary>curl command</primary><secondary>-X GET option</secondary></indexterm></para><screen format="linespecific">curl -X GET http://127.0.0.1:5984/_all_dbs</screen><para>All we added to the previous request is the
    <literal moreinfo="none">_all_dbs</literal> string.</para><para>The response should look like:</para><screen format="linespecific">[]</screen><para>Oh, that’s right, we didn’t create any databases yet! All we see is
    an empty list.</para><note><para>The <literal moreinfo="none">curl</literal> command issues <literal moreinfo="none">GET</literal>
      requests by default. You can issue <literal moreinfo="none">POST</literal> requests
      using <literal moreinfo="none">curl -X POST</literal>. To make it easy to work with our
      terminal history, we usually use the <literal moreinfo="none">-X</literal> option even
      when issuing <literal moreinfo="none">GET</literal> requests. If we want to send a
      <literal moreinfo="none">POST</literal> next time, all we have to change is the
      method.<indexterm id="I_indexterm3_d1e1186" significance="normal"><primary>curl command</primary><secondary>-X POST option</secondary></indexterm><indexterm id="I_indexterm3_d1e1191" significance="normal"><primary>POST requests</primary><secondary>issuing with curl</secondary></indexterm></para><para>HTTP does a bit more under the hood than you can see in the
      examples here. If you’re interested in every last detail that goes over
      the wire, pass in the <literal moreinfo="none">-v</literal> option (e.g., <literal moreinfo="none">curl
      -vX GET</literal>), which will show you the server
      <literal moreinfo="none">curl</literal> tries to connect to, the request headers it
      sends, and response headers it receives back. Great for
      debugging!<indexterm id="I_indexterm3_d1e1207" significance="normal"><primary>curl command</primary><secondary>-v option</secondary></indexterm></para></note><para>Let’s create a database:</para><screen format="linespecific">curl -X PUT http://127.0.0.1:5984/baseball</screen><para>CouchDB will reply with:</para><programlisting id="I_programlisting3_d1e1218" language="javascript" linenumbering="unnumbered" format="linespecific">{"ok":true}</programlisting><para>Retrieving the list of databases again shows some useful results
    this time:<indexterm id="I_indexterm3_d1e1222" significance="normal"><primary>JavaScript Object Notation</primary><see>JSON</see></indexterm></para><screen format="linespecific">curl -X GET http://127.0.0.1:5984/_all_dbs</screen><programlisting id="I_programlisting3_d1e1229" language="javascript" linenumbering="unnumbered" format="linespecific">["baseball"]</programlisting><note><para>We should mention <emphasis>JavaScript Object Notation
      (JSON)</emphasis> here, the data format CouchDB speaks. JSON is a
      lightweight data interchange format based on JavaScript syntax. Because
      JSON is natively compatible with JavaScript, your web browser is an
      ideal client for CouchDB.<indexterm id="I_indexterm3_d1e1238" significance="normal"><primary>web browsers</primary><secondary>ideal clients for CouchDB</secondary></indexterm><indexterm id="I_indexterm3_d1e1243" significance="normal"><primary>JSON (JavaScript Object Notation)</primary></indexterm></para><para>Brackets (<literal moreinfo="none">[]</literal>) represent ordered lists, and
      curly braces (<literal moreinfo="none">{}</literal>) represent key/value dictionaries.
      Keys must be strings, delimited by quotes (<literal moreinfo="none">"</literal>), and
      values can be strings, numbers, booleans, lists, or key/value
      dictionaries. For a more detailed description of JSON, see <xref linkend="jsonprimer"/>.<indexterm id="I_indexterm3_d1e1259" significance="normal"><primary>arrays</primary></indexterm><indexterm id="I_indexterm3_d1e1262" significance="normal"><primary>objects</primary><secondary>JSON syntax</secondary></indexterm><indexterm id="I_indexterm3_d1e1268" significance="normal"><primary>strings</primary></indexterm><indexterm id="I_indexterm3_d1e1271" significance="normal"><primary>" (quotation marks), delimiting JSON strings</primary></indexterm><indexterm id="I_indexterm3_d1e1274" significance="normal"><primary>ordered lists</primary><secondary>in JSON</secondary></indexterm><indexterm id="I_indexterm3_d1e1279" significance="normal"><primary>key/value dictionaries in JSON</primary></indexterm><indexterm id="I_indexterm3_d1e1282" significance="normal"><primary>{ } (curly braces), enclosing objects in JSON</primary></indexterm><indexterm id="I_indexterm3_d1e1285" significance="normal"><primary>[ ] (square brackets), enclosing arrays in JSON</primary></indexterm></para></note><para>Let’s create another database:<indexterm id="I_indexterm3_d1e1290" significance="normal"><primary>PUT requests</primary></indexterm><indexterm id="I_indexterm3_d1e1293" significance="normal"><primary>curl command</primary><secondary>-X PUT option</secondary></indexterm></para><screen format="linespecific">curl -X PUT http://127.0.0.1:5984/baseball</screen><para>CouchDB will reply with:</para><programlisting id="I_programlisting3_d1e1302" language="javascript" linenumbering="unnumbered" format="linespecific">{"error":"file_exists","reason":"The database could not be created, the file 
already exists."}</programlisting><para>We already have a database with that name, so CouchDB will respond
    with an error. Let’s try again with a different database name:</para><screen format="linespecific">curl -X PUT http://127.0.0.1:5984/plankton</screen><para>CouchDB will reply with:</para><programlisting id="I_programlisting3_d1e1310" language="javascript" linenumbering="unnumbered" format="linespecific">{"ok":true}</programlisting><para>Retrieving the list of databases yet again shows some useful
    results:</para><screen format="linespecific">curl -X GET http://127.0.0.1:5984/_all_dbs</screen><para>CouchDB will respond with:</para><programlisting id="I_programlisting3_d1e1319" language="javascript" linenumbering="unnumbered" format="linespecific">["baseball", "plankton"]</programlisting><para>To round things off, let’s delete the second database:<indexterm id="I_indexterm3_d1e1323" significance="normal"><primary>DELETE requests</primary></indexterm><indexterm id="I_indexterm3_d1e1326" significance="normal"><primary>curl command</primary><secondary>-X DELETE option</secondary></indexterm></para><screen format="linespecific">curl -X DELETE http://127.0.0.1:5984/plankton</screen><para>CouchDB will reply with:</para><programlisting id="I_programlisting3_d1e1335" language="javascript" linenumbering="unnumbered" format="linespecific">{"ok":true}</programlisting><para>The list of databases is now the same as it was before:</para><screen format="linespecific">curl -X GET http://127.0.0.1:5984/_all_dbs</screen><para>CouchDB will respond with:</para><programlisting id="I_programlisting3_d1e1343" language="javascript" linenumbering="unnumbered" format="linespecific">["baseball"]</programlisting><para>For brevity, we’ll skip working with documents, as the next section
    covers a different and potentially easier way of working with CouchDB that
    should provide experience with this. As we work through the example, keep
    in mind that “under the hood” <phrase role="keep-together">everything</phrase> is being done by the application
    exactly as you have been doing here manually. Everything is done using
    <literal moreinfo="none">GET</literal>, <literal moreinfo="none">PUT</literal>, <literal moreinfo="none">POST</literal>,
    and <literal moreinfo="none">DELETE</literal> with a URI.<indexterm id="I_indexterm3_d1e1363" class="endofrange" startref="ch03_APIcurl" significance="normal"/><indexterm id="I_indexterm3_d1e1364" class="endofrange" startref="ch03_getstartAPI" significance="normal"/></para></sect1><sect1 id="I_sect13_d1e1365"><title>Welcome to Futon</title><para>After having seen CouchDB’s raw API, let’s get our feet wet by
    playing with Futon, the built-in administration interface. Futon provides
    full access to all of CouchDB’s features and makes it easy to work with
    some of the more complex ideas involved. With Futon we can create and
    destroy databases; view and edit documents; compose and run MapReduce
    views; and trigger replication between databases.<indexterm id="I_indexterm3_d1e1370" significance="normal"><primary>getting started with CouchDB</primary><secondary>Futon administrative interface</secondary></indexterm><indexterm id="I_indexterm3_d1e1375" significance="normal"><primary>Futon</primary></indexterm></para><para>To load Futon in your browser, visit:<indexterm id="I_indexterm3_d1e1380" significance="normal"><primary>web browsers</primary><secondary>loading Futon</secondary></indexterm></para><screen format="linespecific">http://127.0.0.1:5984/_utils/</screen><para>If you’re running version 0.9 or later, you should see something
    similar to <xref linkend="figure_3_1"/>. In later chapters, we’ll focus
    on using CouchDB from server-side languages such as Ruby and Python. As
    such, this chapter is a great opportunity to showcase an example of
    natively serving up a dynamic web application using nothing more than
    CouchDB’s integrated web server, something you may wish to do with your
    own applications.</para><para>The first thing we should do with a fresh installation of CouchDB is
    run the test suite to verify that everything is working properly. This
    assures us that any problems we may run into aren’t due to bothersome
    issues with our setup. By the same token, failures in the Futon test suite
    are a red flag, telling us to double-check our installation before
    attempting to use a potentially broken database server, saving us the
    confusion when nothing seems to be working quite like we expect!<indexterm id="I_indexterm3_d1e1393" significance="normal"><primary>Futon</primary><secondary>running test suite</secondary></indexterm></para><figure float="none" id="figure_3_1"><title>The Futon welcome screen</title><mediaobject id="I_mediaobject3_d1e1401"><imageobject role="print"><imagedata fileref="figs/print/codb_0301.pdf" format="PDF" scale="95"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0301.png" format="PNG" scale="95"/></imageobject></mediaobject></figure><warning><para>Some common network configurations cause the replication test to
      fail when accessed via the <literal moreinfo="none">localhost</literal> address. You can
      fix this by accessing CouchDB via
      <emphasis>http://127.0.0.1:5984/_utils/</emphasis>.</para></warning><para>Navigate to the test suite by clicking “Test Suite” on the Futon
    sidebar, then click “run all” at the top to kick things off. <xref linkend="figure_3_2"/> shows the Futon test suite running some
    tests.</para><figure id="figure_3_2" float="0"><title>The Futon test suite running some tests</title><mediaobject id="I_mediaobject3_d1e1422"><imageobject role="print"><imagedata fileref="figs/print/codb_0302.pdf" format="PDF" scale="95"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0302.png" format="PNG" scale="95"/></imageobject></mediaobject></figure><para>Because the test suite is run from the browser, not only does it
    test that CouchDB is functioning properly, it also verifies that your
    browser’s connection to the database is properly configured, which can be
    very handy for diagnosing misbehaving proxies or other HTTP
    middleware.</para><warning><para>If the test suite has an inordinate number of failures, you’ll
      need to see the troubleshooting section in <xref linkend="installingfromsource"/> for the next steps to fix your
      installation.</para></warning><para>Now that the test suite is finished, you’ve verified that your
    CouchDB installation is successful and you’re ready to see what else Futon
    has to offer.</para></sect1><sect1 id="I_sect13_d1e1437"><title>Your First Database and Document</title><para>Creating a database in Futon is simple. From the overview page,
    click “Create Database.” When asked for a name, enter
    <literal moreinfo="none">hello-world</literal> and click the Create button.<indexterm id="I_indexterm3_d1e1445" significance="normal"><primary>getting started with CouchDB</primary><secondary>creating a database and document</secondary></indexterm></para><para>After your database has been created, Futon will display a list of
    all its documents. This list will start out empty (<xref linkend="figure_3_3"/>), so let’s create our first document. Click the
    “Create Document” link and then the Create button in the pop up. Make sure
    to leave the document ID blank, and CouchDB will generate a UUID for
    you.<indexterm id="I_indexterm3_d1e1454" significance="normal"><primary>UUIDs (universally unique identifiers)</primary><secondary>for documents</secondary></indexterm><indexterm id="I_indexterm3_d1e1459" significance="normal"><primary>documents</primary><secondary>creating</secondary></indexterm></para><warning><para>For demoing purposes, having CouchDB assign a UUID is fine. When
      you write your first programs, we recommend assigning your own UUIDs. If
      your rely on the server to generate the UUID and you end up making two
      POST requests because the first POST request bombed out, you might
      generate two docs and never find out about the first one because only
      the second one will be reported back. Generating your own UUIDs makes
      sure that you’ll never end up with duplicate documents.<indexterm id="I_indexterm3_d1e1467" significance="normal"><primary>POST requests</primary></indexterm></para></warning><para>Futon will display the newly created document, with its
    <literal moreinfo="none">_id</literal> and <literal moreinfo="none">_rev</literal> as the only fields. To
    create a new field, click the “Add Field” button. We’ll call the new field
    <literal moreinfo="none">hello</literal>. Click the green check icon (or hit the Enter
    key) to finalize creating the <literal moreinfo="none">hello</literal> field. Double-click
    the <literal moreinfo="none">hello</literal> field’s value (default
    <literal moreinfo="none">null</literal>) to edit it.<indexterm id="I_indexterm3_d1e1491" significance="normal"><primary sortas="id field, documents">_id field, documents</primary></indexterm><indexterm id="I_indexterm3_d1e1494" significance="normal"><primary sortas="rev field, documents">_rev field, documents</primary></indexterm></para><para>If you try to enter <literal moreinfo="none">world</literal> as the new value,
    you’ll get an error when you click the value’s green check icon. CouchDB
    values must be entered as valid JSON. Instead, enter
    <literal moreinfo="none">"world"</literal> (with quotes) because this is a valid JSON
    string. You should have no problems saving it. You can experiment with
    other JSON values; e.g., <literal moreinfo="none">[1, 2, "c"]</literal> or
    <literal moreinfo="none">{"foo":"bar"}</literal>. Once you’ve entered your values into the
    document, make a note of its <literal moreinfo="none">_rev</literal> attribute and click
    “Save Document.” The result should look like <xref linkend="figure_3_4"/>.<indexterm id="I_indexterm3_d1e1517" significance="normal"><primary>JSON (JavaScript Object Notation)</primary><secondary>source of “hello world” document in Futon</secondary></indexterm></para><figure float="none" id="figure_3_3"><title>An empty database in Futon</title><mediaobject id="I_mediaobject3_d1e1525"><imageobject role="print"><imagedata fileref="figs/print/codb_0303.pdf" format="PDF" scale="95"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0303.png" format="PNG" scale="95"/></imageobject></mediaobject></figure><figure float="none" id="figure_3_4"><title>A “hello world” document in Futon</title><mediaobject id="I_mediaobject3_d1e1533"><imageobject role="print"><imagedata fileref="figs/print/codb_0304.pdf" format="PDF" scale="95"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0304.png" format="PNG" scale="95"/></imageobject></mediaobject></figure><para>You’ll notice that the document’s <literal moreinfo="none">_rev</literal> has
    changed. We’ll go into more detail about this in later chapters, but for
    now, the important thing to note is that <literal moreinfo="none">_rev</literal> acts like
    a safety feature when saving a document. As long as you and CouchDB agree
    on the most recent <literal moreinfo="none">_rev</literal> of a document, you can
    successfully save your changes.</para><para>Futon also provides a way to display the underlying JSON data, which
    can be more compact and easier to read, depending on what sort of data you
    are dealing with. To see the JSON version of our “hello world” document,
    click the Source tab. The result should look like <xref linkend="figure_3_5"/>.</para><figure float="none" id="figure_3_5"><title>The JSON source of a “hello world” document in Futon</title><mediaobject id="I_mediaobject3_d1e1556"><imageobject role="print"><imagedata fileref="figs/print/codb_0305.pdf" format="PDF" scale="95"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0305.png" format="PNG" scale="95"/></imageobject></mediaobject></figure></sect1><sect1 id="I_sect13_d1e1561"><title>Running a Query Using MapReduce</title><para>Traditional relational databases allow you to run any queries you
    like as long as your data is structured correctly. In contrast, CouchDB
    uses predefined <emphasis>map</emphasis> and <emphasis>reduce</emphasis>
    functions in a style known as MapReduce. These functions provide great
    flexibility because they can adapt to variations in document structure,
    and indexes for each document can be computed independently and in
    parallel. The combination of a map and a reduce function is called a
    <emphasis>view</emphasis> in CouchDB terminology.<indexterm id="I_indexterm3_d1e1575" significance="normal"><primary>views</primary><secondary>defined</secondary></indexterm><indexterm class="startofrange" id="ch03_getstartMapReduce" significance="normal"><primary>getting started with CouchDB</primary><secondary>running a query using MapReduce</secondary></indexterm><indexterm class="startofrange" id="ch03_MapReducequery" significance="normal"><primary>MapReduce</primary><secondary>running a query using</secondary></indexterm></para><note><para>For experienced relational database programmers, MapReduce can
      take some getting used to. Rather than declaring which rows from which
      tables to include in a result set and depending on the database to
      determine the most efficient way to run the query, reduce queries are
      based on simple range requests against the indexes generated by your map
      functions.</para></note><para>Map functions are called once with each document as the argument.
    The function can choose to skip the document altogether or
    <emphasis>emit</emphasis> one or more view rows as key/value pairs. Map
    functions may not depend on any information outside of the document. This
    independence is what allows CouchDB views to be generated incrementally
    and in parallel.<indexterm class="startofrange" id="ch03_views" significance="normal"><primary>views</primary><secondary>creating</secondary></indexterm></para><para>CouchDB views are stored as rows that are kept sorted by key. This
    makes retrieving data from a range of keys efficient even when there are
    thousands or millions of rows. When writing CouchDB map functions, your
    primary goal is to build an index that stores related data under nearby
    keys.<indexterm id="I_indexterm3_d1e1605" significance="normal"><primary>documents</primary><secondary>creating</secondary><tertiary>example document for MapReduce view</tertiary></indexterm></para><para>Before we can run an example MapReduce view, we’ll need some data to
    run it on. We’ll create documents carrying the price of various
    supermarket items as found at different stores. Let’s create documents for
    apples, oranges, and bananas. (Allow CouchDB to generate the
    <literal moreinfo="none">_id</literal> and <literal moreinfo="none">_rev</literal> fields.) Use Futon to
    create documents that have a final JSON structure that looks like
    this:<indexterm id="I_indexterm3_d1e1620" significance="normal"><primary>MapReduce</primary><secondary>running a query using</secondary><tertiary>creating example documents</tertiary></indexterm><indexterm id="I_indexterm3_d1e1627" significance="normal"><primary>JSON (JavaScript Object Notation)</primary><secondary>example documents for MapReduce view</secondary></indexterm></para><programlisting id="I_programlisting3_d1e1632" language="javascript" linenumbering="unnumbered" format="linespecific">{
    "_id" : "bc2a41170621c326ec68382f846d5764",
    "_rev" : "2612672603",
    "item" : "apple",
    "prices" : {
        "Fresh Mart" : 1.59,
        "Price Max" : 5.99,
        "Apples Express" : 0.79
    }
}</programlisting><para>This document should look like <xref linkend="figure_3_6"/> when
    entered into Futon.</para><figure float="none" id="figure_3_6"><title>An example document with apple prices in Futon</title><mediaobject id="I_mediaobject3_d1e1641"><imageobject role="print"><imagedata fileref="figs/print/codb_0306.pdf" format="PDF" scale="95"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0306.png" format="PNG" scale="95"/></imageobject></mediaobject></figure><para>OK, now that that’s done, let’s create the document for
    oranges:</para><programlisting id="I_programlisting3_d1e1648" language="javascript" linenumbering="unnumbered" format="linespecific">{
    "_id" : "bc2a41170621c326ec68382f846d5764",
    "_rev" : "2612672603",
    "item" : "orange",
    "prices" : {
        "Fresh Mart" : 1.99,
        "Price Max" : 3.19,
        "Citrus Circus" : 1.09
    }
}</programlisting><para>And finally, the document for bananas:</para><programlisting id="I_programlisting3_d1e1653" language="javascript" linenumbering="unnumbered" format="linespecific">{
    "_id" : "bc2a41170621c326ec68382f846d5764",
    "_rev" : "2612672603",
    "item" : "banana",
    "prices" : {
        "Fresh Mart" : 1.99,
        "Price Max" : 0.79,
        "Banana Montana" : 4.22
    }
}</programlisting><para>Imagine we’re catering a big luncheon, but the client is very
    price-sensitive. To find the lowest prices, we’re going to create our
    first view, which shows each fruit sorted by price. Click “hello-world” to
    return to the hello-world overview, and then from the “select view” menu
    choose “Temporary view…” to create a new view. The result should look
    something like <xref linkend="figure_3_7"/>.<indexterm id="I_indexterm3_d1e1659" significance="normal"><primary>MapReduce</primary><secondary>running a query using</secondary><tertiary>temporary view in Futon</tertiary></indexterm><indexterm id="I_indexterm3_d1e1666" significance="normal"><primary>Futon</primary><secondary>creating temporary view</secondary></indexterm></para><figure float="none" id="figure_3_7"><title>A temporary view in Futon</title><mediaobject id="I_mediaobject3_d1e1674"><imageobject role="print"><imagedata fileref="figs/print/codb_0307.pdf" format="PDF" scale="95"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0307.png" format="PNG" scale="95"/></imageobject></mediaobject></figure><para>Edit the map function, on the left, so that it looks like the
    following:<indexterm id="I_indexterm3_d1e1681" significance="normal"><primary>MapReduce</primary><secondary>running a query using</secondary><tertiary>editing map function</tertiary></indexterm></para><programlisting id="I_programlisting3_d1e1688" language="javascript" linenumbering="unnumbered" format="linespecific">function(doc) {
    var store, price, value;
    if (doc.item &amp;&amp; doc.prices) {
        for (store in doc.prices) {
            price = doc.prices[store];
            value = [doc.item, store];
            emit(price, value);
        }
    }
}</programlisting><para>This is a <emphasis>JavaScript</emphasis> function that CouchDB runs
    for each of our documents as it computes the view. We’ll leave the reduce
    function blank for the time being.</para><para>Click “Run” and you should see result rows like in <xref linkend="figure_3_8"/>, with the various items sorted by price. This map
    function could be even more useful if it grouped the items by type so that
    all the prices for bananas were next to each other in the result set.
    CouchDB’s key sorting system allows any valid JSON object as a key. In
    this case, we’ll emit an array of <literal moreinfo="none">[item, price]</literal> so that
    CouchDB groups by item type and price.<indexterm id="I_indexterm3_d1e1702" significance="normal"><primary>MapReduce</primary><secondary>running a query using</secondary><tertiary>results of running a view in Futon</tertiary></indexterm></para><figure float="none" id="figure_3_8"><title>The results of running a view in Futon</title><mediaobject id="I_mediaobject3_d1e1712"><imageobject role="print"><imagedata fileref="figs/print/codb_0308.pdf" format="PDF" scale="95"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0308.png" format="PNG" scale="95"/></imageobject></mediaobject></figure><para>Let’s modify the view function so that it looks like this:<indexterm id="I_indexterm3_d1e1719" significance="normal"><primary>MapReduce</primary><secondary>running a query using</secondary><tertiary>modifying view function</tertiary></indexterm></para><programlisting id="I_programlisting3_d1e1726" language="javascript" linenumbering="unnumbered" format="linespecific">function(doc) {
    var store, price, key;
    if (doc.item &amp;&amp; doc.prices) {
        for (store in doc.prices) {
            price = doc.prices[store];
            key = [doc.item, price];
            emit(key, store);
        }
    }
}</programlisting><para>Here, we first check that the document has the fields we want to
    use. CouchDB recovers gracefully from a few isolated map function
    failures, but when a map function fails regularly (due to a missing
    required field or other JavaScript exception), CouchDB shuts off its
    indexing to prevent any further resource usage. For this reason, it’s
    important to check for the existence of any fields before you use them. In
    this case, our map function will skip the first “hello world” document we
    created without emitting any rows or encountering any errors. The result
    of this query should look like <xref linkend="figure_3_9"/>.</para><figure float="none" id="figure_3_9"><title>The results of running a view after grouping by item type and
      price</title><mediaobject id="I_mediaobject3_d1e1736"><imageobject role="print"><imagedata fileref="figs/print/codb_0309.pdf" format="PDF" scale="95"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0309.png" format="PNG" scale="95"/></imageobject></mediaobject></figure><para>Once we know we’ve got a document with an item type and some prices,
    we iterate over the item’s prices and emit key/values pairs. The key is an
    array of the item and the price, and forms the basis for CouchDB’s sorted
    index. In this case, the value is the name of the store where the item can
    be found for the listed price.<indexterm id="I_indexterm3_d1e1743" class="endofrange" startref="ch03_views" significance="normal"/></para><para>View rows are sorted by their keys—in this example, first by item,
    then by price. This method of complex sorting is at the heart of creating
    useful indexes with CouchDB.<indexterm id="I_indexterm3_d1e1746" significance="normal"><primary>views</primary><secondary>sorting in</secondary></indexterm></para><note><para>MapReduce can be challenging, especially if you’ve spent years
      working with relational databases. The important things to keep in mind
      are that map functions give you an opportunity to sort your data using
      any key you choose, and that CouchDB’s design is focused on providing
      fast, efficient access to data within a range of keys.</para></note></sect1><sect1 id="I_sect13_d1e1754"><title>Triggering Replication</title><para>Futon can trigger replication between two local databases, between a
    local and remote database, or even between two remote databases. We’ll
    show you how to replicate data from one local database to another, which
    is a simple way of making backups of your databases as we’re working
    through the examples.<indexterm id="I_indexterm3_d1e1759" significance="normal"><primary>getting started with CouchDB</primary><secondary>triggering replication</secondary></indexterm><indexterm id="I_indexterm3_d1e1764" significance="normal"><primary>replication</primary><secondary>triggering</secondary></indexterm><indexterm id="I_indexterm3_d1e1769" class="endofrange" startref="ch03_getstartMapReduce" significance="normal"/><indexterm id="I_indexterm3_d1e1770" class="endofrange" startref="ch03_MapReducequery" significance="normal"/></para><para>First we’ll need to create an empty database to be the target of
    replication. Return to the overview and create a database called
    <literal moreinfo="none">hello-replication</literal>. Now click “Replicator” in the
    sidebar and choose <literal moreinfo="none">hello-world</literal> as the source and
    <literal moreinfo="none">hello-replication</literal> as the target. Click “Replicate” to
    replicate your database. The result should look something like <xref linkend="figure_3_10"/>.</para><figure float="none" id="figure_3_10"><title>Running database replication in Futon</title><mediaobject id="I_mediaobject3_d1e1787"><imageobject role="print"><imagedata fileref="figs/print/codb_0310.pdf" format="PDF" scale="95"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0310.png" format="PNG" scale="95"/></imageobject></mediaobject></figure><warning><para>For larger databases, replication can take much longer. It is
      important to leave the browser window open while replication is taking
      place. As an alternative, you can trigger replication via
      <literal moreinfo="none">curl</literal> or some other HTTP client that can handle
      long-running connections. If your client closes the connection before
      replication finishes, you’ll have to retrigger it. Luckily, CouchDB’s
      replication can take over from where it left off instead of starting
      from scratch.</para></warning></sect1><sect1 id="I_sect13_d1e1798"><title>Wrapping Up</title><para>Now that you’ve seen most of Futon’s features, you’ll be prepared to
    dive in and inspect your data as we build our example application in the
    next few chapters. Futon’s pure JavaScript approach to managing CouchDB
    shows how it’s possible to build a fully featured web application using
    only CouchDB’s HTTP API and integrated web server.</para><para>But before we get there, we’ll have another look at CouchDB’s HTTP
    API—now with a magnifying glass. Let’s <emphasis>curl</emphasis> on the
    couch and relax.</para></sect1></chapter><chapter id="thecoreapi"><title>The Core API</title><para>This chapter explores the CouchDB in minute detail. It shows all the
  nitty-gritty and clever bits. We show you best practices and guide you
  around common pitfalls.<indexterm class="startofrange" id="ch04_coreAPI" significance="normal"><primary>core CouchDB API</primary></indexterm><indexterm id="I_indexterm4_d1e1816" significance="normal"><primary>API</primary><secondary>core API</secondary><see>core CouchDB API</see></indexterm></para><para>We start out by revisiting the basic operations we ran in the last
  chapter, looking behind the scenes. We also show what Futon needs to do
  behind its user interface to give us the nice features we saw
  earlier.</para><para>This chapter is both an introduction to the core CouchDB API as well
  as a reference. If you can’t remember how to run a particular request or why
  some parameters are needed, you can always come back here and look things up
  (we are probably the heaviest users of this chapter).</para><para>While explaining the API bits and pieces, we sometimes need to take a
  larger detour to explain the reasoning for a particular request. This is a
  good opportunity for us to tell you why CouchDB works the way it
  does.</para><para>The API can be subdivided into the following sections. We’ll explore
  them individually:</para><itemizedlist><listitem><para>Server</para></listitem><listitem><para>Databases</para></listitem><listitem><para>Documents</para></listitem><listitem><para>Replication</para></listitem></itemizedlist><sect1 id="I_sect14_d1e1844"><title>Server</title><para>This one is basic and simple. It can serve as a sanity check to see
    if CouchDB is running at all. It can also act as a safety guard for
    libraries that require a certain version of CouchDB. We’re using the
    <literal moreinfo="none">curl</literal> utility again:<indexterm id="I_indexterm4_d1e1852" significance="normal"><primary>HTTP requests</primary></indexterm><indexterm id="I_indexterm4_d1e1855" significance="normal"><primary>servers</primary><secondary>CouchDB, checking if running</secondary></indexterm><indexterm id="I_indexterm4_d1e1860" significance="normal"><primary>core CouchDB API</primary><secondary>server</secondary></indexterm></para><screen format="linespecific">curl http://127.0.0.1:5984/</screen><para>CouchDB replies, all excited to get going:</para><programlisting id="I_programlisting4_d1e1869" language="javascript" linenumbering="unnumbered" format="linespecific">{"couchdb":"Welcome","version":"0.10.1"}</programlisting><para>You get back a JSON string, that, if parsed into a native object or
    data structure of your programming language, gives you access to the
    welcome string and version <phrase role="keep-together">information</phrase>.</para><para>This is not terribly useful, but it illustrates nicely the way
    CouchDB behaves. You send an HTTP request and you receive a JSON string in
    the HTTP response as a result.</para></sect1><sect1 id="I_sect14_d1e1878"><title>Databases</title><para>Now let’s do something a little more useful: create databases. For
    the strict, CouchDB is a <emphasis>database management system</emphasis>
    (DMS). That means it can hold multiple <emphasis>databases</emphasis>. A
    database is a bucket that holds “related data.” We’ll explore later what
    that means exactly. In practice, the terminology is overlapping—often
    people refer to a DMS as “a database” and also a database within the DMS
    as “a database.” We might follow that slight oddity, so don’t get confused
    by it. In general, it should be clear from the context if we are talking
    about the whole of CouchDB or a single database within CouchDB.<indexterm class="startofrange" id="ch04_dbcoreAPI" significance="normal"><primary>databases</primary></indexterm><indexterm class="startofrange" id="ch04_coreAPIdb" significance="normal"><primary>core CouchDB API</primary><secondary>databases</secondary></indexterm><indexterm id="I_indexterm4_d1e1897" significance="normal"><primary>DMS (database management system)</primary></indexterm><indexterm id="I_indexterm4_d1e1900" significance="normal"><primary>database management system (DMS)</primary></indexterm></para><para>Now let’s make one! We want to store our favorite music albums, and
    we creatively give our database the name <literal moreinfo="none">albums</literal>. Note
    that we’re now using the <literal moreinfo="none">-X</literal> option again to tell
    <literal moreinfo="none">curl</literal> to send a <literal moreinfo="none">PUT</literal> request instead
    of the default <literal moreinfo="none">GET</literal> request:<indexterm id="I_indexterm4_d1e1921" significance="normal"><primary>PUT requests</primary><secondary>sending using curl</secondary></indexterm><indexterm id="I_indexterm4_d1e1926" significance="normal"><primary>HTTP requests</primary><secondary>PUT request</secondary></indexterm><indexterm id="I_indexterm4_d1e1931" significance="normal"><primary>curl command</primary><secondary>-X PUT option</secondary></indexterm></para><screen format="linespecific">curl -X PUT http://127.0.0.1:5984/albums</screen><para>CouchDB replies:</para><programlisting id="I_programlisting4_d1e1940" language="javascript" linenumbering="unnumbered" format="linespecific">{"ok":true}</programlisting><para>That’s it. You created a database and CouchDB told you that all went
    well. What happens if you try to create a database that already exists?
    Let’s try to create that database again:</para><screen format="linespecific">curl -X PUT http://127.0.0.1:5984/albums</screen><para>CouchDB replies:</para><programlisting id="I_programlisting4_d1e1948" language="javascript" linenumbering="unnumbered" format="linespecific">{"error":"file_exists","reason":"The database could not be created, the file 
already exists."}</programlisting><para>We get back an error. This is pretty convenient. We also learn a
    little bit about how CouchDB works. CouchDB stores each database in a
    single file. Very simple. This has some consequences down the road, but
    we’ll skip the details for now and explore the underlying storage system
    in <xref linkend="thepowerofbtrees"/>.</para><para>Let’s create another database, this time with
    <literal moreinfo="none">curl</literal>’s <literal moreinfo="none">-v</literal> (for “verbose”) option.
    The verbose option tells <literal moreinfo="none">curl</literal> to show us not only the
    essentials—the HTTP response body—but all the underlying request and
    response details:<indexterm id="I_indexterm4_d1e1966" significance="normal"><primary>curl command</primary><secondary>-v option</secondary></indexterm></para><screen format="linespecific">curl -vX PUT http://127.0.0.1:5984/albums-backup</screen><para><literal moreinfo="none">curl</literal> elaborates:</para><screen format="linespecific">* About to connect() to 127.0.0.1 port 5984 (#0)
*   Trying 127.0.0.1... connected
* Connected to 127.0.0.1 (127.0.0.1) port 5984 (#0)
&gt; PUT /albums-backup HTTP/1.1
&gt; User-Agent: curl/7.16.3 (powerpc-apple-darwin9.0) libcurl/7.16.3 OpenSSL/0.9.7l 
zlib/1.2.3
&gt; Host: 127.0.0.1:5984
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 201 Created
&lt; Server: CouchDB/0.9.0 (Erlang OTP/R12B)
&lt; Date: Sun, 05 Jul 2009 22:48:28 GMT
&lt; Content-Type: text/plain;charset=utf-8
&lt; Content-Length: 12
&lt; Cache-Control: must-revalidate
&lt;
{"ok":true}
* Connection #0 to host 127.0.0.1 left intact
* Closing connection #0</screen><para>What a mouthful. Let’s step through this line by line to understand
    what’s going on and find out what’s important. Once you’ve seen this
    output a few times, you’ll be able to spot the important bits more
    easily.</para><screen format="linespecific">* About to connect() to 127.0.0.1 port 5984 (#0)</screen><para>This is <literal moreinfo="none">curl</literal> telling us that it is going to
    establish a <emphasis>TCP</emphasis> connection to the CouchDB server we
    specified in our request URI. Not at all important, except when debugging
    networking issues.<indexterm id="I_indexterm4_d1e1991" significance="normal"><primary>TCP connections</primary></indexterm></para><screen format="linespecific">*   Trying 127.0.0.1... connected
* Connected to 127.0.0.1 (127.0.0.1) port 5984 (#0)</screen><para><literal moreinfo="none">curl</literal> tells us it successfully connected to
    CouchDB. Again, not important if you aren’t trying to find problems with
    your network.</para><para>The following lines are prefixed with <literal moreinfo="none">&gt;</literal> and
    <literal moreinfo="none">&lt;</literal> characters. <literal moreinfo="none">&gt;</literal> means the line
    was sent to CouchDB verbatim (without the actual <literal moreinfo="none">&gt;</literal>).
    <literal moreinfo="none">&lt;</literal> means the line was sent back to
    <literal moreinfo="none">curl</literal> by CouchDB.</para><screen format="linespecific">&gt; PUT /albums-backup HTTP/1.1</screen><para>This initiates an HTTP request. Its <emphasis>method</emphasis> is
    <literal moreinfo="none">PUT</literal>, the <emphasis>URI</emphasis> is
    <literal moreinfo="none">/albums-backup</literal>, and the HTTP version is
    <literal moreinfo="none">HTTP/1.1</literal>. There is also <literal moreinfo="none">HTTP/1.0</literal>,
    which is simpler in some cases, but for all practical reasons you should
    be using <literal moreinfo="none">HTTP/1.1</literal>.<indexterm id="I_indexterm4_d1e2048" significance="normal"><primary>HTTP requests</primary></indexterm></para><para>Next, we see a number of <emphasis>request headers</emphasis>. These
    are used to provide additional details about the request to
    CouchDB.<indexterm id="I_indexterm4_d1e2056" significance="normal"><primary>request headers</primary></indexterm></para><screen format="linespecific">&gt; User-Agent: curl/7.16.3 (powerpc-apple-darwin9.0) libcurl/7.16.3 OpenSSL/0.9.7l 
zlib/1.2.3</screen><para>The <literal moreinfo="none">User-Agent</literal> header tell CouchDB which piece of
    client software is doing the HTTP request. We don’t learn anything new:
    it’s <literal moreinfo="none">curl</literal>. This header is often useful in web
    development when there are known errors in client implementations that a
    server might want to prepare the response for. It also helps to determine
    which platform a user is on. This information can be used for technical
    and statistical reasons. For CouchDB, the <literal moreinfo="none">User-Agent</literal>
    header is irrelevant.<indexterm id="I_indexterm4_d1e2072" significance="normal"><primary>headers</primary><secondary>User-Agent header</secondary></indexterm><indexterm id="I_indexterm4_d1e2077" significance="normal"><primary>User-Agent header</primary></indexterm></para><screen format="linespecific">&gt; Host: 127.0.0.1:5984</screen><para>The <literal moreinfo="none">Host</literal> header is required by HTTP 1.1. It tells
    the server the hostname that came with the request.</para><screen format="linespecific">&gt; Accept: */*</screen><para>The <literal moreinfo="none">Accept</literal> header tells CouchDB that
    <literal moreinfo="none">curl</literal> accepts any media type. We’ll look into why this
    is useful a little later.</para><screen format="linespecific">&gt;</screen><para>An empty line denotes that the request headers are now finished and
    the rest of the request contains data we’re sending to the server. In this
    case, we’re not sending any data, so the rest of the curl output is
    dedicated to the HTTP response.<indexterm id="I_indexterm4_d1e2101" significance="normal"><primary>headers</primary><secondary>response</secondary></indexterm><indexterm id="I_indexterm4_d1e2106" significance="normal"><primary>responses</primary><secondary>HTTP</secondary></indexterm><indexterm id="I_indexterm4_d1e2111" significance="normal"><primary>HTTP responses</primary></indexterm></para><screen format="linespecific">&lt; HTTP/1.1 201 Created</screen><para>The first line of CouchDB’s HTTP response includes the HTTP version
    information (again, to acknowledge that the requested version could be
    processed), an HTTP <emphasis>status code</emphasis>, and a
    <emphasis>status code message</emphasis>. Different requests trigger
    different response codes. There’s a whole range of them telling the client
    (<literal moreinfo="none">curl</literal> in our case) what effect the request had on the
    server. Or, if an error occurred, what kind of error. RFC 2616 (the
    <phrase role="keep-together">HTTP</phrase> 1.1 specification) defines
    clear behavior for response codes. CouchDB fully follows the
    RFC.<indexterm id="I_indexterm4_d1e2131" significance="normal"><primary>status code messages</primary></indexterm><indexterm id="I_indexterm4_d1e2134" significance="normal"><primary>HTTP status codes</primary></indexterm></para><para>The <emphasis>201 Created</emphasis> status code tells the client
    that the resource the request was made against was successfully created.
    No surprise here, but if you remember that we got an error message when we
    tried to create this database twice, you now know that this response could
    include a different response code. Acting upon responses based on response
    codes is a common practice. For example, all response codes of 400 or
    larger tell you that some error occurred. If you want to shortcut your
    logic and immediately deal with the error, you could just check a
    <literal moreinfo="none">&gt;= 400</literal> response code.</para><screen format="linespecific">&lt; Server: CouchDB/0.10.1 (Erlang OTP/R13B)</screen><para>The <literal moreinfo="none">Server</literal> header is good for diagnostics. It
    tells us which CouchDB version and which underlying Erlang version we are
    talking to. In general, you can ignore this header, but it is good to know
    it’s there if you need it.<indexterm id="I_indexterm4_d1e2152" significance="normal"><primary>servers</primary><secondary>Server header</secondary></indexterm><indexterm id="I_indexterm4_d1e2157" significance="normal"><primary>Erlang</primary><secondary>versions, in Server header</secondary></indexterm></para><screen format="linespecific">&lt; Date: Sun, 05 Jul 2009 22:48:28 GMT</screen><para>The <literal moreinfo="none">Date</literal> header tells you the time of the server.
    Since client and server time are not necessary synchronized, this header
    is purely informational. You shouldn’t build any critical application
    logic on top of this!<indexterm id="I_indexterm4_d1e2169" significance="normal"><primary>time</primary><secondary>server</secondary></indexterm><indexterm id="I_indexterm4_d1e2174" significance="normal"><primary>dates</primary><secondary>Date header</secondary></indexterm></para><screen format="linespecific">&lt; Content-Type: text/plain;charset=utf-8</screen><para>The <literal moreinfo="none">Content-Type</literal> header tells you which MIME type
    the HTTP response body is and its encoding. We already know CouchDB
    returns JSON strings. The appropriate <literal role="keep-together" moreinfo="none">Content-Type</literal> header is
    <literal moreinfo="none">application/json</literal>. Why do we see
    <literal moreinfo="none">text/plain</literal>? This is where pragmatism wins over purity.
    Sending an <literal moreinfo="none">application/json</literal>
    <literal moreinfo="none">Content-Type</literal> header will make a browser offer you the
    returned JSON for download instead of just displaying it. Since it is
    <phrase role="keep-together">extremely</phrase> useful to be able to test
    CouchDB from a browser, CouchDB sends a <literal moreinfo="none">text/plain</literal>
    content type, so all browsers will display the JSON as text.<indexterm id="I_indexterm4_d1e2208" significance="normal"><primary>JSON (JavaScript Object Notation)</primary><secondary>Content-Type header, application/json</secondary></indexterm><indexterm id="I_indexterm4_d1e2213" significance="normal"><primary>content types</primary><secondary>Content-Type headers</secondary></indexterm></para><para>There are some browser extensions that make your browser JSON-aware,
    but they are not installed by default.</para><para>Do you remember the <literal moreinfo="none">Accept</literal> request header and how
    it is set to <literal moreinfo="none">\*/\* -&gt; */*</literal> to express interest in any
    MIME type? If you send <literal moreinfo="none">Accept: application/json</literal> in your
    request, CouchDB knows that you can deal with a pure JSON response with
    the proper <literal moreinfo="none">Content-Type</literal> header and will use it instead
    of <literal moreinfo="none">text/plain</literal>.</para><screen format="linespecific">&lt; Content-Length: 12</screen><para>The <literal moreinfo="none">Content-Length</literal> header simply tells us how
    many bytes the response body has.</para><screen format="linespecific">&lt; Cache-Control: must-revalidate</screen><para>This <literal moreinfo="none">Cache-Control</literal> header tells you, or any proxy
    server between CouchDB and you, not to cache this <phrase role="keep-together">response</phrase>.</para><screen format="linespecific">&lt;</screen><para>This empty line tells us we’re done with the response headers and
    what follows now is the response body.</para><screen format="linespecific">{"ok":true}</screen><para>We’ve seen this before.</para><screen format="linespecific">* Connection #0 to host 127.0.0.1 left intact
* Closing connection #0</screen><para>The last two lines are <literal moreinfo="none">curl</literal> telling us that it
    kept the TCP connection it opened in the beginning open for a moment, but
    then closed it after it received the entire response.</para><para>Throughout the book, we’ll show more requests with the
    <literal moreinfo="none">-v</literal> option, but we’ll omit some of the headers we’ve
    seen here and include only those that are important for the particular
    request.</para><para>Creating databases is all fine, but how do we get rid of one?
    Easy—just change the HTTP method:</para><screen format="linespecific">&gt; curl -vX DELETE http://127.0.0.1:5984/albums-backup</screen><para>This deletes a CouchDB database. The request will remove the file
    that the database contents are stored in. There is no “Are you sure?”
    safety net or any “Empty the trash” magic you’ve got to do to delete a
    database. Use this command with care. Your data will be deleted without a
    chance to bring it back easily if you don’t have a backup copy.</para><para>This section went knee-deep into HTTP and set the stage for
    discussing the rest of the core CouchDB API. Next stop:
    documents.<indexterm id="I_indexterm4_d1e2284" class="endofrange" startref="ch04_dbcoreAPI" significance="normal"/><indexterm id="I_indexterm4_d1e2285" class="endofrange" userlevel="ch04_coreAPIdb" significance="normal"/></para></sect1><sect1 id="I_sect14_d1e2286"><title>Documents</title><para>Documents are CouchDB’s central data structure. The idea behind a
    document is, unsurprisingly, that of a real-world document—a sheet of
    paper such as an invoice, a <phrase role="keep-together">recipe</phrase>,
    or a business card. We already learned that CouchDB uses the JSON format
    to store documents. Let’s see how this storing works at the lowest
    level.<indexterm class="startofrange" id="ch04_documents" significance="normal"><primary>documents</primary></indexterm><indexterm class="startofrange" id="ch04_coreAPIdocs" significance="normal"><primary>core CouchDB API</primary><secondary>documents</secondary></indexterm></para><para>Each document in CouchDB has an <emphasis>ID</emphasis>. This ID is
    unique per database. You are free to choose any string to be the ID, but
    for best results we recommend a UUID (or GUID), i.e., a Universally (or
    Globally) Unique IDentifier. UUIDs are random numbers that have such a low
    collision probability that everybody can make thousands of UUIDs a minute
    for millions of years without ever creating a duplicate. This is a great
    way to ensure two independent people cannot create two different documents
    with the same ID. Why should you care what somebody else is doing? For
    one, that somebody else could be you at a later time or on a different
    computer; secondly, CouchDB replication lets you share documents with
    others and using UUIDs ensures that it all works. But more on that later;
    let’s make some documents:<indexterm id="I_indexterm4_d1e2307" significance="normal"><primary>document IDs</primary></indexterm><indexterm id="I_indexterm4_d1e2310" significance="normal"><primary>IDs, document</primary><see>document IDs</see></indexterm><indexterm id="I_indexterm4_d1e2315" significance="normal"><primary>GUIDs (globally unique identifiers)</primary></indexterm><indexterm id="I_indexterm4_d1e2318" significance="normal"><primary>UUIDs (universally unique identifiers)</primary></indexterm></para><screen format="linespecific">curl -X PUT http://127.0.0.1:5984/albums/6e1295ed6c29495e54cc05947f18c8af \ 
-d '{"title":"There is Nothing Left to Lose","artist":"Foo Fighters"}'</screen><para>CouchDB replies:</para><screen format="linespecific">{"ok":true,"id":"6e1295ed6c29495e54cc05947f18c8af","rev":"1-2902191555"}</screen><para>The <literal moreinfo="none">curl</literal> command appears complex, but let’s break
    it down. First, <literal moreinfo="none">-X PUT</literal> tells <literal moreinfo="none">curl</literal> to
    make a PUT request. It is followed by the URL that specifies your <phrase role="keep-together">CouchDB IP address</phrase> and port. The resource
    part of the URL
    <literal moreinfo="none">/albums/6e1295ed6c29495e54cc05947f18c8af</literal> specifies the
    location of a document inside our <literal moreinfo="none">albums</literal> database. The
    wild collection of numbers and characters is a UUID. This UUID is your
    document’s ID. Finally, the <literal role="keep-together" moreinfo="none">-d</literal>
    flag tells <literal moreinfo="none">curl</literal> to use the following string as the body
    for the PUT request. The string is a simple JSON structure including
    <literal moreinfo="none">title</literal> and <literal moreinfo="none">artist</literal> attributes with
    their respective values.<indexterm id="I_indexterm4_d1e2360" significance="normal"><primary>curl command</primary><secondary>-d flag</secondary></indexterm><indexterm id="I_indexterm4_d1e2366" significance="normal"><primary>UUIDs (universally unique identifiers)</primary><secondary>furnished by CouchDB</secondary></indexterm></para><note><para>If you don’t have a UUID handy, you can ask CouchDB to give you
      one (in fact, that is what we did just now without showing you). Simply
      send a GET request to <literal moreinfo="none">/_uuids</literal>:</para><screen format="linespecific">curl -X GET http://127.0.0.1:5984/_uuids</screen><para>CouchDB replies:</para><programlisting id="I_programlisting4_d1e2381" language="javascript" linenumbering="unnumbered" format="linespecific">{"uuids":["6e1295ed6c29495e54cc05947f18c8af"]}</programlisting><para>Voilá, a UUID. If you need more than one, you can pass in the
      <literal role="keep-together" moreinfo="none">?count=10</literal> HTTP <phrase role="keep-together">parameter</phrase> to request 10 UUIDs, or really,
      any number you need.</para></note><para>To double-check that CouchDB isn’t lying about having saved your
    document (it usually doesn’t), try to retrieve it by sending a GET
    request:</para><screen format="linespecific">curl -X GET http://127.0.0.1:5984/albums/6e1295ed6c29495e54cc05947f18c8af</screen><para>We hope you see a pattern here. Everything in CouchDB has an
    address, a URI, and you use the different HTTP methods to operate on these
    URIs.</para><para>CouchDB replies:</para><programlisting id="I_programlisting4_d1e2400" language="javascript" linenumbering="unnumbered" format="linespecific">{"_id":"6e1295ed6c29495e54cc05947f18c8af",
	"_rev":"1-2902191555",
	"title":"There is Nothing Left to Lose",
	"artist":"Foo Fighters"}</programlisting><para>This looks a lot like the document you asked CouchDB to save, which
    is good. But you should notice that CouchDB added two fields to your JSON
    structure. The first is <literal moreinfo="none">_id</literal>, which holds the UUID we
    asked CouchDB to save our document under. We always know the ID of a
    document if it is included, which is very convenient.<indexterm id="I_indexterm4_d1e2407" significance="normal"><primary sortas="id field, documents">_id field, documents</primary></indexterm></para><para>The second field is <literal moreinfo="none">_rev</literal>. It stands for
    <emphasis>revision</emphasis>.<indexterm id="I_indexterm4_d1e2418" significance="normal"><primary sortas="rev field, documents">_rev field, documents</primary></indexterm></para><sect2><title>Revisions</title><para>If you want to change a document in CouchDB, you don’t tell it to
      go and find a field in a specific document and insert a new value.
      Instead, you load the full document out of CouchDB, make your changes in
      the JSON structure (or object, when you are doing actual programming),
      and save the entire new revision (or version) of that document back into
      CouchDB. Each revision is identified by a new <literal moreinfo="none">_rev</literal>
      value.<indexterm id="I_indexterm4_d1e2429" significance="normal"><primary>revisions</primary></indexterm><indexterm id="I_indexterm4_d1e2432" significance="normal"><primary>documents</primary><secondary>revisions</secondary></indexterm></para><para>If you want to update or delete a document, CouchDB expects you to
      include the <literal moreinfo="none">_rev</literal> field of the revision you wish to
      change. When CouchDB accepts the change, it will generate a new revision
      number. This mechanism ensures that, in case somebody else made a change
      unbeknownst to you before you got to request the document update,
      CouchDB will not accept your update because you are likely to overwrite
      data you didn’t know existed. Or simplified: whoever saves a change to a
      document first, wins. Let’s see what happens if we don’t provide a
      <literal moreinfo="none">_rev</literal> field (which is equivalent to providing a
      outdated value):</para><screen format="linespecific">curl -X PUT http://127.0.0.1:5984/albums/6e1295ed6c29495e54cc05947f18c8af \
-d '{"title":"There is Nothing Left to Lose","artist":"Foo Fighters","year":"1997"}'</screen><para>CouchDB replies:</para><programlisting id="I_programlisting4_d1e2449" language="javascript" linenumbering="unnumbered" format="linespecific">{"error":"conflict","reason":"Document update conflict."}</programlisting><para>If you see this, add the latest revision number of your document
      to the JSON structure:</para><screen format="linespecific">curl -X PUT http://127.0.0.1:5984/albums/6e1295ed6c29495e54cc05947f18c8af \
-d '{"_rev":"1-2902191555","title":"There is Nothing Left to Lose", 
"artist":"Foo Fighters","year":"1997"}'</screen><para>Now you see why it was handy that CouchDB returned that
      <literal moreinfo="none">_rev</literal> when we made the initial request. CouchDB
      replies:</para><programlisting id="I_programlisting4_d1e2460" language="javascript" linenumbering="unnumbered" format="linespecific">{"ok":true,"id":"6e1295ed6c29495e54cc05947f18c8af","rev":"2-2739352689"}</programlisting><para>CouchDB accepted your write and also generated a new revision
      number. The revision number is the md5 hash of the transport
      representation of a document with an <literal moreinfo="none">N-</literal> prefix
      denoting the number of times a document got updated. This is useful for
      replication. See <xref linkend="conflictmanagement"/> for more
      information.</para><para>There are multiple reasons why CouchDB uses this revision system,
      which is also called Multi-Version Concurrency Control (MVCC). They all
      work hand-in-hand, and this is a good opportunity to explain some of
      them.<indexterm id="I_indexterm4_d1e2472" significance="normal"><primary>MVCC (Multi-Version Concurrency Control)</primary></indexterm></para><para>One of the aspects of the HTTP protocol that CouchDB uses is that
      it is <emphasis>stateless</emphasis>. What does that mean? When talking
      to CouchDB you need to <emphasis>make requests</emphasis>. Making a
      <phrase role="keep-together">request</phrase> includes opening a network
      connection to CouchDB, exchanging bytes, and closing the connection.
      This is done every time you make a request. Other protocols allow you to
      open a connection, exchange bytes, keep the connection open, exchange
      more bytes later—maybe depending on the bytes you exchanged at the
      <phrase role="keep-together">beginning—</phrase>and eventually close the
      connection. Holding a connection open for later use requires the server
      to do extra work. One common pattern is that for the lifetime of a
      connection, the client has a consistent and static view of the data on
      the server. Managing huge amounts of parallel connections is a
      significant amount of work. HTTP connections are usually short-lived,
      and making the same guarantees is a lot easier. As a result, CouchDB can
      handle many more concurrent connections.</para><para>Another reason CouchDB uses MVCC is that this model is simpler
      conceptually and, as a consequence, easier to program. CouchDB uses less
      code to make this work, and less code is always good because the ratio
      of defects per lines of code is static.</para><para>The revision system also has positive effects on replication and
      storage mechanisms, but we’ll explore these later in the book.</para><warning><para>The terms <emphasis>version</emphasis> and
        <emphasis>revision</emphasis> might sound familiar (if you are
        programming without version control, drop this book right now and
        start learning one of the popular systems). Using new versions for
        document changes works a lot like version control, but there’s an
        important difference: CouchDB does <emphasis>not</emphasis> guarantee
        that older versions are kept around.</para></warning></sect2><sect2><title>Documents in Detail</title><para>Now let’s have a closer look at our document creation requests
      with the <literal moreinfo="none">curl</literal> <literal moreinfo="none">-v</literal> flag that was
      helpful when we explored the database API earlier. This is also a good
      <phrase role="keep-together">opportunity</phrase> to create more
      documents that we can use in later examples.<indexterm id="I_indexterm4_d1e2519" significance="normal"><primary>curl command</primary><secondary>-v option</secondary></indexterm></para><para>We’ll add some more of our favorite music albums. Get a fresh UUID
      from the <phrase role="keep-together"><literal moreinfo="none">/_uuids</literal> resource.</phrase> If you don’t
      remember how that works, you can look it up a few pages back.</para><screen format="linespecific">curl -vX PUT http://127.0.0.1:5984/albums/70b50bfa0a4b3aed1f8aff9e92dc16a0 \
-d '{"title":"Blackened Sky","artist":"Biffy Clyro","year":2002}'</screen><note><para>By the way, if you happen to know more information about your
        favorite albums, don’t hesitate to add more properties. And don’t
        worry about not knowing all the information for all the albums.
        CouchDB’s <phrase role="keep-together">schema-</phrase><phrase role="keep-together">less</phrase> documents can contain whatever you
        know. After all, you should relax and not worry about data.</para></note><para>Now with the <literal moreinfo="none">-v</literal> option, CouchDB’s reply (with
      only the important bits shown) looks like this:</para><screen format="linespecific">&gt; PUT /albums/70b50bfa0a4b3aed1f8aff9e92dc16a0 HTTP/1.1
&gt;
&lt; HTTP/1.1 201 Created
&lt; Location: http://127.0.0.1:5984/albums/70b50bfa0a4b3aed1f8aff9e92dc16a0
&lt; Etag: "1-2248288203"
&lt;
{"ok":true,"id":"70b50bfa0a4b3aed1f8aff9e92dc16a0","rev":"1-2248288203"}</screen><para>We’re getting back the <literal moreinfo="none">201 Created</literal> HTTP status
      code in the response headers, as we saw earlier when we created a
      database. The <literal moreinfo="none">Location</literal> header gives us a full URL to
      our newly created document. And there’s a new header. An Etag in
      HTTP-speak identifies a specific version of a resource. In this case, it
      identifies a specific version (the first one) of our new document. Sound
      familiar? Yes, conceptually, an Etag is the same as a CouchDB document
      revision number, and it shouldn’t come as a surprise that CouchDB uses
      revision numbers for Etags. Etags are useful for caching
      infrastructures. We’ll learn how to use them in <xref linkend="showfunctions"/>.</para><sect3><title>Attachments</title><para>CouchDB documents can have attachments just like an email
        message can have attachments. An attachment is identified by a name
        and includes its MIME type (or Content-Type) and the number of bytes
        the attachment contains. Attachments can be any data. It is easiest to
        think about attachments as files attached to a document. These files
        can be text, images, Word documents, music, or movie files. Let’s make
        one.<indexterm id="I_indexterm4_d1e2563" significance="normal"><primary>attachments to documents</primary></indexterm><indexterm id="I_indexterm4_d1e2566" significance="normal"><primary>documents</primary><secondary>attachments</secondary></indexterm></para><para>Attachments get their own URL where you can upload data. Say we
        want to add the album artwork to the
        <literal moreinfo="none">6e1295ed6c29495e54cc05947f18c8af</literal> document (“There
        is Nothing Left to Lose”), and let’s also say the artwork is in a file
        <filename moreinfo="none">artwork.jpg</filename> in the current <phrase role="keep-together">directory</phrase>:</para><screen format="linespecific">&gt; curl -vX PUT http://127.0.0.1:5984/albums/6e1295ed6c29495e54cc05947f18c8af/ \
artwork.jpg?rev=2-2739352689 --data-binary @artwork.jpg -H "Content-Type: image/jpg"</screen><?dbfo-need height=”1in”
?><para>The <literal moreinfo="none">-d@</literal> option tells <literal moreinfo="none">curl</literal>
        to read a file’s contents into the HTTP request body. We’re using the
        <literal moreinfo="none">-H</literal> option to tell CouchDB that we’re uploading a
        JPEG file. CouchDB will keep this information around and will send the
        appropriate header when requesting this attachment; in case of an
        image like this, a browser will render the image instead of offering
        you the data for download. This will come in handy later. Note that
        you need to provide the current revision number of the document you’re
        attaching the artwork to, just as if you would update the document.
        Because, after all, attaching some data is changing the
        document.<indexterm id="I_indexterm4_d1e2596" significance="normal"><primary>curl command</primary><secondary>-H option</secondary></indexterm><indexterm id="I_indexterm4_d1e2601" significance="normal"><primary>curl command</primary><secondary>-d@ option</secondary></indexterm></para><para>You should now see your artwork image if you point your browser
        to
        <filename moreinfo="none">http://127.0.0.1:5984/albums/6e1295ed6c29495e54cc05947f18c8af/artwork.jpg</filename>.</para><para>If you request the document again, you’ll see a new
        member:</para><screen format="linespecific">curl http://127.0.0.1:5984/albums/6e1295ed6c29495e54cc05947f18c8af</screen><para>CouchDB replies:</para><programlisting id="I_programlisting4_d1e2617" language="javascript" linenumbering="unnumbered" format="linespecific">{"_id":"6e1295ed6c29495e54cc05947f18c8af","_rev":"3-131533518","title":
"There is Nothing Left to Lose","artist":"Foo Fighters","year":"1997","_attachments":
{"artwork.jpg":{"stub":true,"content_type":"image/jpg","length":52450}}}</programlisting><para><literal moreinfo="none">_attachments</literal> is a list of keys and values
        where the values are JSON objects containing the attachment metadata.
        <literal moreinfo="none">stub=true</literal> tells us that this entry is just the
        metadata. If we use the <literal moreinfo="none">?attachments=true</literal> HTTP
        option when requesting this document, we’d get a Base64-encoded string
        containing the attachment data.</para><para>We’ll have a look at more document request options later as we
        explore more features of CouchDB, such as replication, which is the
        next topic.<indexterm id="I_indexterm4_d1e2632" class="endofrange" startref="ch04_coreAPIdocs" significance="normal"/><indexterm id="I_indexterm4_d1e2633" class="endofrange" startref="ch04_documents" significance="normal"/></para></sect3></sect2></sect1><sect1 id="I_sect14_d1e2634"><title>Replication</title><para>CouchDB replication is a mechanism to synchronize databases. Much
    like <literal moreinfo="none">rsync</literal> <phrase role="keep-together">synchronizes</phrase> two directories locally or over
    a network, replication synchronizes two <phrase role="keep-together">databases</phrase> locally or remotely.<indexterm class="startofrange" id="ch04_coreAPIrepl" significance="normal"><primary>core CouchDB API</primary><secondary>replication</secondary></indexterm><indexterm class="startofrange" id="ch04_replication" significance="normal"><primary>replication</primary></indexterm></para><para>In a simple POST request, you tell CouchDB the
    <emphasis>source</emphasis> and the <emphasis>target</emphasis> of a
    replication and CouchDB will figure out which documents and new document
    revisions are on <emphasis>source</emphasis> that are not yet on
    <emphasis>target</emphasis>, and will proceed to move the missing
    documents and revisions over.<indexterm id="I_indexterm4_d1e2670" significance="normal"><primary>target database (for replication)</primary></indexterm><indexterm id="I_indexterm4_d1e2673" significance="normal"><primary>source database (for replication)</primary></indexterm></para><para>We’ll take an in-depth look at replication later in the book; in
    this chapter, we’ll just show you how to use it.</para><para>First, we’ll create a target database. Note that CouchDB won’t
    automatically create a target database for you, and will return a
    replication failure if the target doesn’t exist (likewise for the source,
    but that mistake isn’t as easy to make):</para><screen format="linespecific">curl -X PUT http://127.0.0.1:5984/albums-replica</screen><para>Now we can use the database <literal moreinfo="none">albums-replica</literal> as a
    replication target:</para><screen format="linespecific">curl -vX POST http://127.0.0.1:5984/_replicate \
-d '{"source":"albums","target":"albums-replica"}'</screen><note><para>As of version 0.11, CouchDB supports the option
      <literal moreinfo="none">"create_target":true</literal> placed in the JSON POSTed to the
      <literal moreinfo="none">_replicate</literal> URL. It implicitly creates the target
      database if it doesn’t exist.</para></note><para>CouchDB replies (this time we formatted the output so you can read
    it more easily):</para><programlisting id="I_programlisting4_d1e2700" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "history": [
    {
      "start_last_seq": 0,
      "missing_found": 2,
      "docs_read": 2,
      "end_last_seq": 5,
      "missing_checked": 2,
      "docs_written": 2,
      "doc_write_failures": 0,
      "end_time": "Sat, 11 Jul 2009 17:36:21 GMT",
      "start_time": "Sat, 11 Jul 2009 17:36:20 GMT"
    }
  ],
  "source_last_seq": 5,
  "session_id": "924e75e914392343de89c99d29d06671",
  "ok": true
}</programlisting><para>CouchDB maintains a <emphasis>session history</emphasis> of
    replications. The response for a replication request contains the history
    entry for this <emphasis>replication session</emphasis>. It is also worth
    noting that the request for replication will stay
    <emphasis>open</emphasis> until replication closes. If you have a lot of
    documents, it’ll take a while until they are all replicated and you won’t
    get back the replication response until all documents are replicated. It
    is important to note that replication replicates the database only as it
    was at the point in time when replication was started. So, any additions,
    modifications, or deletions subsequent to the start of replication will
    not be replicated.<indexterm id="I_indexterm4_d1e2714" significance="normal"><primary>replication sessions</primary></indexterm><indexterm id="I_indexterm4_d1e2717" significance="normal"><primary>session history of replications</primary></indexterm></para><para>We’ll punt on the details again—the <literal moreinfo="none">"ok": true</literal> at
    the end tells us all went well. If you now have a look at the
    <literal moreinfo="none">albums-replica</literal> database, you should see all the
    documents that you created in the <literal moreinfo="none">albums</literal> database.
    Neat, eh?</para><para>What you just did is called <emphasis>local replication</emphasis>
    in CouchDB terms. You created a local copy of a database. This is useful
    for backups or to keep snapshots of a specific state of your data around
    for later. You might want to do this if you are developing your
    applications but want to be able to roll back to a stable version of your
    code and data.<indexterm id="I_indexterm4_d1e2736" significance="normal"><primary>local replication</primary></indexterm></para><para>There are more types of replication useful in other situations. The
    <literal moreinfo="none">source</literal> and <literal moreinfo="none">target</literal> members of our
    replication request are actually links (like in HTML) and so far we’ve
    seen links relative to the server we’re working on (hence
    <emphasis>local</emphasis>). You can also specify a remote database as the
    target:<indexterm id="I_indexterm4_d1e2750" significance="normal"><primary>remote target database (for replication)</primary></indexterm></para><screen format="linespecific">curl -vX POST http://127.0.0.1:5984/_replicate \
-d '{"source":"albums","target":"http://127.0.0.1:5984/albums-replica"}'</screen><para>Using a local <literal moreinfo="none">source</literal> and a remote
    <literal moreinfo="none">target</literal> database is called <emphasis>push
    replication</emphasis>. We’re pushing changes to a remote
    server.<indexterm id="I_indexterm4_d1e2766" significance="normal"><primary>push replication</primary></indexterm></para><note><para>Since we don’t have a second CouchDB server around just yet, we’ll
      just use the absolute address of our single server, but you should be
      able to infer from this that you can put any remote server in
      there.</para></note><para>This is great for sharing local changes with remote servers or
    buddies next door.</para><para>You can also use a remote <literal moreinfo="none">source</literal> and a local
    <literal moreinfo="none">target</literal> to do a <emphasis>pull replication</emphasis>.
    This is great for getting the latest changes from a server that is used by
    others:<indexterm id="I_indexterm4_d1e2785" significance="normal"><primary>pull replication</primary></indexterm></para><screen format="linespecific">curl -vX POST http://127.0.0.1:5984/_replicate \
-d '{"source":"http://127.0.0.1:5984/albums-replica","target":"albums"}'</screen><para>Finally, you can run <emphasis>remote replication</emphasis>, which
    is mostly useful for management <phrase role="keep-together">operations:<indexterm id="I_indexterm4_d1e2797" significance="normal"><primary>remote replication</primary></indexterm></phrase></para><screen format="linespecific">curl -vX POST http://127.0.0.1:5984/_replicate \
-d '{"source":"http://127.0.0.1:5984/albums",
"target":"http://127.0.0.1:5984/albums-replica"}'</screen><?dbfo-need height=”3in”
?><sidebar id="I_sidebar4_d1e2804"><title>CouchDB and REST</title><para>CouchDB prides itself on having a <emphasis>RESTful
      API</emphasis>, but these replication requests don’t look very RESTy to
      the trained eye. What’s up with that? While CouchDB’s core database,
      document, and attachment API are RESTful, not all of CouchDB’s API is.
      The replication API is one example. There are more, as we’ll see later
      in the book.<indexterm id="I_indexterm4_d1e2812" significance="normal"><primary>RESTful API</primary></indexterm></para><para>Why are there RESTful and non-RESTful APIs mixed up here? Have the
      developers been too lazy to go REST all the way? Remember, REST is an
      architectural style that lends itself to certain architectures (such as
      the CouchDB document API). But it is not a one-size-fits-all. Triggering
      an event like replication does not make a whole lot of sense in the REST
      world. It is more like a traditional remote procedure call. And there is
      nothing wrong with this.</para><para>We very much believe in the “use the right tool for the job”
      philosophy, and REST does not fit every job. For support, we refer to
      Leonard Richardson and Sam Ruby who wrote <citetitle><ulink role="orm:hideurl:ital" url="http://oreilly.com/catalog/9780596529260">RESTful Web
      Services</ulink></citetitle> (O’Reilly), as they share our
      view.<indexterm id="I_indexterm4_d1e2823" class="endofrange" startref="ch04_replication" significance="normal"/><indexterm id="I_indexterm4_d1e2824" class="endofrange" startref="ch04_coreAPIrepl" significance="normal"/></para></sidebar></sect1><sect1 id="I_sect14_d1e2826"><title>Wrapping Up</title><para>This is still not the full CouchDB API, but we discussed the
    essentials in great detail. We’re going to fill in the blanks as we go.
    For now, we believe you’re ready to start building CouchDB
    applications.<indexterm id="I_indexterm4_d1e2831" class="endofrange" startref="ch04_coreAPI" significance="normal"/></para></sect1></chapter></part><part id="part2"><title>Developing with CouchDB</title><chapter id="designdocuments"><title>Design Documents</title><para><emphasis>Design documents</emphasis> are a special type of CouchDB
  document that contains application code. Because it runs inside a database,
  the application API is highly structured. We’ve seen JavaScript views and
  other functions in the previous chapters. In this section, we’ll take a look
  at the function APIs, and talk about how functions in a design document are
  related within applications.<indexterm class="startofrange" id="ch05_designdocs" significance="normal"><primary>design documents</primary></indexterm></para><para>This part (<xref linkend="part2"/>, Chapters <xref linkend="designdocuments"/> through <xref linkend="listfunctions"/>) lays
  the foundation for <xref linkend="part3"/>, where we take what we’ve
  learned and build a small blog application to further develop an
  understanding of how CouchDB applications are built. The application is
  called Sofa, and on a few occasions we discuss it this part. If you are
  unclear on what we are referring to, do not worry, we’ll get to it in <xref linkend="part3"/>.</para><sect1 id="I_sect11_d1e2857"><title>Document Modeling</title><para>In our experience, there are two main kinds of documents. The first
    kind is like something a word processor would save, or a user profile.
    With that sort of data, you want to denormalize as much as you possibly
    can. Basically, you want to be able to load the document in one request
    and get something that makes sense enough to display.<indexterm id="I_indexterm1_d1e2862" significance="normal"><primary>document modeling</primary></indexterm></para><para>A technique exists for creating “virtual” documents by using views
    to collate data together. You could use this to store each attribute of
    your user profiles in a different document, but I wouldn’t recommend it.
    Virtual documents are useful in cases where the presented view will be
    created by merging the work of different authors; for instance, the
    reference example, a blog post, and its comments in one query. A blog post
    titled “CouchDB Joins,” by Christopher Lenz, covers this in more
    detail.<footnote><para><ulink url="http://www.cmlenz.net/archives/2007/10/couchdb-joins">http://www.cmlenz.net/archives/2007/10/couchdb-joins</ulink></para></footnote></para><para>This virtual document idea takes us to the other kind of
    document—the event log. Use this in cases where you don’t trust user input
    or where you need to trigger an asynchronous job. This records the user
    action as an event, so only minimal validation needs to occur at save
    time. It’s when you load the document for further work that you’d check
    for complex relational-style constraints.</para><para>You can treat documents as state machines, with a combination of
    user input and background processing managing document state. You’d use a
    view by state to pull out the relevant document—changing its state would
    move it in the view.</para><para>This approach is also useful for logging—combined with the <literal moreinfo="none">batch=ok</literal> performance hint, CouchDB should make a
    fine log store, and reduce views are ideal for finding things like average
    response time or highly active users.</para></sect1><sect1 id="I_sect11_d1e2880"><title>The Query Server</title><para>CouchDB’s default query server (the software package that executes
    design document functions) is written in JavaScript, but there are views
    servers available for nearly any language you can imagine. Implementing a
    new language is a matter of handling a few JSON commands from a simple
    line-based program.<indexterm id="I_indexterm1_d1e2885" significance="normal"><primary>views servers</primary></indexterm><indexterm id="I_indexterm1_d1e2888" significance="normal"><primary>design documents</primary><secondary>query server</secondary></indexterm><indexterm id="I_indexterm1_d1e2893" significance="normal"><primary>query server</primary></indexterm></para><para>In this section, we’ll review existing functionality like MapReduce
    views, update validation functions, and show and list transforms. We’ll
    also briefly describe capabilities available on CouchDB’s roadmap, like
    replication filters, update handlers for parsing non-JSON input, and a
    rewrite handler for making application URLs more palatable. Since CouchDB
    is an open source project, we can’t really say when each planned feature
    will become available, but it’s our hope that everything described here is
    available by the time you read this. We’ll make it clear in the text when
    we’re talking about things that aren’t yet in the CouchDB trunk.</para></sect1><sect1 id="I_sect11_d1e2898"><title>Applications Are Documents</title><para>CouchDB is designed to work best when there is a one-to-one
    correspondence between applications and design documents.<indexterm id="I_indexterm1_d1e2903" significance="normal"><primary>design documents</primary><secondary>applications as documents</secondary></indexterm></para><para>A <emphasis>design document</emphasis> is a CouchDB document with an
    <literal moreinfo="none">id</literal> that begins with <literal moreinfo="none">_design/</literal>. For
    instance, the example blog application, Sofa, is stored in a design
    document with the ID <literal moreinfo="none">_design/sofa</literal> (see <xref linkend="figure_5-1"/>). Design documents are just like any other CouchDB
    document—they replicate along with the other documents in their database
    and track edit conflicts with the <literal moreinfo="none">rev</literal>
    parameter.<indexterm id="I_indexterm1_d1e2928" significance="normal"><primary>document IDs</primary><secondary>design documents</secondary></indexterm></para><para>As we’ve seen, design documents are normal JSON documents, denoted
    by the fact that their DocID is prefixed with
    <literal moreinfo="none">_design/</literal>.</para><para>CouchDB looks for views and other application functions here. The
    static HTML pages of our application are served as attachments to the
    design document. Views and validations, however, aren’t stored as
    attachments; rather, they are directly included in the design document’s
    JSON body.</para><figure float="none" id="figure_5-1"><title>Anatomy of our design document</title><mediaobject id="I_mediaobject1_d1e2943"><imageobject role="print"><imagedata fileref="figs/print/codb_0501.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0501.png" format="PNG"/></imageobject></mediaobject></figure><para>CouchDB’s MapReduce queries are stored in the
    <literal moreinfo="none">views</literal> field. This is how Futon displays and allows you
    to edit MapReduce queries. View indexes are stored on a per–design
    document basis, according to a fingerprint of the function’s text
    contents. This means that if you edit attachments, validations, or any
    other non-view (or language) fields on the design document, the views will
    not be regenerated. However, if you change a map or a reduce function, the
    view index will be deleted and a new index built for the new view <phrase role="keep-together">functions.</phrase></para><para>CouchDB has the capability to render responses in formats other than
    raw JSON. The design doc fields <literal moreinfo="none">show</literal> and
    <literal moreinfo="none">list</literal> contain functions used to transform raw JSON into
    HTML, XML, or other Content-Types. This allows CouchDB to serve Atom feeds
    without any additional middleware. The <literal moreinfo="none">show</literal> and
    <literal moreinfo="none">list</literal> functions are a little like “<phrase role="keep-together">actions</phrase>” in traditional web frameworks—they
    run some code based on a request and render a response. However, they
    differ from actions in that they may not have side <phrase role="keep-together">effects</phrase>. This means that they are largely
    restricted to handling <literal moreinfo="none">GET</literal> requests, but it also means
    they can be cached by HTTP proxies like Varnish.<indexterm id="I_indexterm1_d1e2979" significance="normal"><primary>Atom feeds</primary><secondary>served by CouchDB</secondary></indexterm><indexterm id="I_indexterm1_d1e2984" significance="normal"><primary>list functions</primary></indexterm><indexterm id="I_indexterm1_d1e2987" significance="normal"><primary>show functions</primary></indexterm></para><para>Because application logic is contained in a single document, code
    upgrades can be accomplished with CouchDB replication. This also opens the
    possibility for a single database to host multiple applications. The
    interface a newspaper editor needs is vastly different from what a reader
    desires, although the data is largely the same. They can both be hosted by
    the same database, in different design documents.</para><para>A CouchDB database can contain many design documents. Example design
    DocIDs are:<indexterm id="I_indexterm1_d1e2994" significance="normal"><primary>databases</primary><secondary>design documents in</secondary></indexterm></para><screen format="linespecific">_design/calendar
_design/contacts
_design/blog
_design/admin</screen><para>In the full CouchDB URL structure, you’d be able to
    <literal moreinfo="none">GET</literal> the design document JSON at URLs like:<indexterm id="I_indexterm1_d1e3007" significance="normal"><primary>URLs</primary><secondary sortas="design">for design documents</secondary></indexterm></para><screen format="linespecific">http://localhost:5984/mydb/_design/calendar
http://127.0.0.1:5984/mydb/_design/contacts
http://127.0.0.1:5984/mydb/_design/blog
http://127.0.0.1:5984/mydb/_design/admin</screen><para>We show this to note that design documents have a special case, as
    they are the only documents whose URLs can be used with a literal slash.
    We’ve done this because nobody likes to see <literal moreinfo="none">%2F</literal> in
    their browser’s location bar. In all other cases, a slash in a DocID must
    be escaped when used in a URL. For instance, the DocID
    <literal moreinfo="none">movies/jaws</literal> would appear in the URL like this:
    <literal moreinfo="none">http://127.0.0.1:5984/mydb/movies%2Fjaws</literal>.<indexterm id="I_indexterm1_d1e3025" significance="normal"><primary>/ (slashes), in design document URLs</primary></indexterm></para><para>We’ll build the first iteration of the example application without
    using <literal moreinfo="none">show</literal> or <literal moreinfo="none">list</literal>, because writing
    Ajax queries against the JSON API is a better way to teach CouchDB as a
    database. The APIs we explore in the first iteration are the same APIs
    you’d use to analyze log data, archive assets, or manage persistent
    queues.</para><para>In the second iteration, we’ll upgrade our example blog so that it
    can function with client-side JavaScript turned off. For now, sticking to
    Ajax queries gives more transparency into how CouchDB’s JSON/HTTP API
    works. JSON is a subset of JavaScript, so working with it in JavaScript
    keeps the impedance mismatch low, while the browser’s
    <emphasis>XMLHttpRequest (XHR)</emphasis> object handles the HTTP details
    for us.<indexterm id="I_indexterm1_d1e3041" significance="normal"><primary>XMLHttpRequest object</primary></indexterm><indexterm id="I_indexterm1_d1e3044" significance="normal"><primary>Ajax queries against JSON API</primary></indexterm><indexterm id="I_indexterm1_d1e3047" significance="normal"><primary>JSON (JavaScript Object Notation)</primary><secondary>Ajax queries against JSON API</secondary></indexterm></para><para>CouchDB uses the <literal moreinfo="none">validate_doc_update</literal> function to
    prevent invalid or unauthorized document updates from proceeding. We use
    it in the example application to ensure that blog posts can be authored
    only by logged-in users. CouchDB’s validation functions also can’t have
    any side effects, and they have the opportunity to block not only end user
    document saves, but also replicated documents from other nodes. We’ll talk
    about validation in depth in <xref linkend="part3"/>.<indexterm id="I_indexterm1_d1e3059" significance="normal"><primary>validate_doc_update function</primary></indexterm></para><para>The raw images, JavaScript, CSS, and HTML assets needed by Sofa are
    stored in the <literal moreinfo="none">_attachments</literal> field, which is interesting
    in that by default it shows only the stubs, rather than the full content
    of the files. Attachments are available on all CouchDB documents, not just
    design documents, so asset management applications have as much
    flexibility as they could need. If a set of resources is required for your
    application to run, they should be attached to the design document. This
    means that a new user can easily <phrase role="keep-together">bootstrap</phrase> your application on an empty
    database.</para><para>The other fields in the design document shown in <xref linkend="figure_5-1"/> (and in the design documents we’ll be using) are
    used by CouchApp’s upload process (see <xref linkend="standaloneapplications"/> for more information on CouchApp). The
    <literal moreinfo="none">signatures</literal> field allows us to avoid updating
    attachments that have not changed between the disk and the database. It
    does this by comparing file content hashes. The <literal moreinfo="none">lib</literal>
    field is used to hold additional JavaScript code and JSON data to be
    inserted at deploy time into view, show, and validation functions. We’ll
    explain CouchApp in the next chapter.</para></sect1><sect1 id="I_sect11_d1e3082"><title>A Basic Design Document</title><para>In the next section we’ll get into advanced techniques for working
    with design documents, but before we finish here, let’s look at a very
    basic design document. All we’ll do is define a single view, but it should
    be enough to show you how design documents fit into the larger
    system.<indexterm id="I_indexterm1_d1e3087" significance="normal"><primary>design documents</primary><secondary>basic</secondary></indexterm></para><para>First, add the following text (or something like it) to a text file
    called <filename moreinfo="none">mydesign.json</filename> using your editor:</para><programlisting id="I_programlisting1_d1e3097" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "_id" : "_design/example",
  "views" : {
    "foo" : {
      "map" : "function(doc){ emit(doc._id, doc._rev)}"
    }
  }
}</programlisting><para>Now use <literal moreinfo="none">curl</literal> to <literal moreinfo="none">PUT</literal> the file
    to CouchDB (we’ll create a database first for good measure):</para><screen format="linespecific">curl -X PUT http://127.0.0.1:5984/basic
curl -X PUT http://127.0.0.1:5984/basic/_design/example -d @mydesign.json</screen><para>From the second request, you should see a response like:</para><programlisting id="I_programlisting1_d1e3111" language="javascript" linenumbering="unnumbered" format="linespecific">{"ok":true,"id":"_design/example","rev":"1-230141dfa7e07c3dbfef0789bf11773a"}</programlisting><para>Now we can query the view we’ve defined, but before we do that, we
    should add a few documents to the database so we have something to view.
    Running the following command a few times will add empty documents:</para><screen format="linespecific">curl -X POST http://127.0.0.1:5984/basic -d '{}'</screen><para>Now to query the view:</para><screen format="linespecific">curl http://127.0.0.1:5984/basic/_design/example/_view/foo</screen><para>This should give you a list of all the documents in the database
    (except the design document). You’ve created and used your first design
    document!</para></sect1><sect1 id="I_sect11_d1e3124"><title>Looking to the Future</title><para>There are other design document functions that are being introduced
    at the time of this writing, including <literal moreinfo="none">_update</literal> and
    <literal moreinfo="none">_filter</literal> that we aren’t covering in depth here. Filter
    functions are covered in <xref linkend="changenotifications"/>. Imagine a
    web service that <literal moreinfo="none">POSTs</literal> an XML blob at a URL of your
    choosing when particular events occur. PayPal’s instant payment
    notification is one of these. With an <literal moreinfo="none">_update</literal> handler,
    you can <literal moreinfo="none">POST</literal> these directly in CouchDB and it can parse
    the XML into a JSON document and save it. The same goes for CSV,
    multi-part form, or any other format.</para><para>The bigger picture we’re working on is like an app server, but
    different in one crucial regard: rather than let the developer do whatever
    he wants (loop a list of DocIDs and make queries, make queries based on
    the results of other queries, etc.), we’re defining “safe”
    transformations, such as view, show, list, and update. By safe, we mean
    that they have well-known performance characteristics and otherwise fit
    into CouchDB’s <phrase role="keep-together">architecture</phrase> in a
    streamlined way.</para><para>The goal here is to provide a way to build standalone apps that can
    also be easily indexed by search engines and used via screen readers.
    Hence, the push for plain old HTML. You can pretty much rely on JavaScript
    getting executed (except when you can’t). Having HTML resources means
    CouchDB is suitable for public-facing web apps.</para><para>On the horizon are a rewrite handler and a database event handler,
    as they seem to flesh out the application capabilities nicely. A rewrite
    handler would allow your application to present its own URL space, which
    would make integration into existing systems a bit easier. An event
    handler would allow you to run asynchronous processes when the database
    changes, so that, for instance, a document update can trigger a workflow,
    multi-document validation, or message queue.<indexterm id="I_indexterm1_d1e3156" class="endofrange" startref="ch05_designdocs" significance="normal"/></para></sect1></chapter><chapter id="findingyourdatawithviews"><title>Finding Your Data with Views</title><para>Views are useful for many purposes:<indexterm id="I_indexterm2_d1e3162" significance="normal"><primary>views</primary><secondary>uses of</secondary></indexterm><indexterm class="startofrange" id="ch06_views" significance="normal"><primary>views</primary></indexterm></para><itemizedlist><listitem><para>Filtering the documents in your database to find those relevant to
      a particular process.</para></listitem><listitem><para>Extracting data from your documents and presenting it in a
      specific order.</para></listitem><listitem><para>Building efficient indexes to find documents by any value or
      structure that resides in them.</para></listitem><listitem><para>Use these indexes to represent relationships among
      documents.</para></listitem><listitem><para>Finally, with views you can make all sorts of calculations on the
      data in your documents. For example, a view can answer the question of
      what your company’s spending was in the last week, month, or
      year.</para></listitem></itemizedlist><sect1 id="I_sect12_d1e3186"><title>What Is a View?</title><para>Let’s go through the different use cases. First is extracting data
    that you might need for a special purpose in a specific order. For a front
    page, we want a list of blog post titles sorted by date. We’ll work with a
    set of example documents as we walk through how views work:<indexterm class="startofrange" id="ch06_viewsoverview" significance="normal"><primary>views</primary><secondary>overview of</secondary></indexterm></para><programlisting id="I_programlisting2_d1e3196" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "_id":"biking",
  "_rev":"AE19EBC7654",

  "title":"Biking",
  "body":"My biggest hobby is mountainbiking. The other day...",
  "date":"2009/01/30 18:04:11"
}

{
  "_id":"bought-a-cat",
  "_rev":"4A3BBEE711",
<?dbfo-need height="1in"
?>
  "title":"Bought a Cat",
  "body":"I went to the the pet store earlier and brought home a little kitty...",
  "date":"2009/02/17 21:13:39"
}

{
  "_id":"hello-world",
  "_rev":"43FBA4E7AB",

  "title":"Hello World",
  "body":"Well hello and welcome to my new blog...",
  "date":"2009/01/15 15:52:20"
}</programlisting><para>Three will do for the example. Note that the documents are sorted by
    <literal moreinfo="none">"_id"</literal>, which is how they are stored in the database.
    Now we define a view. <xref linkend="gettingstarted"/> showed you how to
    create a view in Futon, the CouchDB administration client. Bear with us
    without an explanation while we show you some code:</para><programlisting id="I_programlisting2_d1e3207" language="javascript" linenumbering="unnumbered" format="linespecific">function(doc) {
  if(doc.date &amp;&amp; doc.title) {
    emit(doc.date, doc.title);
  }
}</programlisting><para>This is a <emphasis>map function</emphasis>, and it is written in
    JavaScript. If you are not familiar with JavaScript but have used C or any
    other C-like language such as Java, PHP, or C#, this should look familiar.
    It is a simple function definition.<indexterm id="I_indexterm2_d1e3214" significance="normal"><primary>functions</primary><secondary>function definition in JavaScript</secondary></indexterm><indexterm id="I_indexterm2_d1e3219" significance="normal"><primary>JavaScript</primary><secondary>function definition in</secondary></indexterm><indexterm id="I_indexterm2_d1e3224" significance="normal"><primary>map functions</primary><secondary>defining in JavaScript</secondary></indexterm></para><para>You provide CouchDB with view functions as strings stored inside the
    <literal moreinfo="none">views</literal> field of a design document. You don’t run it
    yourself. Instead, when you <emphasis>query your view</emphasis>, CouchDB
    takes the source code and runs it for you on every document in the
    database your view was defined in. You <emphasis>query your
    view</emphasis> to retrieve the <emphasis>view
    result</emphasis>.<indexterm id="I_indexterm2_d1e3243" significance="normal"><primary>view result</primary></indexterm><indexterm id="I_indexterm2_d1e3246" significance="normal"><primary>querying views</primary></indexterm><indexterm id="I_indexterm2_d1e3250" significance="normal"><primary>design documents</primary><secondary>view functions in</secondary></indexterm></para><para>All map functions have a single parameter <literal moreinfo="none">doc</literal>.
    This is a single document in the database. Our map function checks whether
    our document has a <literal moreinfo="none">date</literal> and a <literal moreinfo="none">title</literal>
    <phrase role="keep-together">attribute—</phrase>luckily, all of our
    documents have them—and then calls the built-in <literal moreinfo="none">emit()</literal>
    function with these two attributes as arguments.<indexterm id="I_indexterm2_d1e3273" significance="normal"><primary>emit( ) function</primary></indexterm></para><para>The <literal moreinfo="none">emit()</literal> function always takes two arguments:
    the first is <literal moreinfo="none">key</literal>, and the second is
    <literal moreinfo="none">value</literal>. The <literal moreinfo="none">emit(key, value)</literal> function
    creates an entry in our <emphasis>view result</emphasis>. One more thing:
    the <literal moreinfo="none">emit()</literal> function can be called multiple times in the
    map function to create multiple entries in the view results from a single
    document, but we are not doing that yet.<indexterm id="I_indexterm2_d1e3297" significance="normal"><primary>key/value pairs</primary><secondary>emit( ) function arguments</secondary></indexterm></para><para>CouchDB takes whatever you pass into the <literal moreinfo="none">emit()</literal>
    function and puts it into a list (see <xref linkend="view_results_table"/>). Each row in that list includes the
    <literal moreinfo="none">key</literal> and <literal moreinfo="none">value</literal>. More importantly, the
    list is sorted by <literal moreinfo="none">key</literal> (by <literal moreinfo="none">doc.date</literal>
    in our case). The most important feature of a view result is that it is
    sorted by <literal moreinfo="none">key</literal>. We will come back to that over and over
    again to do neat things. Stay tuned.</para><table id="view_results_table"><title>View results</title><tgroup cols="2"><thead><row><entry>Key</entry><entry>Value</entry></row></thead><tbody><row><entry><literal moreinfo="none">"2009/01/15 15:52:20"</literal></entry><entry><literal moreinfo="none">"Hello World"</literal></entry></row><row><entry><literal moreinfo="none">"2009/01/30 18:04:11"</literal></entry><entry><literal moreinfo="none">"Biking"</literal></entry></row><row><entry><literal moreinfo="none">"2009/02/17 21:13:39"</literal></entry><entry><literal moreinfo="none">"Bought a Cat"</literal></entry></row></tbody></tgroup></table><para>If you read carefully over the last few paragraphs, one part stands
    out: “When you query your view, CouchDB takes the source code and runs it
    for you on every document in the database.” If you have a lot of
    documents, that takes quite a bit of time and you might wonder if it is
    not horribly inefficient to do this. Yes, it would be, but CouchDB is
    designed to avoid any extra costs: it only runs through all documents
    once, when you <emphasis>first</emphasis> query your view. If a document
    is changed, the map function is only run once, to recompute the keys and
    values for that single document.<indexterm id="I_indexterm2_d1e3363" significance="normal"><primary>functions</primary><seealso>entries for individual function names</seealso></indexterm></para><para>The view result is stored in a B-tree, just like the structure that
    is responsible for holding your documents. View B-trees are stored in
    their own file, so that for high-performance CouchDB usage, you can keep
    views on their own disk. The B-tree provides very fast lookups of rows by
    key, as well as efficient streaming of rows in a key range. In our
    example, a single view can answer all questions that involve time: “Give
    me all the blog posts from last week” or “last month” or “this year.”
    Pretty neat. Read more about how CouchDB’s B-trees work in <xref linkend="thepowerofbtrees"/>.<indexterm id="I_indexterm2_d1e3372" significance="normal"><primary>B-trees</primary><secondary>view results in</secondary></indexterm></para><para>When we query our view, we get back a list of all documents sorted
    by date. Each row also includes the post title so we can construct links
    to posts. Figure 6-1 is just a graphical representation of the view
    result. The actual result is JSON-encoded and contains a little more
    metadata:</para><programlisting id="I_programlisting2_d1e3379" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "total_rows": 3,
  "offset": 0,
  "rows": [
    {
      "key": "2009/01/15 15:52:20",
      "id": "hello-world",
      "value": "Hello World"
    },

    {
      "key": "2009/02/17 21:13:39",
      "id": "bought-a-cat",
      "value": "Bought a Cat"
    },

    {
      "key": "2009/01/30 18:04:11",
      "id": "biking",
      "value": "Biking"
    }
  ]
}</programlisting><para>Now, the actual result is not as nicely formatted and doesn’t
    include any superfluous whitespace or newlines, but this is better for you
    (and us!) to read and understand. Where does that <literal moreinfo="none">"id"</literal>
    member in the result rows come from? That wasn’t there before. That’s
    because we omitted it earlier to avoid confusion. CouchDB automatically
    includes the document ID of the document that created the entry in the
    view result. We’ll use this as well when constructing links to the blog
    post pages.<indexterm id="I_indexterm2_d1e3386" class="endofrange" startref="ch06_viewsoverview" significance="normal"/></para></sect1><sect1 id="I_sect12_d1e3387"><title>Efficient Lookups</title><para>Let’s move on to the second use case for views: “building efficient
    indexes to find documents by any value or structure that resides in them.”
    We already explained the efficient indexing, but we skipped a few details.
    This is a good time to finish this discussion as we are looking at map
    functions that are a little more complex.<indexterm class="startofrange" id="ch06_indexesefficient" significance="normal"><primary>indexes</primary><secondary>building efficient indexes for lookups</secondary></indexterm><indexterm class="startofrange" id="ch06_viewslookups" significance="normal"><primary>views</primary><secondary>efficient lookups with</secondary></indexterm></para><para>First, back to the B-trees! We explained that the B-tree that backs
    the <literal moreinfo="none">key</literal>-sorted view result is built only once, when you
    first query a view, and all subsequent queries will just read the B-tree
    instead of executing the map function for all documents again. What
    happens, though, when you change a document, add a new one, or delete one?
    Easy: CouchDB is smart enough to find the rows in the view result that
    were created by a specific document. It marks them
    <emphasis>invalid</emphasis> so that they no longer show up in view
    results. If the document was deleted, we’re good—the resulting B-tree
    reflects the state of the database. If a document got updated, the new
    document is run through the map function and the resulting new lines are
    inserted into the B-tree at the correct spots. New documents are handled
    in the same way. <xref linkend="thepowerofbtrees"/> demonstrates that a
    B-tree is a very efficient data structure for our needs, and the
    crash-only design of CouchDB databases is carried over to the view indexes
    as well.</para><para>To add one more point to the efficiency discussion: usually multiple
    documents are updated between view queries. The mechanism explained in the
    previous paragraph gets applied to all changes in the database since the
    last time the view was queried in a batch operation, which makes things
    even faster and is generally a better use of your resources.</para><sect2><title>Find One</title><para>On to more complex map functions. We said “find documents by any
      value or structure that resides in them.” We already explained how to
      extract a value by which to sort a list of views (our
      <literal moreinfo="none">date</literal> field). The same mechanism is used for fast
      lookups. The URI to query to get a view’s result is
      <literal moreinfo="none">/database/_design/designdocname/_view/viewname</literal>. This
      gives you a list of all rows in the view. We have only three documents,
      so things are small, but with thousands of documents, this can get long.
      You can add <emphasis>view parameters</emphasis> to the URI to constrain
      the result set. Say we know the date of a blog post. To find a single
      document, we would use
      <literal moreinfo="none">/blog/_design/docs/_view/by_date?key="2009/01/30
      18:04:11"</literal> to get the “Biking” blog post. Remember that you can
      place whatever you like in the <literal moreinfo="none">key</literal> parameter to the
      <literal moreinfo="none">emit()</literal> function. Whatever you put in there, we can
      now use to look up exactly—and fast.<indexterm id="I_indexterm2_d1e3438" significance="normal"><primary>views</primary><secondary>efficient lookups with</secondary><tertiary sortas="finding 1 document">finding one
          document</tertiary></indexterm></para><para>Note that in the case where multiple rows have the same key
      (perhaps we design a view where the key is the name of the post’s
      author), key queries can return more than one row.</para></sect2><sect2><title>Find Many</title><para>We talked about “getting all posts for last month.” If it’s
      February now, this is <phrase role="keep-together">as easy as</phrase>
      <literal moreinfo="none">/blog/_design/docs/_view/by_date?startkey="2010/01/01
      00:00:00"&amp;endkey="2010/02/00 00:00:00"</literal>. The
      <literal moreinfo="none">startkey</literal> and <literal moreinfo="none">endkey</literal> parameters
      specify an inclusive range on which we can search.<indexterm id="I_indexterm2_d1e3464" significance="normal"><primary>views</primary><secondary>efficient lookups with</secondary><tertiary>finding many documents</tertiary></indexterm></para><para>To make things a little nicer and to prepare for a future example,
      we are going to change the format of our date field. Instead of a
      string, we are going to use an array, where individual members are part
      of a timestamp in decreasing significance. This sounds fancy, but it is
      rather easy. Instead of:</para><programlisting id="I_programlisting2_d1e3473" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "date": "2009/01/31 00:00:00"
}</programlisting><para>we use:</para><programlisting id="I_programlisting2_d1e3477" language="javascript" linenumbering="unnumbered" format="linespecific">"date": [2009, 1, 31, 0, 0, 0]</programlisting><para>Our map function does not have to change for this, but our view
      result looks a little different. See <xref linkend="new_view_results_table"/>.</para><table id="new_view_results_table"><title>New view results</title><tgroup cols="2"><thead><row><entry>Key</entry><entry>Value</entry></row></thead><tbody><row><entry><literal moreinfo="none">[2009, 1, 15, 15, 52, 20]</literal></entry><entry><literal moreinfo="none">"Hello World"</literal></entry></row><row><entry><literal moreinfo="none">[2009, 2, 17, 21, 13, 39]</literal></entry><entry><literal moreinfo="none">"Biking"</literal></entry></row><row><entry><literal moreinfo="none">[2009, 1, 30, 18, 4, 11]</literal></entry><entry><literal moreinfo="none">"Bought a Cat"</literal></entry></row></tbody></tgroup></table><para>And our queries change to
      <literal moreinfo="none">/blog/_design/docs/_view/by_date?key=[2009, 1, 1, 0, 0,
      0]</literal> and <literal moreinfo="none">/blog/_design/docs/_view/by_date?key=[2009,
      01, 31, 0, 0, 0]</literal>. For all you care, this is just a change in
      syntax, not meaning. But it shows you the power of views. Not only can
      you construct an index with scalar values like strings and integers, you
      can also use JSON structures as keys for your views. Say we tag our
      documents with a list of tags and want to see all tags, but we don’t
      care for documents that have not been tagged.</para><?dbfo-need height=”1in”
?><programlisting id="I_programlisting2_d1e3524" language="javascript" linenumbering="unnumbered" format="linespecific">{
  ...
  tags: ["cool", "freak", "plankton"],
  ...
}</programlisting><programlisting id="I_programlisting2_d1e3527" language="javascript" linenumbering="unnumbered" format="linespecific">{
  ...
  tags: [],
  ...
}</programlisting><programlisting id="I_programlisting2_d1e3529" language="javascript" linenumbering="unnumbered" format="linespecific">function(doc) {
  if(doc.tags.length &gt; 0) {
    for(var idx in doc.tags) {
      emit(doc.tags[idx], null);
    }
  }
}</programlisting><para>This shows a few new things. You can have conditions on structure
      (<literal moreinfo="none">if(doc.tags.length &gt; 0)</literal>) instead of just values.
      This is also an example of how a map function calls
      <literal moreinfo="none">emit()</literal> multiple times per document. And finally, you
      can pass <literal moreinfo="none">null</literal> instead of a value to the
      <literal moreinfo="none">value</literal> parameter. The same is true for the
      <literal moreinfo="none">key</literal> parameter. We’ll see in a bit how that is
      useful.</para></sect2><sect2><title>Reversed Results</title><para>To retrieve view results in reverse order, use the
      <literal moreinfo="none">descending=true</literal> query parameter. If you are using a
      <literal moreinfo="none">startkey</literal> parameter, you will find that CouchDB
      returns different rows or no rows at all. What’s up with that?<indexterm id="I_indexterm2_d1e3559" significance="normal"><primary>reversed view results</primary></indexterm><indexterm id="I_indexterm2_d1e3562" significance="normal"><primary>views</primary><secondary>efficient lookups with</secondary><tertiary>reversed results</tertiary></indexterm></para><para>It’s pretty easy to understand when you see how view query options
      work under the hood. A view is stored in a tree structure for fast
      lookups. Whenever you query a view, this is how CouchDB operates:</para><orderedlist numeration="arabic" inheritnum="ignore" continuation="restarts"><listitem><para>Starts reading at the top, or at the position that
          <literal moreinfo="none">startkey</literal> specifies, if present.</para></listitem><listitem><para>Returns one row at a time until the end or until it hits
          <literal moreinfo="none">endkey</literal>, if present.</para></listitem></orderedlist><para>If you specify <literal moreinfo="none">descending=true</literal>, the reading
      direction is reversed, <emphasis>not</emphasis> the sort order of the
      rows in the view. In addition, the same two-step procedure is
      followed.</para><para>Say you have a view result that looks like this:</para><informaltable><tgroup cols="2"><thead><row><entry>Key</entry><entry>Value</entry></row></thead><tbody><row><entry><literal moreinfo="none">0</literal></entry><entry><literal moreinfo="none">"foo"</literal></entry></row><row><entry><literal moreinfo="none">1</literal></entry><entry><literal moreinfo="none">"bar"</literal></entry></row><row><entry><literal moreinfo="none">2</literal></entry><entry><literal moreinfo="none">"baz"</literal></entry></row></tbody></tgroup></informaltable><para>Here are potential query options:
      <literal moreinfo="none">?startkey=1&amp;descending=true</literal>. What will CouchDB
      do? See #1 above: it jumps to <literal moreinfo="none">startkey</literal>, which is the
      row with the key <literal moreinfo="none">1</literal>, and starts reading backward until
      it hits the end of the view. So the particular result would be:</para><informaltable><tgroup cols="2"><thead><row><entry>Key</entry><entry>Value</entry></row></thead><tbody><row><entry><literal moreinfo="none">1</literal></entry><entry><literal moreinfo="none">"bar"</literal></entry></row><row><entry><literal moreinfo="none">0</literal></entry><entry><literal moreinfo="none">"foo"</literal></entry></row></tbody></tgroup></informaltable><para>This is very likely not what you want. To get the rows with the
      indexes <literal moreinfo="none">1</literal> and <literal moreinfo="none">2</literal> in reverse order,
      you need to switch the <literal moreinfo="none">startkey</literal> to
      <literal moreinfo="none">endkey</literal>:
      <literal moreinfo="none">endkey=1&amp;descending=true</literal>:</para><informaltable><tgroup cols="2"><thead><row><entry>Key</entry><entry>Value</entry></row></thead><tbody><row><entry><literal moreinfo="none">2</literal></entry><entry><literal moreinfo="none">"baz"</literal></entry></row><row><entry><literal moreinfo="none">1</literal></entry><entry><literal moreinfo="none">"bar"</literal></entry></row></tbody></tgroup></informaltable><para>Now that looks a lot better. CouchDB started reading at the bottom
      of the view and went backward until it hit
      <literal moreinfo="none">endkey</literal>.<indexterm id="I_indexterm2_d1e3704" class="endofrange" startref="ch06_indexesefficient" significance="normal"/><indexterm id="I_indexterm2_d1e3705" class="endofrange" startref="ch06_viewslookups" significance="normal"/></para></sect2></sect1><sect1 id="I_sect12_d1e3706"><title>The View to Get Comments for Posts</title><para>We use an array key here to support the
    <literal moreinfo="none">group_level</literal> reduce query parameter. CouchDB’s views are
    stored in the B-tree file structure (which will be described in more
    detail later on). Because of the way B-trees are structured, we can cache
    the intermediate reduce results in the non-leaf nodes of the tree, so
    reduce queries can be computed along arbitrary key ranges in logarithmic
    time. See <xref linkend="figure_6_1"/>.<indexterm id="I_indexterm2_d1e3716" significance="normal"><primary>reduce functions</primary><secondary>group_level reduce queries</secondary></indexterm><indexterm class="startofrange" id="ch06_viewscomments" significance="normal"><primary>views</primary><secondary>getting comments for posts</secondary></indexterm><indexterm id="I_indexterm2_d1e3726" significance="normal"><primary>B-trees</primary><secondary>caching intermediate reduce results</secondary></indexterm><indexterm id="I_indexterm2_d1e3731" significance="normal"><primary>map functions</primary><secondary>view getting comments for posts</secondary></indexterm><indexterm class="startofrange" id="ch06_grouplevelreduce" significance="normal"><primary>group_level reduce queries</primary></indexterm></para><para>In the blog app, we use <literal moreinfo="none">group_level</literal> reduce
    queries to compute the count of comments both on a per-post and total
    basis, achieved by querying the same view index with different methods.
    With some array keys, and assuming each key has the value
    <literal moreinfo="none">1</literal>:</para><screen format="linespecific">["a","b","c"]
["a","b","e"]
["a","c","m"]
["b","a","c"]
["b","a","g"]</screen><para>the reduce view:</para><programlisting id="I_programlisting2_d1e3751" language="javascript" linenumbering="unnumbered" format="linespecific">function(keys, values, rereduce) {
  return sum(values)
}</programlisting><para>returns the total number of rows between the start and end key. So
    with <literal moreinfo="none">startkey=["a","b"]&amp;endkey=["b"]</literal> (which
    includes the first three of the above keys) the result would equal
    <literal moreinfo="none">3</literal>. The effect is to count rows. If you’d like to count
    rows without depending on the row value, you can switch on the
    <literal moreinfo="none">rereduce</literal> parameter:<indexterm id="I_indexterm2_d1e3764" significance="normal"><primary>reduce functions</primary><secondary>rereduce parameter</secondary></indexterm></para><programlisting id="I_programlisting2_d1e3769" language="javascript" linenumbering="unnumbered" format="linespecific">function(keys, values, rereduce) {
  if (rereduce) {
    return sum(values);
  } else {
    return values.length;
  }
}</programlisting><figure float="none" id="figure_6_1"><title>Comments map function</title><mediaobject id="I_mediaobject2_d1e3774"><imageobject role="print"><imagedata fileref="figs/print/codb_0601.pdf" format="PDF" scale="80"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0601.png" format="PNG" scale="80"/></imageobject></mediaobject></figure><para>This is the reduce view used by the example app to count comments,
    while utilizing the map to output the comments, which are more useful than
    just <literal moreinfo="none">1</literal> over and over. It pays to spend some time
    playing around with map and reduce functions. Futon is OK for this, but it
    doesn’t give full access to all the query parameters. Writing your own
    test code for views in your language of choice is a great way to explore
    the nuances and capabilities of CouchDB’s incremental MapReduce
    system.</para><para>Anyway, with a <literal moreinfo="none">group_level</literal> query, you’re
    basically running a series of reduce range queries: one for each
    <emphasis>group</emphasis> that shows up at the <emphasis>level</emphasis>
    you query. Let’s reprint the key list from earlier, grouped at level
    <literal moreinfo="none">1</literal>:</para><screen format="linespecific">["a"]   3
["b"]   2</screen><para>And at <literal moreinfo="none">group_level=2</literal>:</para><screen format="linespecific">["a","b"]   2
["a","c"]   1
["b","a"]   2</screen><para>Using the parameter <literal moreinfo="none">group=true</literal> makes it behave as
    though it were <literal moreinfo="none">group_level=Exact</literal>, so in the case of our
    current example, it would give the number 1 for each key, as there are no
    exactly duplicated keys.</para></sect1><sect1 id="I_sect12_d1e3816"><title>Reduce/Rereduce</title><para>We briefly talked about the <literal moreinfo="none">rereduce</literal> parameter to
    your reduce function. We’ll explain what’s up with it in this section. By
    now, you should have learned that your view result is stored in B-tree
    index structure for efficiency. The existence and use of the
    <literal moreinfo="none">rereduce</literal> parameter is tightly coupled to how the B-tree
    index works.<indexterm class="startofrange" id="ch06_indexBTreereduce" significance="normal"><primary>indexes</primary><secondary>B-tree, reduce view results and</secondary></indexterm><indexterm class="startofrange" id="ch06_BTreeindexreduce" significance="normal"><primary>B-trees</primary><secondary>index, reduce view results and</secondary></indexterm><indexterm class="startofrange" id="ch06_reducefunc" significance="normal"><primary>reduce functions</primary><secondary>rereduce parameter</secondary></indexterm><indexterm class="startofrange" id="ch06_viewsreduce" significance="normal"><primary>views</primary><secondary>reduce function and rereduce parameters</secondary></indexterm><indexterm id="I_indexterm2_d1e3847" class="endofrange" startref="ch06_grouplevelreduce" significance="normal"/><indexterm id="I_indexterm2_d1e3848" class="endofrange" startref="ch06_viewscomments" significance="normal"/></para><para>Consider the map result shown in <xref linkend="example_6-1"/>.</para><example id="example_6-1"><title>Example view result (mmm, food)</title><screen format="linespecific">"afrikan", 1
"afrikan", 1
"chinese", 1
"chinese", 1
"chinese", 1
"chinese", 1
"french", 1
"italian", 1
"italian", 1
"spanish", 1
"vietnamese", 1
"vietnamese", 1</screen></example><para>When we want to find out how many dishes there are per origin, we
    can reuse the simple reduce function shown earlier:</para><screen format="linespecific">function(keys, values, rereduce) {
  return sum(values);
}</screen><para><xref linkend="figure_6_2"/> shows a simplified version of what the
    B-tree index looks like. We abbreviated the key strings.</para><figure float="none" id="figure_6_2"><title>The B-tree index</title><mediaobject id="I_mediaobject2_d1e3868"><imageobject role="print"><imagedata fileref="figs/print/codb_0602.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0602.png" format="PNG"/></imageobject></mediaobject></figure><para>The view result is what computer science grads call a “pre-order”
    walk through the tree. We look at each element in each node starting from
    the left. Whenever we see that there is a subnode to descend into, we
    descend and start reading the elements in that subnode. When we have
    walked through the entire tree, we’re done.</para><para>You can see that CouchDB stores both keys and values inside each
    leaf node. In our case, it is simply always <literal moreinfo="none">1</literal>, but you
    might have a value where you count other results and then all rows have a
    different value. What’s important is that CouchDB runs all elements that
    are within a node into the reduce function (setting the
    <literal moreinfo="none">rereduce</literal> parameter to <literal moreinfo="none">false</literal>) and
    stores the result inside the parent node along with the edge to the
    <phrase role="keep-together">subnode.</phrase> In our case, each edge has
    a <literal moreinfo="none">3</literal> representing the reduce value for the node it
    points to.</para><para>In reality, nodes have more than 1,600 elements in them. CouchDB
    computes the result for all the elements in multiple iterations over the
    elements in a single node, not all at once (which would be disastrous for
    memory consumption).</para><para>Now let’s see what happens when we run a query. We want to know how
    many <literal moreinfo="none">"chinese"</literal> entries we have. The query option is
    simple: <literal moreinfo="none">?key="chinese"</literal>. See <xref linkend="figure_6_3"/>.</para><figure float="none" id="figure_6_3"><title>The B-tree index reduce result</title><mediaobject id="I_mediaobject2_d1e3908"><imageobject role="print"><imagedata fileref="figs/print/codb_0603.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0603.png" format="PNG"/></imageobject></mediaobject></figure><para>CouchDB detects that all values in the subnode include the
    <literal moreinfo="none">"chinese"</literal> key. It concludes that it can take just the
    <literal moreinfo="none">3</literal> value associated with that node to compute the final
    result. It then finds the node left to it and sees that it’s a node with
    keys outside the requested range (<literal moreinfo="none">key=</literal> requests a range
    where the beginning and the end are the same value). It concludes that it
    has to use the <literal moreinfo="none">"chinese"</literal> element’s value and the other
    node’s value and run them through the reduce function with the
    <literal moreinfo="none">rereduce</literal> parameter set to
    <literal moreinfo="none">true</literal>.</para><para>The reduce function effectively calculates <literal moreinfo="none">3 + 1</literal>
    on query time and returns the desired result. <xref linkend="example_6-2"/> shows some pseudocode that shows the last
    invocation of the reduce function with actual values.</para><example id="example_6-2"><title>The result is 4</title><screen format="linespecific">function(null, [3, 1], true) {
  return sum([3, 1]);
}</screen></example><para>Now, we said your reduce function must actually reduce your values.
    If you see the <phrase role="keep-together">B-tree</phrase>, it should
    become obvious what happens when you don’t reduce your values. Consider
    the following map result and reduce function. This time we want to get a
    list of all the unique labels in our view:</para><screen format="linespecific">"abc", "afrikan"
"cef", "afrikan"
"fhi", "chinese"
"hkl", "chinese"
"ino", "chinese"
"lqr", "chinese"
"mtu", "french"
"owx", "italian"
"qza", "italian"
"tdx", "spanish"
"xfg", "vietnamese"
"zul", "vietnamese"</screen><para>We don’t care for the key here and only list all the labels we have.
    Our reduce function removes duplicates; see <xref linkend="example_6-3"/>.</para><example id="example_6-3"><title>Don’t use this, it’s an example broken on purpose</title><screen format="linespecific">function(keys, values, rereduce) {
  var unique_labels = {};
  values.forEach(function(label) {
    if(!unique_labels[label]) {
      unique_labels[label] = true;
    }
  });

  return unique_labels;
}</screen></example><para>This translates to <xref linkend="figure_6_4"/>.</para><para>We hope you get the picture. The way the B-tree storage works means
    that if you don’t actually reduce your data in the reduce function, you
    end up having CouchDB copy huge amounts of data around that grow linearly,
    if not faster with the number of rows in your view.</para><para>CouchDB will be able to compute the final result, but only for views
    with a few rows. Anything larger will experience a ridiculously slow view
    build time. To help with that, CouchDB since version 0.10.0 will throw an
    error if your reduce function does not reduce its input values.</para><para>See <xref linkend="viewcookbookforsqljockeys"/> for an example of
    how to compute unique lists with views.</para><figure float="none" id="figure_6_4"><title>An overflowing reduce index</title><mediaobject id="I_mediaobject2_d1e3978"><imageobject role="print"><imagedata fileref="figs/print/codb_0604.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0604.png" format="PNG"/></imageobject></mediaobject></figure><sect2><title>Lessons Learned</title><itemizedlist><listitem><para>If you don’t use the key field in the map function, you are
          probably doing it wrong.</para></listitem><listitem><para>If you are trying to make a list of values unique in the
          reduce functions, you are probably doing it wrong.</para></listitem><listitem><para>If you don’t reduce your values to a single scalar value or a
          small fixed-sized object or array with a fixed number of scalar
          values of small sizes, you are probably doing it wrong.<indexterm id="I_indexterm2_d1e3996" class="endofrange" startref="ch06_indexBTreereduce" significance="normal"/><indexterm id="I_indexterm2_d1e3997" class="endofrange" startref="ch06_BTreeindexreduce" significance="normal"/><indexterm id="I_indexterm2_d1e3998" class="endofrange" startref="ch06_reducefunc" significance="normal"/><indexterm id="I_indexterm2_d1e3999" class="endofrange" startref="ch06_viewsreduce" significance="normal"/></para></listitem></itemizedlist></sect2></sect1><sect1 id="I_sect12_d1e4000"><title>Wrapping Up</title><para><emphasis>Map functions</emphasis> are side effect–free functions
    that take a document as argument and emit key/value pairs. CouchDB stores
    the <emphasis>emitted rows</emphasis> by constructing a sorted B-tree
    index, so row lookups by key, as well as streaming operations across a
    range of rows, can be accomplished in a small memory and processing
    footprint, while writes avoid seeks. Generating a view takes
    <literal moreinfo="none">O(N)</literal>, where <literal moreinfo="none">N</literal> is the total number of
    rows in the view. However, querying a view is very quick, as the B-tree
    remains shallow even when it contains many, many keys.<indexterm id="I_indexterm2_d1e4016" significance="normal"><primary>map functions</primary></indexterm></para><para><emphasis>Reduce functions</emphasis> operate on the sorted rows
    emitted by map view functions. CouchDB’s reduce functionality takes
    advantage of one of the fundamental properties of B-tree indexes: for
    every leaf node (a sorted row), there is a chain of internal nodes
    reaching back to the root. Each leaf node in the B-tree carries a few rows
    (on the order of tens, depending on row size), and each internal node may
    link to a few leaf nodes or other internal nodes.<indexterm id="I_indexterm2_d1e4023" significance="normal"><primary>reduce functions</primary></indexterm></para><?dbfo-need height=”1in”
?><para>The reduce function is run on every node in the tree in order to
    calculate the final reduce value. The end result is a reduce function that
    can be incrementally updated upon changes to the map function, while
    recalculating the reduction values for a minimum number of nodes. The
    initial reduction is calculated once per each node (inner and leaf) in the
    tree.</para><para>When run on leaf nodes (which contain actual map rows), the reduce
    function’s third parameter, <literal moreinfo="none">rereduce</literal>, is false. The
    arguments in this case are the keys and values as output by the map
    function. The function has a single returned reduction value, which is
    stored on the inner node that a working set of leaf nodes have in common,
    and is used as a cache in future reduce calculations.<indexterm id="I_indexterm2_d1e4034" significance="normal"><primary>reduce functions</primary><secondary>rereduce parameter</secondary></indexterm></para><para>When the reduce function is run on inner nodes, the
    <literal moreinfo="none">rereduce</literal> flag is <literal moreinfo="none">true</literal>. This allows
    the function to account for the fact that it will be receiving its own
    prior output. When <literal moreinfo="none">rereduce</literal> is <literal moreinfo="none">true</literal>,
    the values passed to the function are intermediate reduction values as
    cached from previous calculations. When the tree is more than two levels
    deep, the rereduce phase is repeated, consuming chunks of the previous
    level’s output until the final reduce value is calculated at the root
    node.</para><para>A common mistake new CouchDB users make is attempting to construct
    complex aggregate values with a reduce function. Full reductions should
    result in a scalar value, like <literal moreinfo="none">5</literal>, and not, for
    instance, a JSON hash with a set of unique keys and the count of each. The
    problem with this approach is that you’ll end up with a very large final
    value. The number of unique keys can be nearly as large as the number of
    total keys, even for a large set. It is fine to combine a few scalar
    calculations into one reduce function; for instance, to find the total,
    average, and standard deviation of a set of numbers in a single
    function.</para><para>If you’re interested in pushing the edge of CouchDB’s incremental
    reduce functionality, have a look at <ulink url="http://labs.google.com/papers/sawzall.html">Google’s paper on
    Sawzall</ulink>, which gives examples of some of the more exotic
    reductions that can be accomplished in a system with similar
    constraints.<indexterm id="I_indexterm2_d1e4063" class="endofrange" startref="ch06_views" significance="normal"/></para></sect1></chapter><chapter id="validationfunctions"><title>Validation Functions</title><para>In this chapter, we look closely at the individual components of
  Sofa’s validation function. Sofa has the basic set of validation features
  you’ll want in your apps, so understanding its validation function will give
  you a good foundation for others you may write in the future.<indexterm class="startofrange" id="ch07_validfunc" significance="normal"><primary>validation functions</primary></indexterm></para><para>CouchDB uses the <literal moreinfo="none">validate_doc_update</literal> function to
  prevent invalid or unauthorized document updates from proceeding. We use it
  in the example application to ensure that blog posts can be authored only by
  logged-in users. CouchDB’s validation <phrase role="keep-together">functions—</phrase>like map and reduce functions—can’t
  have any side effects; they run in isolation of a request. They have the
  opportunity to block not only end-user document saves, but also replicated
  documents from other CouchDBs.<indexterm id="I_indexterm3_d1e4080" significance="normal"><primary>validate_doc_update function</primary></indexterm></para><sect1 id="I_sect13_d1e4083"><title>Document Validation Functions</title><para>To ensure that users may save only documents that provide these
    fields, we can <phrase role="keep-together">validate their input</phrase>
    by adding another member to the <literal moreinfo="none">_design/</literal> document: the
    <literal role="keep-together" moreinfo="none">validate_doc_update</literal> function. This
    is the first time you’ve seen CouchDB’s external process in action.
    CouchDB sends functions and documents to a JavaScript interpreter. This
    mechanism is what allows us to write our document validation functions in
    JavaScript. The <literal moreinfo="none">validate_doc_update</literal> function gets
    executed for each document you want to create or update. If the validation
    function raises an exception, the update is denied; when it doesn’t, the
    updates are accepted.<indexterm id="I_indexterm3_d1e4100" significance="normal"><primary>JavaScript</primary><secondary>document validation functions</secondary></indexterm><indexterm id="I_indexterm3_d1e4105" significance="normal"><primary>documents</primary><secondary>validation functions for</secondary></indexterm><indexterm id="I_indexterm3_d1e4111" significance="normal"><primary>validation functions</primary><secondary>document validation</secondary></indexterm></para><para>Document validation is optional. If you don’t create a validation
    function, no checking is done and documents with any content or structure
    can be written into your CouchDB database. If you have multiple design
    documents, each with a <literal moreinfo="none">validate_doc_update</literal> function,
    all of those functions are called upon each incoming write request. Only
    if all of them pass does the write succeed. The order of the validation
    execution is not defined. Each validation function must act on its own.
    See <xref linkend="figure_7-1"/>.</para><figure float="none" id="figure_7-1"><title>The JavaScript document validation function</title><mediaobject id="I_mediaobject3_d1e4126"><imageobject role="print"><imagedata fileref="figs/print/codb_0701.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0701.png" format="PNG"/></imageobject></mediaobject></figure><para>Validation functions can cancel document updates by throwing errors.
    To throw an error in such a way that the user will be asked to
    authenticate, before retrying the request, use JavaScript code
    like:</para><programlisting id="I_programlisting3_d1e4133" language="javascript" linenumbering="unnumbered" format="linespecific">throw({unauthorized : message});</programlisting><para>When you’re trying to prevent an authorized user from saving invalid
    data, use this:</para><programlisting id="I_programlisting3_d1e4137" language="javascript" linenumbering="unnumbered" format="linespecific">throw({forbidden : message});</programlisting><para>This function throws <literal moreinfo="none">forbidden</literal> errors when a post
    does not contain the necessary fields. In places it uses a
    <literal moreinfo="none">validate()</literal> helper to clean up the JavaScript. We also
    use simple JavaScript conditionals to ensure that the
    <literal moreinfo="none">doc._id</literal> is set to be the same as
    <literal moreinfo="none">doc.slug</literal> for the sake of pretty URLs.</para><para>If no exceptions are thrown, CouchDB expects the incoming document
    to be valid and will write it to the database. By using JavaScript to
    validate JSON documents, we can deal with any structure a document might
    have. Given that you can just make up document structure as you go, being
    able to validate what you come up with is pretty flexible and powerful.
    Validation can also be a valuable form of documentation.</para></sect1><sect1 id="I_sect13_d1e4155"><title>Validation’s Context</title><para>Before we delve into the details of our validation function, let’s
    talk about the context in which they run and the effects they can
    have.<indexterm id="I_indexterm3_d1e4160" significance="normal"><primary>validation functions</primary><secondary>context of validation</secondary></indexterm></para><para>Validation functions are stored in <emphasis>design
    documents</emphasis> under the <literal moreinfo="none">validate_doc_update</literal>
    field. There is only one per design document, but there can be many design
    documents in a database. In order for a document to be saved, it must pass
    validations on all design documents in the database (the order in which
    multiple validations are executed is left undefined). In this chapter,
    we’ll assume you are working in a database with only one validation
    function.<indexterm id="I_indexterm3_d1e4173" significance="normal"><primary>design documents</primary><secondary>validation functions in</secondary></indexterm></para></sect1><sect1 id="I_sect13_d1e4178"><title>Writing One</title><para>The function declaration is simple. It takes three arguments: the
    proposed document update, the current version of the document on disk, and
    an object corresponding to the user initiating the request.<indexterm class="startofrange" id="ch07_validfuncwriting" significance="normal"><primary>validation functions</primary><secondary>writing</secondary></indexterm></para><programlisting id="I_programlisting3_d1e4188" language="javascript" linenumbering="unnumbered" format="linespecific">function(newDoc, oldDoc, userCtx) {}</programlisting><para>Above is the simplest possible validation function, which, when
    deployed, would allow all updates regardless of content or user roles. The
    converse, which never lets anyone do anything, looks like this:</para><programlisting id="I_programlisting3_d1e4192" language="javascript" linenumbering="unnumbered" format="linespecific">function(newDoc, oldDoc, userCtx) {
  throw({forbidden : 'no way'});
}</programlisting><para>Note that if you install this function in your database, you won’t
    be able to perform any other document operations until you remove it from
    the design document or delete the design document. Admins can create and
    delete design documents despite the existence of this extreme validation
    function.</para><para>We can see from these examples that the return value of the function
    is ignored. Validation functions prevent document updates by raising
    errors. When the validation function passes without raising errors, the
    update is allowed to proceed.</para><sect2><title>Type</title><para>The most basic use of validation functions is to ensure that
      documents are properly formed to fit your application’s expectations.
      Without validation, you need to check for the existence of all fields on
      a document that your MapReduce or user-interface code needs to function.
      With validation, you know that any saved documents meet whatever
      criteria you require.<indexterm id="I_indexterm3_d1e4203" significance="normal"><primary>types</primary><secondary>validating for documents</secondary></indexterm><indexterm id="I_indexterm3_d1e4208" significance="normal"><primary>validation functions</primary><secondary>writing</secondary><tertiary>for types</tertiary></indexterm></para><para>A common pattern in most languages, frameworks, and databases is
      using types to distinguish between subsets of your data. For instance,
      in Sofa we have a few document types, most prominently
      <literal moreinfo="none">post</literal> and <literal moreinfo="none">comment</literal>.<indexterm id="I_indexterm3_d1e4223" significance="normal"><primary>data types</primary></indexterm></para><para>CouchDB itself has no notion of types, but they are a convenient
      shorthand for use in your application code, including MapReduce views,
      display logic, and user interface code. The convention is to use a field
      called <literal moreinfo="none">type</literal> to store document types, but many
      frameworks use other fields, as CouchDB itself doesn’t care which field
      you use. (For instance, the CouchRest Ruby client uses
      <literal moreinfo="none">couchrest-type</literal>).<indexterm id="I_indexterm3_d1e4234" significance="normal"><primary>type field</primary></indexterm></para><para>Here’s an example validation function that runs only on
      posts:</para><programlisting id="I_programlisting3_d1e4239" language="javascript" linenumbering="unnumbered" format="linespecific">function(newDoc, oldDoc, userCtx) {
  if (newDoc.type == "post") {
    // validation logic goes here
  }
}</programlisting><para>Since CouchDB stores only one validation function per design
      document, you’ll end up validating multiple types in one function, so
      the overall structure becomes something like:</para><programlisting id="I_programlisting3_d1e4243" language="javascript" linenumbering="unnumbered" format="linespecific">function(newDoc, oldDoc, userCtx) {
  if (newDoc.type == "post") {
    // validation logic for posts
  }
  if (newDoc.type == "comment") {
    // validation logic for comments
  }
  if (newDoc.type == "unicorn") {
    // validation logic for unicorns
  }
}</programlisting><para>It bears repeating that <literal moreinfo="none">type</literal> is a completely
      optional field. We present it here as a helpful technique for managing
      validations in CouchDB, but there are other ways to write validation
      functions. Here’s an example that uses <emphasis>duck typing</emphasis>
      instead of an explicit <literal moreinfo="none">type</literal> attribute:<indexterm id="I_indexterm3_d1e4256" significance="normal"><primary>types</primary><seealso>data types</seealso></indexterm><indexterm id="I_indexterm3_d1e4261" significance="normal"><primary>duck typing</primary></indexterm></para><programlisting id="I_programlisting3_d1e4264" language="javascript" linenumbering="unnumbered" format="linespecific">function(newDoc, oldDoc, userCtx) {
  if (newDoc.title &amp;&amp; newDoc.body) {
    // validate that the document has an author
  }
}</programlisting><para>This validation function ignores the <literal moreinfo="none">type</literal>
      attribute altogether and instead makes the somewhat simpler requirement
      that any document with both a title and a body must have an author. For
      some applications, typeless validations are simpler. For others, it can
      be a pain to keep track of which sets of fields are dependent on one
      another.</para><para>In practice, many applications end up using a mix of typed and
      untyped validations. For instance, Sofa uses document types to track
      which fields are required on a given document, but it also uses duck
      typing to validate the structure of particular named fields. We don’t
      care what sort of document we’re validating. If the document has a
      <literal role="keep-together" moreinfo="none">created_at</literal> field, we ensure that
      the field is a properly formed timestamp. Similarly, when we validate
      the author of a document, we don’t care what type of document it is; we
      just ensure that the author matches the user who saved the
      document.<indexterm id="I_indexterm3_d1e4277" significance="normal"><primary>types</primary><secondary>typed and untyped validations</secondary></indexterm><indexterm id="I_indexterm3_d1e4282" significance="normal"><primary>created_at field</primary></indexterm></para></sect2><sect2><title>Required Fields</title><para>The most fundamental validation is ensuring that particular fields
      are available on a document. The proper use of required fields can make
      writing MapReduce views much simpler, as you don’t have to test for all
      the properties before using them—you know all documents will be
      well-formed.<indexterm id="I_indexterm3_d1e4290" significance="normal"><primary>required fields, validating</primary></indexterm><indexterm id="I_indexterm3_d1e4293" significance="normal"><primary>validation functions</primary><secondary>writing</secondary><tertiary>for required fields</tertiary></indexterm></para><para>Required fields also make display logic much simpler. Nothing says
      amateur like the word <literal moreinfo="none">undefined</literal> showing up throughout
      your application. If you know for certain that all documents will have a
      field, you can avoid lengthy conditional statements to render the
      display differently depending on document structure.<indexterm id="I_indexterm3_d1e4305" significance="normal"><primary>display logic</primary><secondary>required fields and</secondary></indexterm></para><para>Sofa requires a different set of fields on posts and comments.
      Here’s a subset of the Sofa validation function:</para><programlisting id="I_programlisting3_d1e4312" language="javascript" linenumbering="unnumbered" format="linespecific">function(newDoc, oldDoc, userCtx) {
  function require(field, message) {
    message = message || "Document must have a " + field;
    if (!newDoc[field]) throw({forbidden : message});
  };

  if (newDoc.type == "post") {
    require("title");
    require("created_at");
    require("body");
    require("author");
  }
  if (newDoc.type == "comment") {
    require("name");
    require("created_at");
    require("comment", "You may not leave an empty comment");
  }
}</programlisting><para>This is our first look at actual validation logic. You can see
      that the actual error throwing code has been wrapped in a helper
      function. Helpers like the <literal moreinfo="none">require</literal> function just
      shown go a long way toward making your code clean and readable. The
      <literal moreinfo="none">require</literal> function is simple. It takes a field name and
      an optional message, and it ensures that the field is not empty or
      blank.<indexterm id="I_indexterm3_d1e4322" significance="normal"><primary>require( ) function</primary></indexterm></para><para>Once we’ve declared our helper function, we can simply use it in a
      type-specific way. Posts require a <literal moreinfo="none">title</literal>, a
      <literal moreinfo="none">timestamp</literal>, a <literal moreinfo="none">body</literal>, and an
      <literal moreinfo="none">author</literal>. Comments require a <literal moreinfo="none">name</literal>, a
      <literal moreinfo="none">timestamp</literal>, and the <literal moreinfo="none">comment</literal> itself.
      If we wanted to require that every single document contained a
      <literal moreinfo="none">created_at</literal> field, we could move that declaration
      outside of any type conditional logic.</para></sect2><sect2><title>Timestamps</title><para>Timestamps are an interesting problem in validation functions.
      Because validation functions are run at replication time as well as
      during normal client access, we can’t require that timestamps be set
      close to the server’s system time. We can require two things: that
      timestamps do not change after they are initially set, and that they are
      well formed. What it means to be well formed depends on your
      application. We’ll look at Sofa’s particular requirements here, as well
      as digress a bit about other options for timestamp formats.<indexterm id="I_indexterm3_d1e4357" significance="normal"><primary>unchanged( ) function</primary></indexterm><indexterm id="I_indexterm3_d1e4360" significance="normal"><primary>validation functions</primary><secondary>writing</secondary><tertiary>for timestamps</tertiary></indexterm><indexterm id="I_indexterm3_d1e4367" significance="normal"><primary>timestamps, problem in validation functions</primary></indexterm></para><para>First, let’s look at a validation helper that does not allow
      fields, once set, to be changed on subsequent updates:</para><programlisting id="I_programlisting3_d1e4372" language="javascript" linenumbering="unnumbered" format="linespecific">function(newDoc, oldDoc, userCtx) {
  function unchanged(field) {
    if (oldDoc &amp;&amp; toJSON(oldDoc[field]) != toJSON(newDoc[field]))
      throw({forbidden : "Field can't be changed: " + field});
  }
  unchanged("created_at");
}</programlisting><para>The <literal moreinfo="none">unchanged</literal> helper is a little more complex
      than the <literal moreinfo="none">require</literal> helper, but not much. The first line
      of the function prevents it from running on initial updates. The
      <literal moreinfo="none">unchanged</literal> helper doesn’t care at all what goes into a
      field the first time it is saved. However, if there exists an
      already-saved version of the document, the <literal moreinfo="none">unchanged</literal>
      helper requires that whatever fields it is used on are the same between
      the new and the old version of the document.<indexterm id="I_indexterm3_d1e4388" significance="normal"><primary>JavaScript</primary><secondary>equality tests</secondary></indexterm><indexterm id="I_indexterm3_d1e4393" significance="normal"><primary>equality tests</primary></indexterm></para><para>JavaScript’s equality test is not well suited to working with
      deeply nested objects. We use CouchDB’s JavaScript runtime’s built-in
      <literal moreinfo="none">toJSON</literal> function in our equality test, which is better
      than testing for raw equality. Here’s why:</para><screen format="linespecific">js&gt; [] == []
false</screen><para>JavaScript considers these arrays to be different because it
      doesn’t look at the contents of the array when making the decision.
      Since they are distinct objects, JavaScript must consider them not
      equal. We use the <literal moreinfo="none">toJSON</literal> function to convert objects
      to a string representation, which makes comparisons more likely to
      succeed in the case where two objects have the same contents. This is
      not guaranteed to work for deeply nested <phrase role="keep-together">objects</phrase>, as <literal moreinfo="none">toJSON</literal> may
      serialize objects.<indexterm id="I_indexterm3_d1e4414" significance="normal"><primary>js command</primary></indexterm><indexterm id="I_indexterm3_d1e4417" significance="normal"><primary>JSON (JavaScript Object Notation)</primary><secondary>toJSON function</secondary></indexterm></para><note><para>The <literal moreinfo="none">js</literal> command gets installed when you
        install CouchDB’s SpiderMonkey dependency. It is a command-line
        application that lets you parse, evaluate, and run JavaScript code.
        <literal moreinfo="none">js</literal> lets you quickly test JavaScript code snippets
        like the one previously shown. You can also run a syntax check of your
        JavaScript code using <literal moreinfo="none">js file.js</literal>. In case CouchDB’s
        error messages are not helpful, you can resort to testing your code
        standalone and get a useful error report.</para></note></sect2><sect2><title>Authorship</title><para>Authorship is an interesting question in distributed systems. In
      some environments, you can trust the server to ascribe authorship to a
      document. Currently, CouchDB has a simple built-in validation system
      that manages <emphasis>node admins</emphasis>. There are plans to add a
      database admin role, as well as other roles. The authentication system
      is pluggable, so you can integrate with existing services to
      authenticate users to CouchDB using an HTTP layer, using LDAP
      integration, or through other means.<indexterm id="I_indexterm3_d1e4442" significance="normal"><primary>node admins</primary></indexterm><indexterm id="I_indexterm3_d1e4445" significance="normal"><primary>authorship, validating</primary></indexterm><indexterm id="I_indexterm3_d1e4448" significance="normal"><primary>validation functions</primary><secondary>writing</secondary><tertiary>for authorship</tertiary></indexterm></para><para>Sofa uses the built-in node admin account system and so is best
      suited for single or small groups of authors. Extending Sofa to store
      author credentials in CouchDB itself is an exercise left to the
      reader.</para><para>Sofa’s validation logic says that documents saved with an author
      field must be saved by the author listed on that field:</para><programlisting id="I_programlisting3_d1e4459" language="javascript" linenumbering="unnumbered" format="linespecific">function(newDoc, oldDoc, userCtx) {
  if (newDoc.author) {
    enforce(newDoc.author == userCtx.name,
      "You may only update documents with author " + userCtx.name);
  }
}</programlisting></sect2></sect1><sect1 id="I_sect13_d1e4461"><title>Wrapping Up</title><para>Validation functions are a powerful tool to ensure that only
    documents you expect end up in your databases. You can test writes to your
    database by content, by structure, and by user who is making the document
    request. Together, these three angles let you build sophisticated
    validation routines that will stop anyone from tampering with your <phrase role="keep-together">database.<indexterm id="I_indexterm3_d1e4468" class="endofrange" startref="ch07_validfuncwriting" significance="normal"/></phrase></para><para>Of course, validation functions are no substitute for a full
    security system, although they go a long way and work well with CouchDB’s
    other security mechanisms. Read more about CouchDB’s security in <xref linkend="security"/>.<indexterm id="I_indexterm3_d1e4473" class="endofrange" startref="ch07_validfunc" significance="normal"/></para></sect1></chapter><chapter id="showfunctions"><title>Show Functions</title><para>CouchDB’s JSON documents are great for programmatic access in most
  environments. Almost all languages have HTTP and JSON libraries, and in the
  unlikely event that yours doesn’t, writing them is fairly simple. However,
  there is one important use case that JSON documents don’t cover: building
  plain old HTML web pages. Browsers are powerful, and it’s exciting that we
  can build Ajax applications using only CouchDB’s JSON and HTTP APIs, but
  this approach is not appropriate for most public-facing websites.<indexterm id="I_indexterm4_d1e4479" significance="normal"><primary>HTML</primary><secondary>rendering from database records</secondary></indexterm><indexterm class="startofrange" id="ch08_showfunc" significance="normal"><primary>show functions</primary></indexterm></para><para>HTML is the <emphasis>lingua franca</emphasis> of the web, for good
  reasons. By rendering our JSON documents into HTML pages, we make them
  available and accessible for a wider variety of uses. With the pure Ajax
  approach, visually impaired visitors to our blog stand a chance of not
  seeing any useful content at all, as popular screen-reading browsers have a
  hard time making sense of pages when the content is changed on the fly via
  JavaScript. Another important concern for authors is that their writing be
  indexed by search engines. Maintaining a high-quality blog doesn’t do much
  good if readers can’t find it via a web search. Most search engines do not
  execute JavaScript found within a page, so to them an Ajax blog looks devoid
  of content. We also mustn’t forget that HTML is likely more friendly as an
  archive format in the long term than the platform-specific JavaScript and
  JSON approach we used in previous chapters. Also, by serving plain HTML, we
  make our site snappier, as the browser can render meaningful content with
  fewer round-trips to the server. These are just a few of the reasons it
  makes sense to provide web content as HTML.<indexterm id="I_indexterm4_d1e4492" significance="normal"><primary>JSON (JavaScript Object Notation)</primary><secondary>rendering JSON documents into HTML web pages</secondary></indexterm></para><para>The traditional way to accomplish the goal of rendering HTML from
  database records is by using a middle-tier application server, such as Ruby
  on Rails or Django, which loads the appropriate records for a user request,
  runs a template function using them, and returns the resulting HTML to the
  visitor’s browser. The basics of this don’t change in CouchDB’s case;
  wrapping JSON views and documents with an application server is relatively
  straightforward. Rather than using browser-side JavaScript to load JSON from
  CouchDB and rendering dynamic pages, Rails or Django (or your framework of
  choice) could make those same HTTP requests against CouchDB, render the
  output to HTML, and return it to the browser. We won’t cover this approach
  in this book, as it is specific to particular languages and frameworks, and
  surveying the different options would take more space than you want to
  read.<indexterm id="I_indexterm4_d1e4499" significance="normal"><primary>application servers, rendering JSON documents into
      HTML</primary></indexterm><indexterm id="I_indexterm4_d1e4502" significance="normal"><primary>Django</primary></indexterm><indexterm id="I_indexterm4_d1e4505" significance="normal"><primary>Ruby on Rails</primary></indexterm><indexterm id="I_indexterm4_d1e4508" significance="normal"><primary>middle-tier application servers</primary></indexterm></para><para>CouchDB includes functionality designed to make it possible to do most
  of what an application tier would do, without relying on additional
  software. The appeal of this approach is that CouchDB can serve the whole
  application without dependencies on a complex environment such as might be
  maintained on a production web server. Because CouchDB is designed to run on
  client computers, where the environment is out of the control of application
  developers, having some built-in templating capabilities greatly expands the
  potential uses of these applications. When your application can be served by
  a standard CouchDB instance, you gain deployment ease and
  flexibility.</para><sect1 id="I_sect14_d1e4513"><title>The Show Function API</title><para>Show functions, as they are called, have a constrained API designed
    to ensure <phrase role="keep-together">cache</phrase><phrase role="keep-together">ability</phrase> and side effect–free operation. This
    is in stark contrast to other application servers, which give the
    programmer the freedom to run any operation as the result of any request.
    Let’s look at a few example show functions.<indexterm id="I_indexterm4_d1e4523" significance="normal"><primary>show functions</primary><secondary>API for</secondary></indexterm></para><para>The most basic show function looks something like this:</para><programlisting id="I_programlisting4_d1e4530" language="javascript" linenumbering="unnumbered" format="linespecific">function(doc, req) {
  return '&lt;h1&gt;' + doc.title + '&lt;/h1&gt;';
}</programlisting><para>When run with a document that has a field called
    <literal moreinfo="none">title</literal> with the content “Hello World,” this function
    will send an HTTP response with the default Content-Type of
    <literal moreinfo="none">text/html</literal>, the UTF-8 character encoding, and the body
    <literal moreinfo="none">&lt;h1&gt;Hello World&lt;/h1&gt;</literal>.</para><para>The simplicity of the request/response cycle of a show function is
    hard to overstate. The most common question we hear is, “How can I load
    another document so that I can render its content as well?” The short
    answer is that you can’t. The longer answer is that for some applications
    you might use a list function to render a view result as HTML, which gives
    you the opportunity to use more than one document as the input of your
    function.</para><para>The basic function from a document and a request to a response, with
    no side effects and no alternative inputs, stays the same even as we start
    using more advanced features. Here’s a more complex show function
    illustrating the ability to set custom headers:<indexterm id="I_indexterm4_d1e4547" significance="normal"><primary>headers</primary><secondary>custom, setting with show function</secondary></indexterm></para><programlisting id="I_programlisting4_d1e4552" language="javascript" linenumbering="unnumbered" format="linespecific">function(doc, req) {
  return {
    body : '&lt;foo&gt;' + doc.title + '&lt;/foo&gt;',
    headers : {
      "Content-Type" : "application/xml",
      "X-My-Own-Header": "you can set your own headers"
    }
  }
}</programlisting><para>If this function were called with the same document as we used in
    the previous example, the response would have a Content-Type of
    <literal moreinfo="none">application/xml</literal> and the body <literal moreinfo="none">&lt;foo&gt;Hello
    World&lt;/foo&gt;</literal>. You should be able to see from this how you’d
    be able to use show functions to generate any output you need, from any of
    your documents.</para><para>Popular uses of show functions are for outputting HTML page, CSV
    files, or XML needed for compatibility with a particular interface. The
    CouchDB test suite even <phrase role="keep-together">illustrates</phrase>
    using show functions to output a PNG image. To output binary data, there
    is the option to return a Base64-encoded string, like this:</para><programlisting id="I_programlisting4_d1e4567" language="javascript" linenumbering="unnumbered" format="linespecific">function(doc, req) {
  return {
    base64 :
      ["iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAsV",
        "BMVEUAAAD////////////////////////5ur3rEBn////////////////wDBL/",
        "AADuBAe9EB3IEBz/7+//X1/qBQn2AgP/f3/ilpzsDxfpChDtDhXeCA76AQH/v7",
        "/84eLyWV/uc3bJPEf/Dw/uw8bRWmP1h4zxSlD6YGHuQ0f6g4XyQkXvCA36MDH6",
        "wMH/z8/yAwX64ODeh47BHiv/Ly/20dLQLTj98PDXWmP/Pz//39/wGyJ7Iy9JAA",
        "AADHRSTlMAbw8vf08/bz+Pv19jK/W3AAAAg0lEQVR4Xp3LRQ4DQRBD0QqTm4Y5",
        "zMxw/4OleiJlHeUtv2X6RbNO1Uqj9g0RMCuQO0vBIg4vMFeOpCWIWmDOw82fZx",
        "vaND1c8OG4vrdOqD8YwgpDYDxRgkSm5rwu0nQVBJuMg++pLXZyr5jnc1BaH4GT",
        "LvEliY253nA3pVhQqdPt0f/erJkMGMB8xucAAAAASUVORK5CYII="].join(''),
    headers : {
      "Content-Type" : "image/png"
    }
  };
}</programlisting><para>This function outputs a 16×16 pixel version of the CouchDB logo. The
    JavaScript code necessary to generate images from document contents would
    likely be quite complex, but the ability to send Base64-encoded binary
    data means that query servers written in other languages like C or PHP
    have the ability to output any data type.</para></sect1><sect1 id="I_sect14_d1e4572"><title>Side Effect–Free</title><para>We’ve mentioned that a key constraint of show functions is that they
    are side effect–free. This means that you can’t use them to update
    documents, kick off background processes, or trigger any other function.
    In the big picture, this is a <emphasis>good thing</emphasis>, as it
    allows CouchDB to give performance and reliability guarantees that
    standard web frameworks can’t. Because a show function will always return
    the same result given the same input and can’t change anything about the
    environment in which it runs, its output can be cached and intelligently
    reused. In a high-availability deployment with proper caching, this means
    that a given show function will be called only once for any particular
    document, and the CouchDB server may not even be contacted for subsequent
    requests.<indexterm id="I_indexterm4_d1e4580" significance="normal"><primary>show functions</primary><secondary>free of side effects</secondary></indexterm></para><para>Working without side effects can be a little bit disorienting for
    developers who are used to the anything-goes approach offered by most
    application servers. It’s considered best practice to ensure that actions
    run in response to GET requests are side <phrase role="keep-together">effect–free</phrase> and cacheable, but rarely do we
    have the discipline to achieve that goal. CouchDB takes a different tack:
    because it’s a database, not an application server, we think it’s more
    important to enforce best practices (and ensure that developers don’t
    write functions that adversely effect the database server) than offer
    absolute flexibility. Once you’re used to working within these
    constraints, they start to make a lot of sense. (There’s a reason they are
    considered best practices.)<indexterm id="I_indexterm4_d1e4590" significance="normal"><primary>GET requests</primary><secondary>responses to, side effect–free and cacheable</secondary></indexterm></para></sect1><sect1 id="I_sect14_d1e4595"><title>Design Documents</title><para>Before we look into show functions themselves, we’ll quickly review
    how they are stored in design documents. CouchDB looks for show functions
    stored in a top-level field called <literal moreinfo="none">shows</literal>, which is
    named like this to be parallel with <literal moreinfo="none">views</literal>,
    <literal moreinfo="none">lists</literal>, and <literal moreinfo="none">filters</literal>. Here’s an
    example design document that defines two show functions:<indexterm id="I_indexterm4_d1e4612" significance="normal"><primary>shows field</primary></indexterm><indexterm id="I_indexterm4_d1e4615" significance="normal"><primary>show functions</primary><secondary>storage in design documents</secondary></indexterm><indexterm id="I_indexterm4_d1e4621" significance="normal"><primary>design documents</primary><secondary>show functions in</secondary></indexterm></para><programlisting id="I_programlisting4_d1e4626" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "_id" : "_design/show-function-examples",
  "shows" : {
    "summary" : "function(doc, req){ ... }",
    "detail" : "function(doc, req){ ... }"
  }
}</programlisting><para>There’s not much to note here except the fact that design documents
    can define multiple show functions. Now let’s see how these functions are
    run.</para></sect1><sect1 id="I_sect14_d1e4630"><title>Querying Show Functions</title><para>We’ve described the show function API, but we haven’t yet seen how
    these functions are run.<indexterm class="startofrange" id="ch08_showfuncquery" significance="normal"><primary>show functions</primary><secondary>querying</secondary></indexterm></para><para>The show function lives inside a design document, so to invoke it we
    append the name of the function to the design document itself, and then
    the ID of the document we want to render:</para><screen format="linespecific">GET /mydb/_design/mydesign/_show/myshow/72d43a93eb74b5f2</screen><para>Because show functions (and the others like list, etc.) are
    available as resources within the design document path, all resources
    provided by a particular design document can be found under a common root,
    which makes custom application proxying simpler. We’ll see an example of
    this in <xref linkend="part3"/>.</para><para>If the document with ID <literal moreinfo="none">72d43a93eb74b5f2</literal> does not
    exist, the request will result in an HTTP 500 Internal Server Error
    response. This seems a little harsh; why does it happen? If we query a
    show function with a document ID that doesn’t point to an existing
    document, the <literal moreinfo="none">doc</literal> argument in the function is
    <literal moreinfo="none">null</literal>. Then the show function tries to access it, and
    the JavaScript interpreter doesn’t like that. So it bails out. To secure
    against these errors, or to handle non-existing documents in a custom way
    (e.g., a wiki could display a “create new page” page), you can wrap the
    code in our function with <literal moreinfo="none">if(doc !== null) { ...
    }</literal>.</para><para>However, show functions can also be called without a document ID at
    all, like this:</para><screen format="linespecific">GET /mydb/_design/mydesign/_show/myshow</screen><para>In this case, the <literal moreinfo="none">doc</literal> argument to the function
    has the value <literal moreinfo="none">null</literal>. This option is useful in cases
    where the show function can make sense without a document. For instance,
    in the example application we’ll explore in <xref linkend="part3"/>, we
    use the same show function to provide for editing existing blog posts when
    a DocID is given, as well as for composing new blog posts when no DocID is
    given. The alternative would be to maintain an alternate resource (likely
    a static HTML attachment) with parallel functionality. As programmers, we
    strive not to repeat ourselves, which motivated us to give show functions
    the ability to run without a document ID.</para><sect2><title>Design Document Resources</title><para>In addition to the ability to run show functions, other resources
      are available within the design document path. This combination of
      features within the design document resource means that applications can
      be deployed without exposing the full CouchDB API to visitors, with only
      a simple proxy to rewrite the paths. We won’t go into full detail here,
      but the gist of it is that end users would run the previous query from a
      path like this:<indexterm id="I_indexterm4_d1e4681" significance="normal"><primary>design document resources</primary></indexterm><indexterm id="I_indexterm4_d1e4684" significance="normal"><primary>show functions</primary><secondary>querying</secondary><tertiary>design document resources</tertiary></indexterm></para><screen format="linespecific">GET /_show/myshow/72d43a93eb74b5f2</screen><para>Under the covers, an HTTP proxy can be programmed to prepend the
      database and design document portion of the path (in this case,
      <filename moreinfo="none">/mydb/_design/mydesign</filename>) so that CouchDB sees the
      standard query. With such a system in place, end users can access the
      application only via functions defined on the design document, so
      developers can enforce constraints and prevent access to raw JSON
      document and view data. While it doesn’t provide 100% security, using
      custom rewrite rules is an effective way to control the access end users
      have to a CouchDB application. This technique has been used in
      production by a few websites at the time of this writing.</para></sect2><sect2><title>Query Parameters</title><para>The request object (including helpfully parsed versions of query
      parameters) is available to show functions as well. By way of
      illustration, here’s a show function that returns different data based
      on the URL query parameters:<indexterm id="I_indexterm4_d1e4703" significance="normal"><primary>URL parameters for show function queries</primary></indexterm><indexterm id="I_indexterm4_d1e4706" significance="normal"><primary>show functions</primary><secondary>querying</secondary><tertiary>query parameters</tertiary></indexterm></para><programlisting id="I_programlisting4_d1e4713" language="javascript" linenumbering="unnumbered" format="linespecific">function(req, doc) {
  return "&lt;p&gt;Aye aye, " + req.parrot + "!&lt;/p&gt;";
}</programlisting><para>Requesting this function with a query parameter will result in the
      query parameter being used in the output:</para><screen format="linespecific">GET /mydb/_design/mydesign/_show/myshow?parrot=Captain</screen><para>In this case, we’ll see the output: <literal moreinfo="none">&lt;p&gt;Aye aye,
      Captain!&lt;/p&gt;</literal></para><para>Allowing URL parameters into the function does not affect
      cacheability, as each unique invocation results in a distinct URL.
      However, making heavy use of this feature will lower your cache
      effectiveness. Query parameters like this are most useful for doing
      things like switching the mode or the format of the show function
      output. It’s <phrase role="keep-together">recommended</phrase> that you
      avoid using them for things like inserting custom content (such as
      requesting the user’s nickname) into the response, as that will mean
      each users’s data must be cached separately.</para></sect2><sect2><title>Accept Headers</title><para>Part of the HTTP spec allows for clients to give hints to the
      server about which media types they are capable of accepting. At this
      time, the JavaScript query server shipped with CouchDB 0.10.0 contains
      helpers for working with Accept headers. However, web browser support
      for Accept headers is <emphasis>very poor</emphasis>, which has prompted
      frameworks such as Ruby on Rails to remove their support for them.
      CouchDB may or may not follow suit here, but the fact remains that you
      are discouraged from relying on Accept headers for applications that
      will be accessed via web browsers.<indexterm id="I_indexterm4_d1e4737" significance="normal"><primary>headers</primary><secondary>Accept headers</secondary></indexterm><indexterm id="I_indexterm4_d1e4742" significance="normal"><primary>show functions</primary><secondary>querying</secondary><tertiary>Accept headers</tertiary></indexterm><indexterm id="I_indexterm4_d1e4749" significance="normal"><primary>web browsers</primary><secondary>lack of support for Accept headers</secondary></indexterm><indexterm id="I_indexterm4_d1e4754" significance="normal"><primary>content types</primary><secondary>Accept headers and</secondary></indexterm><indexterm id="I_indexterm4_d1e4759" significance="normal"><primary>Accept headers</primary></indexterm></para><para>There is a suite of helpers for Accept headers present that allow
      you to specify the format in a query parameter as well. For
      instance:</para><screen format="linespecific">GET /db/_design/app/_show/post
Accept: application/xml</screen><para>is equivalent to a similar URL with mismatched Accept headers.
      This is because browsers don’t use sensible Accept headers for feed
      URLs. Browsers 1, Accept headers 0. Yay browsers.</para><screen format="linespecific">GET /db/_design/app/_show/post?format=xml
Accept: x-foo/whatever</screen><para>The request function allows developers to switch response
      Content-Types based on the client’s request. The next example adds the
      ability to return either HTML, XML, or a developer-designated media
      type: <literal moreinfo="none">x-foo/whatever</literal>.<indexterm id="I_indexterm4_d1e4775" significance="normal"><primary>format, render_function function</primary></indexterm></para><para>CouchDB’s <filename moreinfo="none">main.js</filename> library provides
      the<literal moreinfo="none"> ("format", render_function)</literal> function, which makes
      it easy for developers to handle client requests for multiple MIME types
      in one form function.</para><para>This function also shows off the use of
      <literal moreinfo="none">registerType(name, mime_types)</literal>, which adds new types
      to mapping objects used by <literal moreinfo="none">respondWith</literal>. The end
      result is ultimate flexibility for developers, with an easy interface
      for handling different types of requests. <filename moreinfo="none">main.js</filename>
      uses a JavaScript port of <emphasis>Mimeparse</emphasis>, an open source
      reference implementation, to provide this service.<indexterm id="I_indexterm4_d1e4800" significance="normal"><primary>Mimeparse, JavaScript port of</primary></indexterm><indexterm id="I_indexterm4_d1e4803" class="endofrange" startref="ch08_showfuncquery" significance="normal"/></para></sect2></sect1><sect1 id="I_sect14_d1e4804"><title>Etags</title><para>We’ve mentioned that show function requests are side effect–free and
    cacheable, but we haven’t discussed the mechanism used to accomplish this.
    <emphasis>Etags</emphasis> are a standard HTTP mechanism for indicating
    whether a cached copy of an HTTP response is still current. Essentially,
    when the client makes its first request to a resource, the response is
    accompanied by an Etag, which is an opaque string token unique to the
    version of the resource requested. The second time the client makes a
    request against the same resource, it sends along the original Etag with
    the request. If the server determines that the Etag still matches the
    resource, it can avoid sending the full response, instead <phrase role="keep-together">replying</phrase> with a message that essentially
    says, “You have the latest version already.”<indexterm id="I_indexterm4_d1e4815" significance="normal"><primary>caching</primary><secondary>show function requests</secondary></indexterm><indexterm id="I_indexterm4_d1e4820" significance="normal"><primary>show functions</primary><secondary>Etags and</secondary></indexterm><indexterm id="I_indexterm4_d1e4825" significance="normal"><primary>Etags</primary></indexterm></para><para>When implemented properly, the use of Etags can cut down
    significantly on server load. CouchDB provides an Etag header, so that by
    using an HTTP proxy cache like Squid, you’ll instantly remove load from
    CouchDB.</para></sect1><sect1 id="I_sect14_d1e4830"><title>Functions and Templates</title><para>CouchDB’s process runner looks only at the functions stored under
    <literal moreinfo="none">show</literal>, but we’ll <phrase role="keep-together">want to
    keep</phrase> the template HTML separate from the content negotiation
    logic. The <literal role="keep-together " moreinfo="none">couchapp</literal> script
    handles this for us, using the <literal moreinfo="none">!code</literal> and
    <literal moreinfo="none">!json</literal> handlers.<indexterm id="I_indexterm4_d1e4851" significance="normal"><primary>functions</primary><secondary>templates and</secondary></indexterm><indexterm class="startofrange" id="ch08_templatesfunc" significance="normal"><primary>templates</primary><secondary>functions and</secondary></indexterm><indexterm id="I_indexterm4_d1e4861" significance="normal"><primary>show functions</primary><secondary>templates and</secondary></indexterm></para><para>Let’s follow the show function logic through the files that Sofa
    splits it into. Here’s Sofa’s <literal moreinfo="none">edit</literal> show
    function:</para><screen format="linespecific">function(doc, req) {
  // !json templates.edit
  // !json blog
  // !code vendor/couchapp/path.js
  // !code vendor/couchapp/template.js

  // we only show html
  return template(templates.edit, {
    doc : doc,
    docid : toJSON((doc &amp;&amp; doc._id) || null),
    blog : blog,
    assets : assetPath(),
    index : listPath('index','recent-posts',{descending:true,limit:8})
  });
}</screen><para>This should look pretty straightforward. First, we have the
    function’s <emphasis>head</emphasis>, or <emphasis>signature</emphasis>,
    that tells us we are dealing with a function that takes two arguments:
    <literal moreinfo="none">doc</literal> and <literal moreinfo="none">req</literal>.<indexterm id="I_indexterm4_d1e4887" significance="normal"><primary>signature or head (function)</primary></indexterm></para><para>The next four lines are comments, as far as JavaScript is concerned.
    But these are special documents. The CouchApp upload script knows how to
    read these special comments on top of the show function. They include
    <emphasis>macros</emphasis>; a macro starts with a bang
    (<literal moreinfo="none">!</literal>) and a name. Currently, CouchApp supports the two
    macros <literal moreinfo="none">!json</literal> and <literal moreinfo="none">!code</literal>.<indexterm id="I_indexterm4_d1e4904" significance="normal"><primary>! (bang), beginning macros</primary></indexterm><indexterm id="I_indexterm4_d1e4907" significance="normal"><primary>macros</primary></indexterm></para><sect2><title>The !json Macro</title><para>The <literal moreinfo="none">!json</literal> macro takes one argument: the path to
      a file in the CouchApp directory hierarchy in the <emphasis>dot
      notation</emphasis>. Instead of a slash (<literal moreinfo="none">/</literal>) or
      backslash (<literal moreinfo="none">\</literal>), you use a dot (<literal moreinfo="none">.</literal>).
      The <literal moreinfo="none">!json</literal> macro then reads the contents of the file
      and puts them into a variable that has the same name as the file’s path
      in dot notation.<indexterm id="I_indexterm4_d1e4934" significance="normal"><primary>macros</primary><secondary>!json</secondary></indexterm><indexterm id="I_indexterm4_d1e4939" significance="normal"><primary>directory hierarchy</primary></indexterm><indexterm id="I_indexterm4_d1e4942" significance="normal"><primary>dot (.) notation</primary></indexterm><indexterm id="I_indexterm4_d1e4945" significance="normal"><primary>. (dot) notation</primary></indexterm><indexterm id="I_indexterm4_d1e4948" significance="normal"><primary>show functions</primary><secondary>templates and</secondary><tertiary>!json macro</tertiary></indexterm><indexterm id="I_indexterm4_d1e4955" significance="normal"><primary sortas="json macro">!json macro</primary></indexterm></para><?dbfo-need height=”1in”
?><para>For example, if you use the macro like this:</para><screen format="linespecific">  // !json template.edit</screen><para>CouchDB will read the file <filename moreinfo="none">template/edit.*</filename>
      and place its contents into a variable:</para><screen format="linespecific">  var template.edit = "contents of edit.*"</screen><para>When specifying the path, you omit the file’s extension. That way
      you can read <filename moreinfo="none">.json</filename>, <filename moreinfo="none">.js</filename>, or
      <filename moreinfo="none">.html</filename> files, or any other files into variables in
      your functions. Because the macro matches files with any extensions, you
      can’t have two files with the same name but different extensions.</para><para>In addition, you can specify a directory and CouchApp will load
      all the files in this directory and any subdirectory. So this:</para><screen format="linespecific">  // !json template</screen><para>creates:</para><screen format="linespecific">  var template.edit = "contents of edit.*"
  var teplate.post = "contents of post.*"</screen><para>Note that the macro also takes care of creating the top-level
      <literal moreinfo="none">template</literal> variable. We just omitted that here for
      brevity. The <literal moreinfo="none">!json</literal> macro will generate only valid
      JavaScript.</para></sect2><sect2><title>The !code Macro</title><para>The <literal moreinfo="none">!code</literal> macro is similar to the
      <literal moreinfo="none">!json</literal> macro, but it serves a slightly different
      purpose. Instead of making the contents of one or more files available
      as variables in your functions, it replaces itself with the contents of
      the file referenced in the argument to the macro.<indexterm id="I_indexterm4_d1e5009" significance="normal"><primary>macros</primary><secondary>!code</secondary></indexterm><indexterm id="I_indexterm4_d1e5014" significance="normal"><primary>show functions</primary><secondary>templates and</secondary><tertiary>!code macro</tertiary></indexterm><indexterm id="I_indexterm4_d1e5021" significance="normal"><primary sortas="code macro">!code macro</primary></indexterm></para><para>This is useful for sharing library functions between CouchDB
      functions (map/reduce/show/list/validate) without having to maintain
      their source code in multiple places.</para><para>Our example shows this line:</para><screen format="linespecific">  // !code vendor/couchapp/path.js</screen><para>If you look at the CouchApp sources, there is a file in
      <filename moreinfo="none">vendor/couchapp/path.js</filename> that includes a bunch of
      useful function related to the URL path of a request. In the example
      just shown, CouchApp will replace the line with the contents of
      <filename moreinfo="none">path.js</filename>, making the functions locally available to
      the show function.</para><para>The <literal moreinfo="none">!code</literal> macro can load only a single file at
      a time.<indexterm id="I_indexterm4_d1e5043" class="endofrange" startref="ch08_templatesfunc" significance="normal"/></para></sect2></sect1><sect1 id="I_sect14_d1e5045"><title>Learning Shows</title><para>Before we dig into the full code that will render the post permalink
    pages, let’s look at some <emphasis>Hello World</emphasis> form examples.
    The first one shows just the function arguments and the simplest possible
    return value. See <xref linkend="figure_8-1"/>.<indexterm id="I_indexterm4_d1e5055" significance="normal"><primary>show functions</primary><secondary>basic form function</secondary></indexterm></para><figure float="none" id="figure_8-1"><title>Basic form function</title><mediaobject id="I_mediaobject4_d1e5063"><imageobject role="print"><imagedata fileref="figs/print/codb_0801.pdf" format="PDF" scale="80"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0801.png" format="PNG" scale="80"/></imageobject></mediaobject></figure><para>A <emphasis>show function</emphasis> is a JavaScript function that
    converts a document and some details about the HTTP request into an HTTP
    response. Typically it will be used to construct HTML, but it is also
    capable of returning Atom feeds, images, or even just filtered JSON. The
    document argument is just like the documents passed to map
    functions.</para></sect1><sect1 id="I_sect14_d1e5073"><title>Using Templates</title><para>The only thing missing from the show function development experience
    is the ability to render HTML without ruining your eyes looking at a whole
    lot of string manipulation, among other unpleasantries. Most programming
    environments solve this problem with templates; for example, documents
    that look like HTML but have portions of their content filled out
    dynamically.<indexterm id="I_indexterm4_d1e5078" significance="normal"><primary>templates</primary><secondary>rendering HTML</secondary></indexterm><indexterm id="I_indexterm4_d1e5083" significance="normal"><primary>HTML</primary><secondary>rendering in show function results</secondary></indexterm><indexterm id="I_indexterm4_d1e5088" significance="normal"><primary>show functions</primary><secondary>using templates</secondary></indexterm></para><para>Dynamically combining template strings and data in JavaScript is a
    solved problem. However, it hasn’t caught on, partly because JavaScript
    doesn’t have very good support for multi-line “heredoc” strings. After
    all, once you get through escaping quotes and leaving out newlines, it’s
    not much fun to edit HTML templates inlined into JavaScript code. We’d
    much rather keep our templates in separate files, where we can avoid all
    the escaping work, and they can be syntax-highlighted by our
    editor.<indexterm id="I_indexterm4_d1e5095" significance="normal"><primary>JavaScript</primary><secondary>using templates with</secondary></indexterm></para><para>The <literal moreinfo="none">couchapp</literal> script has a couple of helpers to
    make working with templates and library code stored in design documents
    less painful. In the function shown in <xref linkend="figure_8-2"/>, we
    use them to load a blog post template, as well as the JavaScript function
    responsible for rendering it.</para><figure float="none" id="figure_8-2"><title>The blog post template</title><mediaobject id="I_mediaobject4_d1e5110"><imageobject role="print"><imagedata fileref="figs/print/codb_0802.pdf" format="PDF" scale="90"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_0802.png" format="PNG" scale="90"/></imageobject></mediaobject></figure><para>As you can see, we take the opportunity in the function to strip
    JavaScript tags from the form post. That regular expression is not secure,
    and the blogging application is meant to be written to only by its owners,
    so we should probably drop the regular expression and simplify the
    function to avoid transforming the document, instead passing it directly
    to the template. Or we should port a known-good sanitization <phrase role="keep-together">routine</phrase> from another language and provide it
    in the templates library.</para></sect1><sect1 id="I_sect14_d1e5120"><title>Writing Templates</title><para>Working with templates, instead of trying to cram all the
    presentation into one file, makes editing forms a little more relaxing.
    The templates are stored in their own file, so you don’t have to worry
    about JavaScript or JSON encoding, and your text editor can highlight the
    template’s HTML syntax. CouchDB’s JavaScript query server includes the E4X
    extensions for JavaScript, which can be helpful for XML templates but do
    not work well for HTML. We’ll explore E4X templates in <xref linkend="viewinglistsofblogposts"/> when we cover forms for views, which
    makes providing an Atom feed of view results easy and memory
    efficient.<indexterm id="I_indexterm4_d1e5127" significance="normal"><primary>show functions</primary><secondary>writing templates to use with</secondary></indexterm><indexterm id="I_indexterm4_d1e5132" significance="normal"><primary>HTML</primary><secondary>writing templates for HTML pages</secondary></indexterm><indexterm id="I_indexterm4_d1e5137" significance="normal"><primary>blog post template</primary></indexterm><indexterm id="I_indexterm4_d1e5140" significance="normal"><primary>templates</primary><secondary>writing</secondary></indexterm></para><para>Trust us when we say that looking at this HTML page is much more
    relaxing than trying to understand what a raw JavaScript one is trying to
    do. The template library we’re using in the example blog is by John Resig
    and was chosen for simplicity. It could easily be replaced by one of many
    other options, such as the Django template language, available in
    JavaScript.</para><para>This is a good time to note that CouchDB’s architecture is designed
    to make it simple to swap out languages for the query servers. With a
    query server written in Lisp, Python, or Ruby (or any language that
    supports JSON and <emphasis>stdio</emphasis>), you could have an even
    wider variety of templating options. However, the CouchDB team recommends
    sticking with JavaScript as it provides the highest level of support and
    interoperability, though other options are available.<indexterm id="I_indexterm4_d1e5152" class="endofrange" startref="ch08_showfunc" significance="normal"/></para></sect1></chapter><chapter id="listfunctions"><title>Transforming Views with <phrase role="keep-together">List
  Functions</phrase></title><para>Just as show functions convert documents to arbitrary output formats,
  CouchDB <emphasis>list functions</emphasis> allow you to render the output
  of view queries in any format. The powerful iterator API allows for
  flexibility to filter and aggregate rows on the fly, as well as output raw
  transformations for an easy way to make Atom feeds, HTML lists, CSV files,
  config files, or even just modified JSON.<indexterm id="I_indexterm5_d1e5163" significance="normal"><primary>views</primary><secondary>transforming with list functions</secondary><see>list functions</see></indexterm><indexterm class="startofrange" id="ch09_list" significance="normal"><primary>list functions</primary></indexterm></para><para>List functions are stored under the <literal moreinfo="none">lists</literal> field of
  a design document. Here’s an example design document that contains two list
  functions:<indexterm id="I_indexterm5_d1e5178" significance="normal"><primary>design documents</primary><secondary>list functions in</secondary></indexterm></para><programlisting id="I_programlisting5_d1e5183" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "_id" : "_design/foo",
  "_rev" : "1-67at7bg",
  "lists" : {
    "bar" : "function(head, req) { var row; while (row = getRow()) { ... } }",
    "zoom" : "function() { return 'zoom!' }",
  }
}</programlisting><sect1 id="arguments_to_the_list_function"><title>Arguments to the List Function</title><para>The function is called with two arguments, which can sometimes be
    ignored, as the row data itself is loaded during function execution. The
    first argument, <literal moreinfo="none">head</literal>, contains information about the
    view. Here’s what you might see looking at a JSON representation of
    <literal moreinfo="none">head</literal>:<indexterm id="I_indexterm5_d1e5196" significance="normal"><primary>list functions</primary><secondary>arguments</secondary></indexterm></para><programlisting id="I_programlisting5_d1e5201" language="javascript" linenumbering="unnumbered" format="linespecific">{total_rows:10, offset:0}</programlisting><para>The request itself is a much richer data structure. This is the same
    request object that is available to show, update, and filter functions.
    We’ll go through it in detail here as a reference. Here’s the example
    <literal moreinfo="none">req</literal> object:<indexterm id="I_indexterm5_d1e5208" significance="normal"><primary>requests</primary><secondary>req object (example)</secondary></indexterm></para><?dbfo-need height=”1in”
?><programlisting id="I_programlisting5_d1e5214" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "info": {
    "db_name": "test_suite_db","doc_count": 11,"doc_del_count": 0,
    "update_seq": 11,"purge_seq": 0,"compact_running": false,"disk_size": 4930,
    "instance_start_time": "1250046852578425","disk_format_version": 4},</programlisting><para>The database information, as available in an information request
    against a database’s URL, is included in the request parameters. This
    allows you to stamp rendered rows with an update sequence and know the
    database you are working with.<indexterm id="I_indexterm5_d1e5218" significance="normal"><primary>HTTP requests</primary><secondary>GET request</secondary></indexterm><indexterm id="I_indexterm5_d1e5223" significance="normal"><primary>requests</primary><seealso>HTTP requests</seealso></indexterm></para><programlisting id="I_programlisting5_d1e5228" language="javascript" linenumbering="unnumbered" format="linespecific">  "method": "GET",
  "path": ["test_suite_db","_design","lists","_list","basicJSON","basicView"],</programlisting><para>The HTTP method and the path in the client from the client request
    are useful, especially for rendering links to other resources within the
    application.</para><programlisting id="I_programlisting5_d1e5232" language="javascript" linenumbering="unnumbered" format="linespecific">  "query": {"foo":"bar"},</programlisting><para>If there are parameters in the query string (in this case
    corresponding to <literal moreinfo="none">?foo=bar</literal>), they will be parsed and
    available as a JSON object at <literal moreinfo="none">req.query</literal>.</para><programlisting id="I_programlisting5_d1e5243" language="javascript" linenumbering="unnumbered" format="linespecific">  "headers":
    {"Accept": "text/html,application/xhtml+xml ,application/xml;q=0.9,*/*;q=0.8",
    "Accept-Charset": "ISO-8859-1,utf-8;q=0.7,*;q=0.7","Accept-Encoding": 
    "gzip,deflate","Accept-Language": "en-us,en;q=0.5","Connection": "keep-alive",
    "Cookie": "_x=95252s.sd25; AuthSession=","Host": "127.0.0.1:5984",
    "Keep-Alive": "300",
    "Referer": "http://127.0.0.1:5984/_utils/couch_tests.html?script/couch_tests.js",
    "User-Agent": "Mozilla/5.0 Gecko/20090729 Firefox/3.5.2"},
  "cookie": {"_x": "95252s.sd25","AuthSession": ""},</programlisting><para>Headers give list and show functions the ability to provide the
    Content-Type response that the client prefers, as well as other nifty
    things like cookies. Note that cookies are also parsed into a JSON
    representation. Thanks, MochiWeb!<indexterm id="I_indexterm5_d1e5247" significance="normal"><primary>headers</primary><secondary>use with list and show functions</secondary></indexterm><indexterm id="I_indexterm5_d1e5252" significance="normal"><primary>cookies, JSON representation of</primary></indexterm></para><programlisting id="I_programlisting5_d1e5255" language="javascript" linenumbering="unnumbered" format="linespecific">  "body": "undefined",
  "form": {},</programlisting><para>In the case where the method is <literal moreinfo="none">POST</literal>, the request
    body (and a form-decoded JSON representation of it, if applicable) are
    available as well.</para><programlisting id="I_programlisting5_d1e5262" language="javascript" linenumbering="unnumbered" format="linespecific">  "userCtx": {"db": "test_suite_db","name": null,"roles": ["_admin"]}
}</programlisting><para>Finally, the <literal moreinfo="none">userCtx</literal> is the same as that sent to
    the validation function. It provides access to the database the user is
    authenticated against, the user’s name, and the roles they’ve been
    granted. In the previous example, you see an anonymous user working with a
    CouchDB node that is in “admin party” mode. Unless an admin is specified,
    everyone is an admin.<indexterm id="I_indexterm5_d1e5269" significance="normal"><primary>userCtx (user context) object</primary></indexterm></para><para>That’s enough about the arguments to list functions. Now it’s time
    to look at the <phrase role="keep-together">mechanics</phrase> of the
    function itself.</para></sect1><sect1 id="an_example_list_function"><title>An Example List Function</title><para>Let’s put this knowledge to use. In the chapter introduction, we
    mentioned using lists to generate config files. One fun thing about this
    is that if you keep your configuration information in CouchDB and generate
    it with lists, you don’t have to worry about being able to regenerate it
    again, because you know the config will be generated by a pure function
    from your database and not other sources of information. This level of
    isolation will ensure that your config files can be generated correctly as
    long as CouchDB is running. Because you can’t fetch data from other system
    services, files, or network sources, you can’t accidentally write a config
    file generator that fails due to external factors.<indexterm class="startofrange" id="ch09_configfiles" significance="normal"><primary>config files, generating using list functions</primary></indexterm><indexterm class="startofrange" id="ch09_listfuncexample" significance="normal"><primary>list functions</primary><secondary>example, generating config files</secondary></indexterm></para><note><para>J. Chris got excited about the idea of using list functions to
      generate config files for the sort of services people usually configure
      using CouchDB, specifically via Chef, an Apache-licensed infrastructure
      automation tool. The key feature of infrastructure automation is that
      deployment scripts are idempotent—that is, running your scripts multiple
      times will have the same intended effect as running them once, something
      that becomes critical when a script fails halfway through. This
      encourages crash-only design, where your scripts can bomb out multiple
      times but your data remains consistent, because it takes the guesswork
      out of provisioning and updating servers in the case of previous
      failures.</para><para>Like map, reduce, and show functions, lists are pure functions,
      from a view query and an HTTP request to an output format. They can’t
      make queries against remote services or otherwise access outside data,
      so you know they are repeatable. Using a list function to generate an
      HTTP server configuration file ensures that the configuration is
      generated <phrase role="keep-together">repeatably</phrase>, based on
      only the state of the database.</para></note><para>Imagine you are running a shared hosting platform, with one
    name-based virtual host per user. You’ll need a config file that starts
    out with some node configuration (which modules to use, etc.) and is
    followed by one config section per user, setting things like the user’s
    HTTP directory, subdomain, forwarded ports, etc.</para><programlisting id="I_programlisting5_d1e5300" language="javascript" linenumbering="unnumbered" format="linespecific">function(head, req) {
  // helper function definitions would be here...
  var row, userConf, configHeader, configFoot;
  configHeader = renderTopOfApacheConf(head, req.query.hostname);
  send(configHeader);</programlisting><para>In the first block of the function, we’re rendering the top of the
    config file using the function <literal moreinfo="none">renderTopOfApacheConf(head,
    req.query.hostname)</literal>. This may include information that’s posted
    into the function, like the internal name of the server that is being
    configured or the root directory in which user HTML files are organized.
    We won’t show the function body, but you can imagine that it would return
    a long <phrase role="keep-together">multi-line</phrase> string that
    handles all the global configuration for your server and sets the stage
    for the per-user configuration that will be based on view data.</para><para>The call to <literal moreinfo="none">send(configHeader)</literal> is the heart of
    your ability to render text using list functions. Put simply, it just
    sends an HTTP chunk to the client, with the content of the strings pasted
    to it. There is some batching behind the scenes, as CouchDB speaks with
    the JavaScript runner with a synchronous protocol, but from the
    perspective of a programmer, <literal moreinfo="none">send()</literal> is how HTTP chunks
    are born.</para><para>Now that we’ve rendered and sent the file’s head, it’s time to start
    rendering the list itself. Each list item will be the result of converting
    a view row to a virtual host’s configuration element. The first thing we
    do is call <literal moreinfo="none">getRow()</literal> to get a row of the view.</para><programlisting id="I_programlisting5_d1e5323" language="javascript" linenumbering="unnumbered" format="linespecific">  while (row = getRow()) {
    var userConf = renderUserConf(row);
    send(userConf)
  }</programlisting><para>The <literal moreinfo="none">while</literal> loop used here will continue to run
    until <literal moreinfo="none">getRow()</literal> returns null, which is how CouchDB
    signals to the list function that all valid rows (based on the view query
    parameters) have been exhausted. Before we get ahead of ourselves, let’s
    check out what happens when we do get a row.</para><para>In this case, we simply render a string based on the row and send it
    to the client. Once all rows have been rendered, the loop is complete. Now
    is a good time to note that the function has the option to return early.
    Perhaps it is programmed to stop iterating when it sees a particular
    user’s document or is based on a tally it’s been keeping of some resource
    allocated in the configuration. In those cases, the loop can end early
    with a <literal moreinfo="none">break</literal> statement or other method. There’s no
    requirement for the list function to render every row that is sent to
    it.</para><programlisting id="I_programlisting5_d1e5339" language="javascript" linenumbering="unnumbered" format="linespecific">  configFoot = renderConfTail();
  return configFoot;
}</programlisting><para>Finally, we close out the configuration file and return the final
    string value to be sent as the last HTTP chunk. The last action of a list
    function is always to return a string, which will be sent as the final
    HTTP chunk to the client.</para><para>To use our config file generation function in practice, we might run
    a command-line script that looks like:</para><screen format="linespecific">curl http://localhost:5984/config_db/_design/files/_list/apache/users?hostname=foobar 
&gt; apache.conf</screen><para>This will render our Apache config based on data in the user’s view
    and save it to a file. What a simple way to build a reliable configuration
    generator!<indexterm id="I_indexterm5_d1e5349" class="endofrange" startref="ch09_listfuncexample" significance="normal"/><indexterm id="I_indexterm5_d1e5350" class="endofrange" startref="ch09_configfiles" significance="normal"/></para></sect1><sect1 id="list_theory"><title>List Theory</title><para>Now that we’ve seen a complete list function, it’s worth mentioning
    some of the helpful properties they have.<indexterm id="I_indexterm5_d1e5356" significance="normal"><primary>list functions</primary><secondary>helpful properties</secondary></indexterm></para><para>The most obvious thing is the iterator-style API. Because each row
    is loaded independently by calling <literal moreinfo="none">getRow()</literal>, it’s easy
    not to leak memory. The list function API is capable of rendering lists of
    arbitrary length without error, when used correctly.</para><para>On the other hand, this API gives you the flexibility to bundle a
    few rows in a single chunk of output, so if you had a view of, say, user
    accounts, followed by subdomains owned by that account, you could use a
    slightly more complex loop to build up some state in the list function for
    rendering more complex chunks. Let’s look at an alternate loop
    section:</para><programlisting id="I_programlisting5_d1e5368" language="javascript" linenumbering="unnumbered" format="linespecific">var subdomainOwnerRow, subdomainRows = [];
while (row = getRow()) {</programlisting><para>We’ve entered a loop that will continue until we have reached the
    <literal moreinfo="none">endkey</literal> of the view. The view is structured so that a
    user profile row is emitted, followed by all of that user’s subdomains.
    We’ll use the profile data and the subdomain information to template the
    configuration for each individual user. This means we can’t render any
    subdomain configuration until we know we’ve received all the rows for the
    current user.</para><programlisting id="I_programlisting5_d1e5375" language="javascript" linenumbering="unnumbered" format="linespecific">  if (!subdomainOwnerRow) {
    subdomainOwnerRow = row;</programlisting><para>This case is true only for the first user. We’re merely setting up
    the initial conditions.</para><programlisting id="I_programlisting5_d1e5379" language="javascript" linenumbering="unnumbered" format="linespecific">  } else if (row.value.user != subdomainOwnerRow.value.user) {</programlisting><para>This is the end case. It will be called only after all the subdomain
    rows for the current user have been exhausted. It is triggered by a row
    with a mismatched user, indicating that we have all the subdomain
    rows.</para><programlisting id="I_programlisting5_d1e5383" language="javascript" linenumbering="unnumbered" format="linespecific">    send(renderUserConf(subdomainOwnerRow, subdomainRows));</programlisting><para>We know we are ready to render everything for the current user, so
    we pass the profile row and the subdomain rows to a render function (which
    nicely hides all the gnarly nginx config details from our fair reader).
    The result is sent to the HTTP client, which writes it to the config
    file.</para><programlisting id="I_programlisting5_d1e5388" language="javascript" linenumbering="unnumbered" format="linespecific">    subdomainRows = [];
    subdomainOwnerRow = row;</programlisting><para>We’ve finished with that user, so let’s clear the rows and start
    working on the next user.</para><programlisting id="I_programlisting5_d1e5392" language="javascript" linenumbering="unnumbered" format="linespecific">  } else {
    subdomainRows.push(row);</programlisting><para>Ahh, back to work, collecting rows.</para><programlisting id="I_programlisting5_d1e5396" language="javascript" linenumbering="unnumbered" format="linespecific">  }
}
send(renderUserConf(subdomainOwnerRow, subdomainRows));</programlisting><para>This last bit is tricky—after the loop is finished (we’ve reached
    the end of the view query), we’ve still got to render the last user’s
    config. Wouldn’t want to forget that!</para><para>The gist of this loop section is that we collect rows that belong to
    a particular user until we see a row that belongs to another user, at
    which point we render output for the first user, clear our state, and
    start working with the new user. Techniques like this show how much
    flexibility is allowed by the list iterator API.</para><para>More uses along these lines include filtering rows that should be
    hidden from a particular result set, finding the top
    <emphasis>N</emphasis> grouped reduce values (e.g., to sort a tag cloud by
    popularity), and even writing custom reduce functions (as long as you
    don’t mind that reductions are not stored incrementally).</para></sect1><sect1 id="querying_lists"><title>Querying Lists</title><para>We haven’t looked in detail at the ways list functions are queried.
    Just like show functions, they are resources available on the design
    document. The basic path to a list function is as follows:<indexterm id="I_indexterm5_d1e5412" significance="normal"><primary>list functions</primary><secondary>querying</secondary></indexterm></para><screen format="linespecific">/db/_design/foo/_list/list-name/view-name</screen><para>Because the list name and the view name are both specified, this
    means it is possible to render a list against more than one view. For
    instance, you could have a list function that renders blog comments in the
    Atom XML format, and then run it against both a global view of recent
    comments as well as a view of recent comments by blog post. This would
    allow you to use the same list function to provide an Atom feed for
    comments across an entire site, as well as individual comment feeds for
    each post.</para><para>After the path to the list comes the view query parameter. Just like
    a regular view, calling a list function without any query parameters
    results in a list that reflects every row in the view. Most of the time
    you’ll want to call it with query parameters to limit the returned
    data.</para><para>You’re already familiar with the view query options from <xref linkend="findingyourdatawithviews"/>. The same query options apply to the
    <literal moreinfo="none">_list</literal> query. Let’s look at URLs side by side; see <xref linkend="a_json_view_query"/>.<indexterm id="I_indexterm5_d1e5432" significance="normal"><primary>JSON (JavaScript Object Notation)</primary><secondary>view query</secondary></indexterm></para><example id="a_json_view_query"><title>A JSON view query</title><screen format="linespecific">GET /db/_design/sofa/_view/recent-posts?descending=true&amp;limit=10</screen></example><para>This view query is just asking for the 10 most recent blog posts. Of
    course, this query could include parameters like
    <literal moreinfo="none">startkey</literal> or <literal moreinfo="none">skip</literal>—we’re leaving them
    out for simplicity. To run the same query through a list function, we
    access it via the list resource, as shown in <xref linkend="the_html_list_query"/>.<indexterm id="I_indexterm5_d1e5452" significance="normal"><primary>HTML</primary><secondary>list query</secondary></indexterm></para><example id="the_html_list_query"><title>The HTML list query</title><screen format="linespecific">GET /db/_design/sofa/_list/index/recent-posts?descending=true&amp;limit=10</screen></example><para>The <literal moreinfo="none">index</literal> list here is a function from JSON to
    HTML. Just like the preceding view query, additional query parameters can
    be applied to paginate through the list. As we’ll see in <xref linkend="part3"/>, once you have a working list, adding pagination is
    trivial. See <xref linkend="the_atom_list_query"/>.<indexterm id="I_indexterm5_d1e5471" significance="normal"><primary>Atom list query</primary></indexterm></para><example id="the_atom_list_query"><title>The Atom list query</title><screen format="linespecific">GET /db/_design/sofa/_list/index/recent-posts?descending=true&amp;limit=10&amp;format=atom</screen></example><para>The list function can also look at the query parameters and do
    things like switch that output to render based on parameters. You can even
    do things like pass the username into the list using a query parameter
    (but it’s not recommended, as you’ll ruin cache efficiency).</para></sect1><sect1 id="lists_comma_etags_comma_and_caching"><title>Lists, Etags, and Caching</title><para>Just like show functions and view queries, lists are sent with
    proper HTTP Etags, which makes them cacheable by intermediate proxies.
    This means that if your server is starting to bog down in list-rendering
    code, it should be possible to relieve load by using a caching reverse
    proxy like Squid. We won’t go into the details of Etags and caching here,
    as they were covered in <xref linkend="showfunctions"/>.<indexterm id="I_indexterm5_d1e5489" class="endofrange" startref="ch09_list" significance="normal"/></para></sect1></chapter></part><part id="part3"><title>Example Application</title><chapter id="standaloneapplications"><title>Standalone Applications</title><para>CouchDB is useful for many areas of an application. Because of its
  incremental <phrase role="keep-together">MapReduce</phrase> and replication
  characteristics, it is especially well suited to online interactive document
  and data management tasks. These are the sort of workloads experienced by
  the majority of web applications. This coupled with CouchDB’s HTTP interface
  make it a natural fit for the web.</para><para>In this part, we’ll tour a document-oriented web application—a basic
  blog implementation. As a lowest common denominator, we’ll be using plain
  old HTML and JavaScript. The lessons learned should apply to
  Django/Rails/Java-style middleware applications and even to intensive
  MapReduce data mining tasks. CouchDB’s API is the same, regardless of
  whether you’re running a small installation or an industrial cluster.</para><para>There is no right answer about which application development framework
  you should use with CouchDB. We’ve seen successful applications in almost
  every commonly used language and framework. For this example application,
  we’ll use a two-layer architecture: CouchDB as the data layer and the
  browser for the user interface. We think this is a viable model for many
  document-oriented applications, and it makes a great way to teach CouchDB,
  because we can easily assume that all of you have a browser at hand without
  having to ensure that you’re familiar with a particular server-side
  scripting language.</para><sect1 id="I_sect11_d1e5505"><title>Use the Correct Version</title><para>This part is interactive, so be prepared to follow along with your
    laptop and a running CouchDB database. We’ve made the full example
    application and all of the source code examples available online, so
    you’ll start by downloading the current version of the example application
    and installing it on your CouchDB instance.<indexterm id="I_indexterm1_d1e5510" significance="normal"><primary>standalone applications</primary><secondary>using correct version of CouchDB</secondary></indexterm><indexterm id="I_indexterm1_d1e5515" significance="normal"><primary>CouchDB</primary><secondary>versions</secondary></indexterm><indexterm id="I_indexterm1_d1e5520" significance="normal"><primary>versions of CouchDB</primary></indexterm></para><para>A challenge of writing this book and preparing it for production is
    that CouchDB is evolving at a rapid pace. The basics haven’t changed in a
    long time, and probably won’t change much in the future, but things around
    the edges are moving forward rapidly for CouchDB’s 1.0 release.</para><para>This book is going to press as CouchDB version 0.10.0 is about to be
    released. Most of the code was written against 0.9.1 and the development
    trunk that is becoming version 0.10.0. In this part we’ll work with two
    other software packages: CouchApp, which is a set of tools for editing and
    sharing CouchDB application code; and Sofa, the example blog
    itself.</para><note><para>See <ulink url="http://couchapp.org">http://couchapp.org</ulink>
      for the latest information about the CouchApp model.</para></note><para>As a reader, it is your responsibility to use the correct versions
    of these packages. For CouchApp, the correct version is always the latest.
    The correct version of Sofa depends on which version of CouchDB you are
    using. To see which version of CouchDB you are using, run the following
    command:</para><screen format="linespecific">curl http://127.0.0.1:5984</screen><para>You should see something like one of these three examples:</para><programlisting id="I_programlisting1_d1e5539" language="javascript" linenumbering="unnumbered" format="linespecific">{"couchdb":"Welcome","version":"0.9.1"}

{"couchdb":"Welcome","version":"0.10.0"}

{"couchdb":"Welcome","version":"0.11.0a858744"}</programlisting><para>These three correspond to versions 0.9.1, 0.10.0, and trunk. If the
    version of CouchDB you have installed is 0.9.1 or earlier, you should
    upgrade to at least 0.10.0, as Sofa makes use of features not present
    until 0.10.0. There is an older version of Sofa that will work, but this
    book covers features and APIs that are part of the 0.10.0 release of
    CouchDB. It’s conceivable that there will be a 0.9.2, 0.10.1 and even a
    0.10.2 release by the time you read this. Please use the latest release of
    whichever version you prefer.<indexterm id="I_indexterm1_d1e5543" significance="normal"><primary>trunk</primary></indexterm></para><para><emphasis>Trunk</emphasis> refers to the latest development version
    of CouchDB available in the Apache Subversion repository. We recommend
    that you use a released version of CouchDB, but as developers, we often
    use trunk. Sofa’s master branch will tend to work on trunk, so if you want
    to stay on the cutting edge, that’s the way to do it.</para></sect1><sect1 id="I_sect11_d1e5550"><title>Portable JavaScript</title><para>If you’re not familiar with JavaScript, we hope the source examples
    are given with enough context and explanation so that you can keep up. If
    you are familiar with JavaScript, you’re probably already excited that
    CouchDB supports view and template rendering JavaScript
    functions.<indexterm id="I_indexterm1_d1e5555" significance="normal"><primary>standalone applications</primary><secondary>portable JavaScript</secondary></indexterm><indexterm id="I_indexterm1_d1e5560" significance="normal"><primary>JavaScript</primary><secondary>portable</secondary></indexterm></para><para>One of the advantages of building applications that can be hosted on
    any standard CouchDB installation is that they are portable via
    replication. This means your application, if you develop it to be served
    directly from CouchDB, gets offline mode “for free.” Local data makes a
    big difference for users in a number of ways we won’t get into here. We
    call applications that can be hosted from a standard CouchDB
    <emphasis>CouchApps</emphasis>.<indexterm id="I_indexterm1_d1e5570" significance="normal"><primary>CouchApps</primary></indexterm></para><para>CouchApps are a great vehicle for teaching CouchDB because we don’t
    need to worry about picking a language or framework; we’ll just work
    directly with CouchDB so that readers get a quick overview of a familiar
    application pattern. Once you’ve worked through the example app, you’ll
    have seen enough to know how to apply CouchDB to your problem domain. If
    you don’t know much about Ajax development, you’ll learn a little about
    jQuery as well, and we hope you find the experience relaxing.</para></sect1><sect1 id="I_sect11_d1e5575"><title>Applications Are Documents</title><para>Applications are stored as design documents (<xref linkend="figure_10-1"/>). You can replicate design documents just like
    everything else in CouchDB. Because design documents can be replicated,
    whole CouchApps are replicated. CouchApps can be updated via replication,
    but they are also easily “forked” by the users, who can alter the source
    code at will.<indexterm id="I_indexterm1_d1e5582" significance="normal"><primary>standalone applications</primary><secondary>design documents as applications</secondary></indexterm><indexterm id="I_indexterm1_d1e5587" significance="normal"><primary>design documents</primary><secondary>as applications</secondary></indexterm></para><figure float="none" id="figure_10-1"><title>CouchDB executes application code stored in design
      documents</title><mediaobject id="I_mediaobject1_d1e5595"><imageobject role="print"><imagedata fileref="figs/print/codb_1001.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1001.png" format="PNG"/></imageobject></mediaobject></figure><para>Because applications are just a special kind of document, they are
    easy to edit and share.</para><note><para>J. Chris says: Thinking of peer-based application replication
      takes me back to my first year of high school, when my friends and I
      would share little programs between the TI-85 graphing calculators we
      were required to own. Two calculators could be connected via a small
      cable and we’d share physics cheat sheets, Hangman, some multi-player
      text-based <phrase role="keep-together">adventures</phrase>, and, at the
      height of our powers, I believe there may have been a Doom clone
      running.</para><para>The TI-85 programs were in Basic, so everyone was always hacking
      each other’s hacks. Perhaps the most ridiculous program was a version of
      Spy Hunter that you controlled with your mind. The idea was that you
      could influence the pseudorandom number generator by concentrating hard
      enough, and thereby control the game. Didn’t work. Anyway, the point is
      that when you give people access to the source code, there’s no telling
      what might happen.</para></note><para>If people don’t like the aesthetics of your application, they can
    tweak the CSS. If people don’t like your interface choices, they can
    improve the HTML. If they want to modify the functionality, they can edit
    the JavaScript. Taken to the extreme, they may want to completely fork
    your application for their own purposes. When they show the modified
    version to their friends and coworkers, and hopefully you, there is a
    chance that more people may want to make improvements.</para><para>As the original developer, you have the control over your version
    and can accept or reject changes as you see fit. If someone messes around
    with the source code for a local application and breaks things beyond
    repair, they can replicate the original copy from your server, as
    illustrated in <xref linkend="figure_10-2"/>.</para><figure float="none" id="figure_10-2"><title>Replicating application changes to a group of friends</title><mediaobject id="I_mediaobject1_d1e5619"><imageobject role="print"><imagedata fileref="figs/print/codb_1002.pdf" format="PDF" scale="90"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1002.png" format="PNG" scale="90"/></imageobject></mediaobject></figure><para>Of course, this may not be your cup of tea. Don’t worry; you can be
    as restrictive as you like with CouchDB. You can restrict access to data
    however you wish, but beware of the opportunities you might be missing.
    There is a middle ground between open collaboration and restricted access
    controls.</para><para>Once you’ve finished the installation procedure, you’ll be able to
    see the full application code for Sofa, both in your text editor and as a
    design document in Futon.</para></sect1><sect1 id="I_sect11_d1e5628"><title>Standalone</title><para>What happens if you add an HTML file as a document attachment?
    Exactly the same thing. We can serve web pages directly with CouchDB. Of
    course, we might also need images, stylesheets, or scripts. No problem;
    just add these resources as document <phrase role="keep-together">attachments</phrase> and link to them using relative
    URIs.<indexterm id="I_indexterm1_d1e5636" significance="normal"><primary>attachments to documents</primary><secondary>using in standalone applications</secondary></indexterm></para><para>Let’s take a step back. What do we have so far? A way to serve HTML
    documents and other static files on the Web. That means we can build and
    serve traditional websites using CouchDB. Fantastic! But isn’t this a
    little like reinventing the wheel? Well, a very important difference is
    that we also have a document database sitting in the background. We can
    talk to this database using the JavaScript served up with our web pages.
    Now we’re really cooking with gas!</para><para>CouchDB’s features are a foundation for building standalone web
    applications backed by a powerful database. As a proof of concept, look no
    further than CouchDB’s built-in administrative interface. Futon is a fully
    functional database management application built using HTML, CSS, and
    JavaScript. Nothing else. CouchDB and web applications go hand in
    hand.</para></sect1><sect1 id="I_sect11_d1e5645"><title>In the Wild</title><para>There are plenty of examples of CouchApps in the wild. This section
    includes screenshots of just a few sites and applications that use a
    standalone CouchDB architecture.<indexterm id="I_indexterm1_d1e5650" significance="normal"><primary>calendar application</primary></indexterm><indexterm class="startofrange" id="ch10_standaloneappsex" significance="normal"><primary>standalone applications</primary><secondary>examples of CouchApps in use</secondary></indexterm></para><para>Damien Katz, inventor of CouchDB and writer of this book’s <xref linkend="foreword"/>, decided to see how long it would take to implement
    a shared calendar with real-time updates as events are changed on the
    server. It took about an afternoon, thanks to some amazing open source
    jQuery plug-ins. <ulink url="http://jchrisa.net/cal/_design/cal/index.html">The calendar demo is
    still running on J. Chris’s server</ulink>. See <xref linkend="figure_10-3"/>.<indexterm id="I_indexterm1_d1e5667" significance="normal"><primary>Ely Service website</primary></indexterm><indexterm id="I_indexterm1_d1e5670" significance="normal"><primary>Katz, Damien</primary></indexterm><indexterm id="I_indexterm1_d1e5673" significance="normal"><primary>awesome</primary><see>Katz, Damien</see></indexterm></para><figure float="none" id="figure_10-3"><title>Group calendar</title><mediaobject id="I_mediaobject1_d1e5681"><imageobject role="print"><imagedata fileref="figs/print/codb_1003.pdf" format="PDF" scale="80"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1003.png" format="PNG" scale="80"/></imageobject></mediaobject></figure><para>Jason Davies swapped out the backend of the <ulink url="http://www.elyservice.co.uk/">Ely Service website</ulink> with
    CouchDB, without changing anything visible to the user. The <phrase role="keep-together">technical</phrase> details are <ulink url="http://www.jasondavies.com/blog/2009/05/08/couchdb-on-wheels/">covered
    on his blog</ulink>. See <xref linkend="figure_10-4"/>.</para><figure float="none" id="figure_10-4"><title>Ely Service</title><mediaobject id="I_mediaobject1_d1e5702"><imageobject role="print"><imagedata fileref="figs/print/codb_1004.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1004.png" format="PNG"/></imageobject></mediaobject></figure><para>Jason also converted his mom’s ecommerce website, Bet Ha Bracha, to
    a CouchApp. It uses the <literal moreinfo="none">_update</literal> handler to hook into
    different transaction gateways. See <xref linkend="figure_10-5"/>.</para><para><ulink url="http://processingjs.org/">Processing JS</ulink> is a
    toolkit for building animated art that runs in the browser. <ulink url="http://github.com/hpoydar/processing-js-studio">Processing JS
    Studio</ulink> is a gallery for Processing JS sketches. See <xref linkend="figure_10-6"/>.<indexterm id="I_indexterm1_d1e5723" significance="normal"><primary>Processing JS Studio</primary></indexterm></para><figure float="none" id="figure_10-5"><title>Bet Ha Bracha</title><mediaobject id="I_mediaobject1_d1e5729"><imageobject role="print"><imagedata fileref="figs/print/codb_1005.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1005.png" format="PNG"/></imageobject></mediaobject></figure><figure float="none" id="figure_10-6"><title>Processing JS Studio</title><mediaobject id="I_mediaobject1_d1e5737"><imageobject role="print"><imagedata fileref="figs/print/codb_1006.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1006.png" format="PNG"/></imageobject></mediaobject></figure><?dbfo-need height=”1in”
?><para><ulink url="http://github.com/quirkey/swinger">Swinger</ulink> is a
    CouchApp for building and sharing presentations. It uses the <ulink url="http://www.quirkey.com/blog/2009/09/15/sammy-js-couchdb-and-the-new-web-architecture/">Sammy</ulink>
    JavaScript application framework. See <xref linkend="figure_10-7"/>.<indexterm id="I_indexterm1_d1e5753" significance="normal"><primary>Swinger application for building and sharing
        presentations</primary></indexterm></para><figure float="none" id="figure_10-7"><title>Swinger</title><mediaobject id="I_mediaobject1_d1e5759"><imageobject role="print"><imagedata fileref="figs/print/codb_1007.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1007.png" format="PNG"/></imageobject></mediaobject></figure><para><ulink url="http://nymphormation.org">Nymphormation</ulink> is a
    link sharing and tagging site by Benoît Chesneau. It uses CouchDB’s cookie
    authentication and also makes it possible to share links using
    replication. See <xref linkend="figure_10-8"/>.<indexterm id="I_indexterm1_d1e5770" significance="normal"><primary>Nymphormation link sharing and tagging site</primary></indexterm><indexterm id="I_indexterm1_d1e5773" significance="normal"><primary>link sharing and tagging site (Nymphormation)</primary></indexterm></para><para><ulink url="http://github.com/langalex/boom_amazing">Boom
    Amazing</ulink> is a CouchApp by Alexander Lang that allows you to zoom,
    rotate, and pan around an SVG file, record the different positions, and
    then replay those for a presentation or something else (from the Boom
    Amazing README). See <xref linkend="figure_10-9"/>.<indexterm id="I_indexterm1_d1e5782" significance="normal"><primary>Boom Amazing application</primary></indexterm><indexterm id="I_indexterm1_d1e5785" significance="normal"><primary>SVG files, application for</primary></indexterm></para><figure float="none" id="figure_10-8"><title>Nymphormation</title><mediaobject id="I_mediaobject1_d1e5791"><imageobject role="print"><imagedata fileref="figs/print/codb_1008.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1008.png" format="PNG"/></imageobject></mediaobject></figure><figure float="none" id="figure_10-9"><title>Boom Amazing</title><mediaobject id="I_mediaobject1_d1e5799"><imageobject role="print"><imagedata fileref="figs/print/codb_1009.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1009.png" format="PNG"/></imageobject></mediaobject></figure><para>The <ulink url="http://github.com/jchris/couchdb-twitter-client">CouchDB Twitter
    Client</ulink> was one of the first standalone CouchApps to be released.
    It’s documented in J. Chris’s blog post, <ulink url="http://jchrisa.net/drl/_design/sofa/_show/post/my_couch_or_yours__shareable_ap">“My
    Couch or Yours, Shareable Apps are the Future”</ulink>. The screenshot in
    <xref linkend="figure_10-10"/> shows the word cloud generated from a
    MapReduce view of CouchDB’s archived tweets. The cloud is normalized
    against the global view, so universally common words don’t dominate the
    chart.<indexterm id="I_indexterm1_d1e5814" significance="normal"><primary>Twitter client application</primary></indexterm></para><figure float="none" id="figure_10-10"><title>Twitter Client</title><mediaobject id="I_mediaobject1_d1e5820"><imageobject role="print"><imagedata fileref="figs/print/codb_1010.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1010.png" format="PNG"/></imageobject></mediaobject></figure><para><ulink url="http://github.com/jchris/toast">Toast</ulink> is a chat
    application that allows users to create channels and then invite others to
    real-time chat. It was initially a demo of the <literal moreinfo="none">_changes</literal>
    event loop, but it started to take off as a way to chat. See <xref linkend="figure_10-11"/>.<indexterm id="I_indexterm1_d1e5834" significance="normal"><primary>Toast (chat application)</primary></indexterm><indexterm id="I_indexterm1_d1e5837" significance="normal"><primary>chat application (Toast)</primary></indexterm></para><para>Sofa is the example application for this part, and it has been
    deployed by a few different authors around the web. The screenshot in
    <xref linkend="figure_10-12"/> is from Jan’s Tumblelog. To see Sofa in
    action, visit <ulink url="http://jchrisa.net">J. Chris’s site</ulink>,
    which has been running Sofa since late 2008.<indexterm id="I_indexterm1_d1e5847" class="endofrange" startref="ch10_standaloneappsex" significance="normal"/><indexterm id="I_indexterm1_d1e5848" significance="normal"><primary>Sofa</primary></indexterm></para><figure float="none" id="figure_10-11"><title>Toast</title><mediaobject id="I_mediaobject1_d1e5854"><imageobject role="print"><imagedata fileref="figs/print/codb_1011.pdf" format="PDF" scale="80"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1011.png" format="PNG" scale="80"/></imageobject></mediaobject></figure><figure float="none" id="figure_10-12"><title>Sofa</title><mediaobject id="I_mediaobject1_d1e5863"><imageobject role="print"><imagedata fileref="figs/print/codb_1012.pdf" format="PDF" scale="80"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1012.png" format="PNG" scale="80"/></imageobject></mediaobject></figure></sect1><sect1 id="I_sect11_d1e5868"><title>Wrapping Up</title><para>J. Chris decided to port his blog from Ruby on Rails to CouchDB. He
    started by exporting Rails ActiveRecord objects as JSON documents, paring
    away some features, and adding others as he converted to HTML and
    JavaScript.</para><para>The resulting blog engine features access-controlled posting, open
    comments with the possibility of moderation, Atom feeds, Markdown
    formatting, and a few other little goodies. This book is not about jQuery,
    so although we use this JavaScript library, we’ll refrain from dwelling on
    it. Readers familiar with using asynchronous XMLHttpRequest (XHR) should
    feel right at home with the code. Keep in mind that the figures and code
    samples in this part omit many of the bookkeeping details.</para><para>We will be studying this application and learning how it exercises
    all the core features of CouchDB. The skills learned in this part should
    be broadly applicable to any CouchDB application domain, whether you
    intend to build a self-hosted CouchApp or not.</para></sect1></chapter><chapter id="managingdesigndocuments"><title>Managing Design Documents</title><para>Applications can live in CouchDB—nice. You just attach a bunch of HTML
  and JavaScript files to a design document and you are good to go. Spice that
  up with view-powered queries and show functions that render any media type
  from your JSON documents, and you have all it takes to write self-contained
  CouchDB applications.<indexterm id="I_indexterm2_d1e5882" significance="normal"><primary>design documents</primary><secondary>working with example application</secondary></indexterm></para><sect1 id="I_sect12_d1e5887"><title>Working with the Example Application</title><note><para>If you want to install and hack on your own version of Sofa while
      you read the following chapters, we’ll be using CouchApp to upload the
      source code as we explore it.</para><para>We’re particularly excited by the prospect of deploying
      applications to CouchDB because, depending on a least-common denominator
      environment, that encourages users to control not just the data but also
      the source code, which will let more people build personal web apps. And
      when the web app you’ve hacked together in your spare time hits the big
      time, the ability of CouchDB to scale to larger infrastructure sure
      doesn’t hurt.</para></note><para>In a CouchDB design document, there are a mix of development
    languages (HTML, JS, CSS) that go into different places like attachments
    and design document attributes. Ideally, you want your development
    environment to help you as much as possible. More important, you’re
    already used to proper syntax highlighting, validation, integrated
    documentation, macros, helpers, and whatnot. Editing HTML and JavaScript
    code as the string attributes of a JSON object is not exactly modern
    computing.<indexterm class="startofrange" id="ch11_CouchApp" significance="normal"><primary>CouchApp</primary></indexterm></para><para>Lucky for you, we’ve been working on a solution. Enter
    <emphasis>CouchApp</emphasis>. CouchApp lets you develop CouchDB
    applications in a convenient directory hierarchy—views and shows are
    separate, neatly organized <filename moreinfo="none">.js</filename> files; your static
    assets (CSS, images) have their place; and with the simplicity of a
    <literal moreinfo="none">couchapp push</literal>, you save your app to a design document
    in CouchDB. Make a change? <literal moreinfo="none">couchapp push</literal> and off you
    go.</para><para>This chapter guides you through the installation and moving parts of
    CouchApp. You will learn what other neat helpers it has in store to make
    your life easier. Once we have CouchApp, we’ll use it to install and
    deploy Sofa to a CouchDB database.</para></sect1><sect1 id="I_sect12_d1e5916"><title>Installing CouchApp</title><para>The CouchApp Python script and JavaScript framework we’ll be using
    grew out of the work designing this example application. It’s now in use
    for a variety of applications, and has a mailing list, wiki, and a
    community of hackers. Just search the Internet for “couchapp” to find the
    latest information. Many thanks to Benoît Chesneau for building and
    maintaining the library (and contributing to CouchDB’s Erlang codebase and
    many of the Python libraries).<indexterm id="I_indexterm2_d1e5921" significance="normal"><primary>design documents</primary><secondary>CouchApps, installation of</secondary></indexterm><indexterm id="I_indexterm2_d1e5926" significance="normal"><primary>CouchApp</primary><secondary>installing</secondary></indexterm></para><para>CouchApp is easiest to install using the Python
    <literal moreinfo="none">easy_install</literal> script, which is part of the
    <literal moreinfo="none">setuptools</literal> package. If you are on a Mac,
    <literal moreinfo="none">easy_install</literal> should already be available. If
    <literal moreinfo="none">easy_install</literal> is not installed and you are on a Debian
    variant, such as Ubuntu, you can use the following command to install
    it:<indexterm id="I_indexterm2_d1e5945" significance="normal"><primary>setuptools package</primary></indexterm><indexterm id="I_indexterm2_d1e5948" significance="normal"><primary>easy_install script</primary></indexterm><indexterm id="I_indexterm2_d1e5952" significance="normal"><primary>Python</primary><secondary>easy_install script</secondary></indexterm></para><screen format="linespecific">sudo apt-get install python-setuptools</screen><para>Once you have <literal moreinfo="none">easy_install</literal>, installing CouchApp
    should be as easy as:</para><screen format="linespecific">sudo easy_install -U couchapp</screen><para>Hopefully, this works and you are ready to start using CouchApp. If
    not, read on….</para><para>The most common problem people have installing CouchApp is with old
    versions of dependencies, especially <literal moreinfo="none">easy_install</literal>
    itself. If you got an installation error, the best next step is to attempt
    to upgrade <literal moreinfo="none">setuptools</literal> and then upgrade CouchApp by
    running the following commands:<indexterm id="I_indexterm2_d1e5976" significance="normal"><primary>CouchApps</primary><secondary>installing</secondary><tertiary>problems with older versions and dependencies</tertiary></indexterm></para><screen format="linespecific">sudo easy_install -U setuptools
sudo easy_install -U couchapp</screen><para>If you have other problems installing CouchApp, have a look at
    <ulink url="http://pypi.python.org/pypi/setuptools"><literal moreinfo="none">setuptools</literal></ulink>
    for Python’s easy install troubleshooting, or visit the <ulink url="http://groups.google.com/group/couchapp"><phrase role="keep-together">CouchApp</phrase> mailing list</ulink>.</para></sect1><sect1 id="I_sect12_d1e5996"><title>Using CouchApp</title><para>Installing CouchApp via <literal moreinfo="none">easy_install</literal> should, as
    they say, be easy. Assuming all goes according to plan, it takes care of
    any dependencies and puts the <literal moreinfo="none">couchapp</literal> utility into
    your system’s <literal moreinfo="none">PATH</literal> so you can immediately begin by
    running the help command:<indexterm id="I_indexterm2_d1e6010" significance="normal"><primary>CouchApp</primary><secondary>running help command</secondary></indexterm></para><screen format="linespecific">couchapp --help</screen><para>We’ll be using the <literal moreinfo="none">clone</literal> and
    <literal moreinfo="none">push</literal> commands. <literal moreinfo="none">clone</literal> pulls an
    application from a running instance in the cloud, saving it as a directory
    structure on your filesystem. <literal moreinfo="none">push</literal> <phrase role="keep-together">deploys</phrase> a standalone CouchDB application
    from your filesystem to any CouchDB over which you have administrative
    control.<indexterm class="startofrange" id="ch11_Sofadownload" significance="normal"><primary>Sofa</primary><secondary>downloading source code</secondary></indexterm></para></sect1><sect1 id="I_sect12_d1e6040"><title>Download the Sofa Source Code</title><para>There are three ways to get the Sofa source code. They are all
    equally valid; it’s just a matter of personal preference and how you plan
    to use the code once you have it. The easiest way is to use CouchApp to
    clone it from a running instance. If you didn’t install CouchApp in the
    previous section, you can read the source code (but not install and run
    it) by downloading and extracting the ZIP or TAR file. If you are
    interested in hacking on Sofa and would like to join the development
    community, the best way to get the source code is from the official Git
    repository. We’ll cover these three methods in turn. First, enjoy <xref linkend="figure_11-1"/>.</para><figure float="none" id="figure_11-1"><title>A happy bird to ease any install-induced frustration</title><mediaobject id="I_mediaobject2_d1e6050"><imageobject role="print"><imagedata fileref="figs/print/codb_1101.pdf" format="PDF" scale="60"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1101.png" format="PNG" scale="60"/></imageobject></mediaobject></figure><sect2><title>CouchApp Clone</title><para>One of the easiest ways to get the Sofa source code is by cloning
      directly from J. Chris’s blog using CouchApp’s <literal moreinfo="none">clone</literal>
      command to download Sofa’s design document to a collection of files on
      your local hard drive. The <literal moreinfo="none">clone</literal> command operates on
      a design document URL, which can be hosted in any CouchDB database
      accessible via HTTP. To clone Sofa from the version running on J.
      Chris’s blog, run the following command:<indexterm id="I_indexterm2_d1e6066" significance="normal"><primary>CouchApp</primary><secondary>clone command</secondary></indexterm><indexterm id="I_indexterm2_d1e6071" significance="normal"><primary>Sofa</primary><secondary>downloading source code</secondary><tertiary>using CouchApp clone command</tertiary></indexterm></para><screen format="linespecific">couchapp clone http://jchrisa.net/drl/_design/sofa</screen><para>You should see this output:</para><screen format="linespecific">[INFO] Cloning sofa to ./sofa</screen><para>Now that you’ve got Sofa on your local filesystem, you can skip to
      <xref linkend="sect1_deploying_sofa"/> to make a small local change and
      push it to your own CouchDB.</para></sect2><sect2><title>ZIP and TAR Files</title><para>If you merely want to peruse the source code while reading along
      with this book, it is available as standard ZIP or TAR downloads. To get
      the ZIP version, access the following URL from your browser, which will
      redirect to the latest ZIP file of Sofa: <ulink url="http://github.com/couchapp/couchapp/zipball/master">http://github.com/couchapp/couchapp/zipball/master</ulink>.
      If you prefer, a TAR file is available as well: <ulink url="http://github.com/couchapp/couchapp/tarball/master"/>.<indexterm id="I_indexterm2_d1e6098" significance="normal"><primary>Sofa</primary><secondary>downloading source code</secondary><tertiary>ZIP and TAR files</tertiary></indexterm></para></sect2><sect2><title>Join the Sofa Development Community on GitHub</title><para>The most up-to-date version of Sofa will always be available at
      its <ulink url="http://github.com/jchris/sofa">public code
      repository</ulink>. If you are interested in staying up-to-date with
      development efforts and contributing patches back to the source, the
      best way to do it is via Git and GitHub.<indexterm id="I_indexterm2_d1e6113" significance="normal"><primary>Sofa</primary><secondary>downloading source code</secondary><tertiary>joining development community on GitHub</tertiary></indexterm></para><para>Git is a form of distributed version control that allows groups of
      developers to track and share changes to software. If you are familiar
      with Git, you’ll have no trouble using it to work on Sofa. If you’ve
      never used Git before, it has a bit of a learning curve, so depending on
      your tolerance for new software, you might want to save learning Git for
      another day—or you might want to dive in head first! For more
      information about Git and how to install it, see <ulink url="http://git-scm.com/">the official Git home page</ulink>. For other
      hints and help using Git, see <ulink url="http://github.com/guides">the
      GitHub guides</ulink>.</para><para>To get Sofa (including all development history) using Git, run the
      following command:</para><screen format="linespecific">git clone git://github.com/jchris/sofa.git</screen><para>Now that you’ve got the source, let’s take a quick tour.<indexterm id="I_indexterm2_d1e6134" class="endofrange" startref="ch11_Sofadownload" significance="normal"/></para></sect2><sect2><title>The Sofa Source Tree</title><para>Once you’ve succeeded with any of these methods, you’ll have a
      copy of Sofa on your local disk. The following text is generated by
      running the <literal moreinfo="none">tree</literal> command on the Sofa directory to
      reveal the full set of files it contains. Sections of the text are
      annotated to make it clear how various files and directories correspond
      to the Sofa design document.<indexterm class="startofrange" id="ch11_Sofasourcetree" significance="normal"><primary>Sofa</primary><secondary>source tree</secondary></indexterm></para><screen format="linespecific">sofa/
|-- README.md
|-- THANKS.txt</screen><para>The source tree contains some files that aren’t necessary for the
      application—the <phrase role="keep-together"><literal moreinfo="none">README</literal></phrase> and
      <literal moreinfo="none">THANKS</literal> files are among those.</para><screen format="linespecific">|-- _attachments
|   |-- LICENSE.txt
|   |-- account.html
|   |-- blog.js
|   |-- jquery.scrollTo.js
|   |-- md5.js
|   |-- screen.css
|   |-- showdown-licenese.txt
|   |-- showdown.js
|   |-- tests.js
|   `-- textile.js</screen><para>The <filename moreinfo="none">_attachments</filename> directory contains files
      that are saved to the Sofa design document as binary attachments.
      CouchDB serves attachments directly (instead of including them in a JSON
      wrapper), so this is where we store JavaScript, CSS, and HTML files that
      the browser will access directly.<indexterm id="I_indexterm2_d1e6166" significance="normal"><primary>attachments to documents</primary><secondary>Sofa design document</secondary></indexterm></para><note><para>Making your first edit to the Sofa source code will show you how
        easy it is to modify the application.</para></note><screen format="linespecific">|-- blog.json</screen><para>The <filename moreinfo="none">blog.json</filename> file contains JSON used to
      configure individual installations of Sofa. Currently, it sets one
      value, the title of the blog. You should open this file now and
      personalize the title field—you probably don’t want to name your blog
      “Daytime Running Lights,” so now’s your chance to come up with something
      more fun!<indexterm id="I_indexterm2_d1e6181" significance="normal"><primary>blog.json file (Sofa)</primary></indexterm><indexterm id="I_indexterm2_d1e6184" significance="normal"><primary>JSON (JavaScript Object Notation)</primary><secondary>blog.json file, Sofa configuration</secondary></indexterm></para><para>You could add other blog configurations to this file—maybe things
      like how many posts to show per page and a URL for an About page for the
      author. Working changes like these into the application will be easy
      once you’ve walked through later <phrase role="keep-together">chapters.</phrase></para><screen format="linespecific">|-- couchapp.json</screen><para>We’ll see later that <literal moreinfo="none">couchapp</literal> outputs a link to
      Sofa’s home page when <literal moreinfo="none">couchapp push</literal> is run. The way
      this works is pretty simple: CouchApp looks for a JSON field on the
      design document at the address
      <filename moreinfo="none">design_doc.couchapp.index</filename>. If it finds it, it
      appends the value to the location of the design document itself to build
      the URL. If there is no CouchApp index specified, but the design
      document has an attachment called <filename role="keep-together" moreinfo="none">index.html</filename>, then it is considered the
      index page. In Sofa’s case, we use the index value to point to a list of
      the most recent posts.<indexterm id="I_indexterm2_d1e6210" significance="normal"><primary>indexes</primary><secondary>Sofa</secondary></indexterm></para><screen format="linespecific">|-- helpers
|   `-- md5.js</screen><para>The <filename moreinfo="none">helpers</filename> directory here is just an
      arbitrary choice—CouchApp will push any files and folders to the design
      document. In this case, the source code to <literal moreinfo="none">md5.js</literal> is
      JSON-encoded and stored on the
      <literal moreinfo="none">design_document.helpers.md5</literal> element.</para><screen format="linespecific">|-- lists
|   `-- index.js</screen><para>The <filename moreinfo="none">lists</filename> directory contains a JavaScript
      function that will be executed by CouchDB to render view rows as Sofa’s
      HTML and Atom indexes. You could add new list functions by creating new
      files within this directory. Lists are covered in depth in <xref linkend="viewinglistsofblogposts"/>.<indexterm id="I_indexterm2_d1e6237" significance="normal"><primary>list functions</primary><secondary>Sofa lists directory</secondary></indexterm></para><screen format="linespecific">|-- shows
|   |-- edit.js
|   `-- post.js</screen><para>The <filename moreinfo="none">shows</filename> directory holds the functions
      CouchDB uses to generate HTML views of blog posts. There are two views:
      one for reading posts and the other for editing. We’ll look at these
      functions in the next few chapters.<indexterm id="I_indexterm2_d1e6249" significance="normal"><primary>shows functions</primary><secondary>shows directory in Sofa</secondary></indexterm><indexterm id="I_indexterm2_d1e6254" significance="normal"><primary>HTML</primary><secondary>views of blog posts (in Sofa)</secondary></indexterm></para><screen format="linespecific">|-- templates
|   |-- edit.html
|   |-- index
|   |   |-- head.html
|   |   |-- row.html
|   |   `-- tail.html
|   `-- post.html</screen><para>The <filename moreinfo="none">templates</filename> directory is like the
      <filename moreinfo="none">helpers</filename> directory and unlike the
      <filename moreinfo="none">lists</filename>, <filename moreinfo="none">shows</filename>, or
      <filename moreinfo="none">views</filename> directories in that the code stored is not
      directly executed on CouchDB’s server side. Instead, the templates are
      included into the body of the list and show functions using macros run
      by CouchApp when pushing code to the server. These CouchApp macros are
      covered in <xref linkend="storingdocuments"/>. The key point is that
      the <filename moreinfo="none">templates</filename> name could be anything. It is not a
      special member of the design document; just a convenient place to store
      and edit our template files.<indexterm id="I_indexterm2_d1e6284" significance="normal"><primary>templates</primary><secondary>templates directory in Sofa</secondary></indexterm></para><screen format="linespecific">|-- validate_doc_update.js</screen><para>This file corresponds to the JavaScript validation function used
      by Sofa to ensure that only the blog owner can create new posts, as well
      as to ensure that the comments are well formed. Sofa’s validation
      function is covered in detail in <xref linkend="storingdocuments"/>.<indexterm id="I_indexterm2_d1e6295" significance="normal"><primary>validation functions</primary><secondary>Sofa</secondary></indexterm></para><screen format="linespecific">|-- vendor
|   `-- couchapp
|       |-- README.md
|       |-- _attachments
|       |   `-- jquery.couchapp.js
|       |-- couchapp.js
|       |-- date.js
|       |-- path.js
|       `-- template.js</screen><para>The <filename moreinfo="none">vendor</filename> directory holds code that is
      managed independently of the Sofa application itself. In Sofa’s case,
      the only vendor package used is <literal moreinfo="none">couchapp</literal>, which
      contains JavaScript code that knows how to do things like link between
      <emphasis>list</emphasis> and <emphasis>show</emphasis> URLs and render
      templates.<indexterm id="I_indexterm2_d1e6317" significance="normal"><primary>vendor directory (Sofa application)</primary></indexterm></para><?dbfo-need height=”1in”
?><para>During <literal moreinfo="none">couchapp push</literal>, files within a
      <filename moreinfo="none">vendor/**/_attachments/*</filename> path are pushed as design
      document attachments. In this case,
      <filename moreinfo="none">jquery.couchapp.js</filename> will be pushed to an <phrase role="keep-together">attachment</phrase> called
      <filename moreinfo="none">couchapp/jquery.couchapp.js</filename> (so that multiple
      vendor packages can have the same attachment names without worry of
      collisions).<indexterm id="I_indexterm2_d1e6339" significance="normal"><primary>CouchApp</primary><secondary>push function</secondary></indexterm></para><screen format="linespecific">`-- views
    |-- comments
    |   |-- map.js
    |   `-- reduce.js
    |-- recent-posts
    |   `-- map.js
    `-- tags
        |-- map.js
        `-- reduce.js</screen><para>The <filename moreinfo="none">views</filename> directory holds MapReduce view
      definitions, with each view represented as a directory, holding files
      corresponding to map and reduce functions.<indexterm id="I_indexterm2_d1e6351" significance="normal"><primary>views</primary><secondary>MapReduce view definitions in Sofa</secondary></indexterm><indexterm id="I_indexterm2_d1e6356" class="endofrange" startref="ch11_Sofasourcetree" significance="normal"/></para></sect2></sect1><sect1 id="sect1_deploying_sofa"><title>Deploying Sofa</title><para>The source code is safely on your hard drive, and you’ve even been
    able to make minor edits to the <filename moreinfo="none">blog.json</filename> file. Now
    it’s time to deploy the blog to a local CouchDB. The
    <literal moreinfo="none">push</literal> command is simple and should work the first time,
    but two other steps are involved in setting up an admin account on your
    CouchDB and for your <phrase role="keep-together">CouchApp</phrase>
    deployments. By the end of this chapter you’ll have your own running copy
    of Sofa.<indexterm class="startofrange" id="ch11_Sofadeploy" significance="normal"><primary>Sofa</primary><secondary>deploying</secondary></indexterm><indexterm class="startofrange" id="ch11_CouchAppSofa" significance="normal"><primary>CouchApp</primary><secondary>deploying Sofa</secondary></indexterm></para><sect2><title>Pushing Sofa to Your CouchDB</title><para>Any time you make edits to the on-disk version of Sofa and want to
      see them in your browser, run the following command:<indexterm id="I_indexterm2_d1e6386" significance="normal"><primary>CouchApp</primary><secondary>deploying Sofa</secondary><tertiary>push function</tertiary></indexterm></para><screen format="linespecific">couchapp push . sofa</screen><para>This deploys the Sofa source code into CouchDB. You should see
      output like this:</para><screen format="linespecific">[INFO] Pushing CouchApp in /Users/jchris/sofa to design doc:
http://127.0.0.1:5984/sofa/_design/sofa
[INFO] Visit your CouchApp here:
http://127.0.0.1:5984/sofa/_design/sofa/_list/index/recent-posts?descending=
true&amp;limit=5</screen><para>If you get an error, make sure your target CouchDB instance is
      running by making a simple HTTP request to it:</para><screen format="linespecific">curl http://127.0.0.1:5984</screen><para>The response should look like:</para><programlisting id="I_programlisting2_d1e6405" language="javascript" linenumbering="unnumbered" format="linespecific">{"couchdb":"Welcome","version":"0.10.1"}</programlisting><para>If CouchDB is not running yet, go back to <xref linkend="gettingstarted"/> and follow the “Hello World” <phrase role="keep-together">instructions</phrase> there.</para></sect2><sect2><title>Visit the Application</title><para>If CouchDB was running, then <literal moreinfo="none">couchapp push</literal>
      should have directed you to visit <ulink url="http://127.0.0.1:5984/sofa/_design/sofa/_list/index/recent-posts?descending=true&amp;limit=5">the
      application’s index URL</ulink>. Visiting the URL should show you
      something like <xref linkend="figure_11-2"/>.<indexterm id="I_indexterm2_d1e6427" significance="normal"><primary>Sofa</primary><secondary>deploying</secondary><tertiary>visiting application’s index URL</tertiary></indexterm><indexterm id="I_indexterm2_d1e6434" significance="normal"><primary>CouchApp</primary><secondary>deploying Sofa</secondary><tertiary>visiting application’s index URL</tertiary></indexterm></para><figure float="none" id="figure_11-2"><title>Empty index page</title><mediaobject id="I_mediaobject2_d1e6444"><imageobject role="print"><imagedata fileref="figs/print/codb_1102.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1102.png" format="PNG"/></imageobject></mediaobject></figure><para>We’re not done yet—there are a couple of steps remaining before
      you’ve got a fully functional Sofa instance.<indexterm id="I_indexterm2_d1e6451" class="endofrange" startref="ch11_Sofadeploy" significance="normal"/><indexterm id="I_indexterm2_d1e6452" class="endofrange" startref="ch11_CouchAppSofa" significance="normal"/></para></sect2></sect1><sect1 id="I_sect12_d1e6453"><title>Set Up Your Admin Account</title><para>Sofa is a single-user application. You, the author, are the
    administrator and the only one who can add and edit posts. To make sure no
    one else goes in and messes with your writing, you must create an
    administrator account in CouchDB. This is a straightforward task. Find
    your <filename moreinfo="none">local.ini</filename> file and open it in your text editor.
    (By default, it’s stored at
    <filename moreinfo="none">/usr/local/etc/couchdb/local.ini</filename>.) If you haven’t
    already, uncomment the <literal moreinfo="none">[admins]</literal> section at the end of
    the file. Next, add a line right below the <literal moreinfo="none">[admins]</literal>
    section with your preferred username and password:<indexterm id="I_indexterm2_d1e6470" significance="normal"><primary>CouchApp</primary><secondary>setting up Sofa admin account</secondary></indexterm><indexterm id="I_indexterm2_d1e6475" significance="normal"><primary>local.ini file</primary></indexterm><indexterm id="I_indexterm2_d1e6479" significance="normal"><primary>admin accounts</primary><secondary>setting up for Sofa</secondary></indexterm><indexterm id="I_indexterm2_d1e6484" significance="normal"><primary>Sofa</primary><secondary>setting up admin account</secondary></indexterm></para><screen format="linespecific">[admins]
jchris = secretpass</screen><para>Now that you’ve edited your <filename moreinfo="none">local.ini</filename>
    configuration file, you need to restart CouchDB for changes to take
    effect. Depending on how you started CouchDB, there are different methods
    of restarting it. If you started in a console, then hitting Ctrl-C and
    rerunning the same command you used to start it is the simplest
    way.</para><para>If you don’t like your passwords lying around in plain-text files,
    don’t worry. When CouchDB starts up and reads this file, it takes your
    password and changes it to a secure hash, like this:</para><screen format="linespecific">[admins]
jchris = -hashed-207b1b4f8434dc604206c2c0c2aa3aae61568d6c,964 \
  06178007181395cb72cb4e8f2e66e</screen><para>CouchDB will now ask you for your credentials when you try to create
    databases or change documents—exactly the things you want to keep to
    yourself.</para><sect2><title>Deploying to a Secure CouchDB</title><para>Now that we’ve set up admin credentials, we’ll need to supply them
      on the command line when running <literal moreinfo="none">couchapp push</literal>. Let’s
      try it:</para><screen format="linespecific">couchapp push . http://jchris:secretpass@localhost:5984/sofa</screen><para>Make sure to replace <literal moreinfo="none">jchris</literal> and
      <literal moreinfo="none">secretpass</literal> with your actual values or you will get a
      “permission denied” error. If all works according to plan, everything
      will be set up in CouchDB and you should be able to start using your
      blog.</para><para>At this point, we are technically ready to move on, but you’ll be
      much happier if you make use of the <filename moreinfo="none">.couchapprc</filename>
      file as documented in the next section.</para></sect2></sect1><sect1 id="I_sect12_d1e6525"><title>Configuring CouchApp with .couchapprc</title><para>If you don’t want to have to put the full URL (potentially including
    authentication parameters) of your database onto the command line each
    time you push, you can use the <filename moreinfo="none">.couchapprc</filename> file to
    store deployment settings. The contents of this file are not pushed along
    with the rest of the app, so it can be a safe place to keep credentials
    for uploading your app to secure servers.<indexterm id="I_indexterm2_d1e6533" significance="normal"><primary sortas="couchapprc">.couchapprc file</primary></indexterm><indexterm id="I_indexterm2_d1e6536" significance="normal"><primary>CouchApp</primary><secondary>configuring with .couchapprc</secondary></indexterm></para><para>The <filename moreinfo="none">.couchapprc</filename> file lives in the source
    directory of your application, so you should look to see if it is at
    <filename moreinfo="none">/path/to/the/directory/of/sofa/.couchapprc</filename> (or create
    it there if it is missing). Dot files (files with names that start with a
    period) are left out of most directory listings. Use whatever tricks your
    OS has to “show hidden files.” The simplest one in a standard command
    shell is to list the directory using <literal moreinfo="none">ls -a</literal>, which will
    show all hidden files as well as normal files.</para><programlisting id="I_programlisting2_d1e6552" language="javascript" linenumbering="unnumbered" format="linespecific">    {
      "env": {
        "default": {
          "db": "http://jchris:secretpass@localhost:5984/sofa"
        },
        "staging": {
          "db": "http://jchris:secretpass@jchrisa.net:5984/sofa-staging"
        },
        "drl": {
          "db": "http://jchris:secretpass@jchrisa.net/drl"
        }
      }
    }</programlisting><?dbfo-need height=”1in”
?><para>With this file set up, you can push your CouchApp with the command
    <literal moreinfo="none">couchapp push</literal>, which will push the application to the
    “default” database. CouchApp also supports alternate environments. To push
    your application to a development database, you could use
    <literal moreinfo="none">couchapp push dev</literal>. In our experience, taking the time
    to set up a good <filename moreinfo="none">.couchapprc</filename> is always worth it.
    Another benefit is that it keeps your passwords off the screen when you
    are working.<indexterm id="I_indexterm2_d1e6566" class="endofrange" startref="ch11_CouchApp" significance="normal"/></para></sect1></chapter><chapter id="storingdocuments"><title>Storing Documents</title><para><emphasis>Documents</emphasis> are CouchDB’s central data structure.
  To best understand and use CouchDB, you need to <emphasis>think in
  documents</emphasis>. This chapter walks you though the lifecycle of
  designing and saving a document. We’ll follow up by reading documents and
  aggregating and querying them with views. In the next section, you’ll see
  how CouchDB can also transform documents into other formats.<indexterm class="startofrange" id="ch12_docsstoring" significance="normal"><primary>documents</primary></indexterm></para><para>Documents are self-contained units of data. You might have heard the
  term <emphasis>record</emphasis> to describe something similar. Your data is
  usually made up of small native types such as integers and strings.
  Documents are the first level of abstraction over these native types. They
  provide some structure and logically group the primitive data. The height of
  a person might be encoded as an integer (<literal moreinfo="none">176</literal>), but this
  integer is usually part of a larger structure that contains a label
  (<literal moreinfo="none">"height": 176</literal>) and related data
  (<literal moreinfo="none">{"name":"Chris", "height": 176}</literal>).<indexterm id="I_indexterm3_d1e6594" significance="normal"><primary>types</primary><secondary>data items in documents</secondary></indexterm><indexterm id="I_indexterm3_d1e6599" significance="normal"><primary>records</primary></indexterm></para><para>How many data items you put into your documents depends on your
  application and a bit on how you want to use views (later), but generally, a
  document roughly corresponds to an object instance in your programming
  language. Are you running an online shop? You will have
  <emphasis>items</emphasis> and <emphasis>sales</emphasis> and
  <emphasis>comments</emphasis> for your items. They all make good candidates
  for objects and, subsequently, documents.</para><para>Documents differ subtly from garden-variety objects in that they
  usually have authors and CRUD operations (create, read, update, delete).
  Document-based software (like the word processors and spreadsheets of yore)
  builds its storage model around saving documents so that authors get back
  what they created. Similarly, in a CouchDB application you may find yourself
  giving greater leeway to the presentation layer. If, instead of adding
  timestamps to your data in a controller, you allow the user to control them,
  you get draft status and the ability to publish articles in the future for
  free (by viewing published documents using an <literal moreinfo="none">endkey</literal> of
  <emphasis>now</emphasis>).<indexterm id="I_indexterm3_d1e6621" significance="normal"><primary>objects</primary><secondary>documents versus</secondary></indexterm></para><para>Validation functions are available so that you don’t have to worry
  about bad data causing errors in your system. Often in document-based
  software, the client application edits and manipulates the data, saving it
  back. As long as you give the user the document she asked you to save,
  she’ll be happy.</para><para>Say your users can comment on the item (“lovely book”); you have the
  option to store the comments as an array, on the item document. This makes
  it trivial to find the item’s comments, but, as they say, “it doesn’t
  scale.” A popular item could have tens of comments, or even hundreds or
  more.</para><para>Instead of storing a list on the item document, in this case it may be
  better to model comments into a collection of documents. There are patterns
  for accessing collections, which CouchDB makes easy. You likely want to show
  only 10 or 20 at a time and provide <emphasis>previous</emphasis> and
  <emphasis>next</emphasis> links. By handling comments as individual
  entities, you can group them with views. A group could be the entire
  collection or slices of 10 or 20, sorted by the item they apply to so that
  it’s easy to grab the set you need.</para><para>A rule of thumb: break up into documents everything that you will be
  handling separately in your application. Items are single, and comments are
  single, but you don’t need to break them into smaller pieces. Views are a
  convenient way to group your documents in meaningful ways.</para><para>Let’s go through building our example application to show you in
  practice how to work with documents.</para><sect1 id="I_sect13_d1e6642"><title>JSON Document Format</title><para>The first step in designing any application (once you know what the
    program is for and have the user interaction nailed down) is deciding on
    the format it will use to represent and store data. Our example blog is
    written in JavaScript. A few lines back we said documents roughly
    represent your data objects. In this case, there is a an exact
    correspondence. CouchDB borrowed the JSON data format from JavaScript;
    this allows us to use documents directly as native objects when
    programming. This is really convenient and leads to fewer problems down
    the road (if you ever worked with an ORM system, you might know what we
    are hinting at).<indexterm id="I_indexterm3_d1e6647" significance="normal"><primary>JSON (JavaScript Object Notation)</primary><secondary>document format</secondary></indexterm><indexterm id="I_indexterm3_d1e6652" significance="normal"><primary>documents</primary><secondary>JSON format</secondary></indexterm></para><para>Let’s draft a JSON format for blog posts. We know we’ll need each
    post to have an author, a title, and a body. We know we’d like to use
    document IDs to find documents so that URLs are search engine–friendly,
    and we’d also like to list them by creation date.<indexterm id="I_indexterm3_d1e6659" significance="normal"><primary>blog posts</primary><secondary>JSON format for</secondary></indexterm></para><para>It should be pretty straightforward to see how JSON works. Curly
    braces (<literal moreinfo="none">{}</literal>) wrap objects, and objects are key/value
    lists. Keys are strings that are wrapped in double quotes
    (<literal moreinfo="none">""</literal>). Finally, a value is a string, an integer, an
    object, or an array (<literal moreinfo="none">[]</literal>). Keys and values are separated
    by a colon (<literal moreinfo="none">:</literal>), and multiple keys and values by comma
    (<literal moreinfo="none">,</literal>). That’s it. For a complete description of the JSON
    format, see <xref linkend="jsonprimer"/>.<indexterm id="I_indexterm3_d1e6684" significance="normal"><primary>objects</primary><secondary>JSON syntax</secondary></indexterm><indexterm id="I_indexterm3_d1e6689" significance="normal"><primary>[ ] (square brackets), enclosing arrays in JSON</primary></indexterm><indexterm id="I_indexterm3_d1e6692" significance="normal"><primary>, (comma), separating multiple keys and values in
        JSON</primary></indexterm><indexterm id="I_indexterm3_d1e6695" significance="normal"><primary>: (colon), separating key/value pairs</primary></indexterm><indexterm id="I_indexterm3_d1e6698" significance="normal"><primary>objects</primary><secondary>JSON</secondary></indexterm><indexterm id="I_indexterm3_d1e6703" significance="normal"><primary>key/value dictionaries in JSON</primary></indexterm><indexterm id="I_indexterm3_d1e6706" significance="normal"><primary>{ } (curly braces), enclosing objects in JSON</primary></indexterm></para><para><xref linkend="figure_12_1"/> shows a document that meets our
    requirements. The cool thing is we just made it up on the spot. We didn’t
    go and define a schema, and we didn’t define how things should look. We
    just created a document with whatever we needed. Now, requirements for
    objects change all the time during the development of an application.
    Coming up with a different document that meets new, evolved needs is just
    as easy.</para><figure float="none" id="figure_12_1"><title>The JSON post format</title><mediaobject id="I_mediaobject3_d1e6715"><imageobject role="print"><imagedata fileref="figs/print/codb_1201.pdf" format="PDF" scale="90"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1201.png" format="PNG" scale="90"/></imageobject></mediaobject></figure><blockquote><attribution>The Joker, <emphasis>The Dark
      Knight</emphasis></attribution><para>Do I really look like a guy with a plan? You know what I am? I’m a
      dog chasing cars. I wouldn’t know what to do with one if I caught it.
      You know, I just do things. The mob has plans, the cops have plans,
      Gordon’s got plans. You know, they’re schemers. Schemers trying to
      control their little worlds. I’m not a schemer. I try to show the
      schemers how pathetic their attempts to control things really
      are.</para></blockquote><para>Let’s examine the document in a little more detail. The first two
    members (<literal moreinfo="none">_id</literal> and <literal moreinfo="none">_rev</literal>) are for
    CouchDB’s housekeeping and act as identification for a particular <phrase role="keep-together"><emphasis>instance</emphasis></phrase> of a document.
    <literal moreinfo="none">_id</literal> is easy: if I store something in CouchDB, it
    creates the <literal moreinfo="none">_id</literal> and returns it to me. I can use the
    <literal moreinfo="none">_id</literal> to build the URL where I can get my something
    back.<indexterm id="I_indexterm3_d1e6749" significance="normal"><primary>documents</primary><secondary sortas="id field">_id field</secondary></indexterm><indexterm id="I_indexterm3_d1e6754" significance="normal"><primary>documents</primary><secondary sortas="rev field">_rev field</secondary></indexterm><indexterm id="I_indexterm3_d1e6759" significance="normal"><primary sortas="rev field, documents">_rev field, documents</primary></indexterm><indexterm id="I_indexterm3_d1e6762" significance="normal"><primary sortas="id field, documents">_id field, documents</primary></indexterm></para><note><para>Your document’s <literal moreinfo="none">_id</literal> defines the URL the
      document can be found under. Say you have a database
      <literal moreinfo="none">movies</literal>. All documents can be found somewhere under
      the URL <literal moreinfo="none">/movies</literal>, but where exactly?</para><para>If you store a document with the <literal moreinfo="none">_id</literal>
      <literal moreinfo="none">Jabberwocky</literal>
      (<literal moreinfo="none">{"_id":"Jabberwocky"}</literal>) into your
      <literal moreinfo="none">movies</literal> database, it will be available under the URL
      <literal moreinfo="none">/movies/Jabberwocky</literal>. So if you send a GET request to
      <literal moreinfo="none">/movies/Jabberwocky</literal>, you will get back the JSON that
      makes up your document
      (<literal moreinfo="none">{"_id":"Jabberwocky"}</literal>).</para></note><para>The <literal moreinfo="none">_rev</literal> (or <emphasis>revision ID</emphasis>)
    describes a version of a document. Each change creates a new document
    version (that again is self-contained) and updates the
    <literal moreinfo="none">_rev</literal>. This becomes useful because, when saving a
    document, you must provide an up-to-date <literal moreinfo="none">_rev</literal> so that
    CouchDB knows you’ve been working against the latest document
    version.</para><para>We touched on this in <xref linkend="eventualconsistency"/>. The
    revision ID acts as a gatekeeper for writes to a document in CouchDB’s
    MVCC system. A document is a shared resource; many clients can read and
    write them at the same time. To make sure two writing clients don’t step
    on each other’s feet, each client must provide what it believes is the
    latest revision ID of a document along with the proposed changes. If the
    on-disk revision ID matches the provided <literal moreinfo="none">_rev</literal>, CouchDB
    will accept the change. If it doesn’t, the update will be rejected. The
    client should read the latest version, integrate the changes, and try
    saving again.</para><para>This mechanism ensures two things: a client can only overwrite a
    version it knows, and it can’t trip over changes made by other clients.
    This works without CouchDB having to manage explicit
    <emphasis>locks</emphasis> on any document. This ensures that no client
    has to wait for another client to complete any work. Updates are
    serialized, so CouchDB will never attempt to write documents faster than
    your disk can spin, and it also means that two mutually conflicting writes
    can’t be written at the same time.</para></sect1><sect1 id="I_sect13_d1e6829"><title>Beyond _id and _rev: Your Document Data</title><para>Now that you thoroughly understand the role of
    <literal moreinfo="none">_id</literal> and <literal moreinfo="none">_rev</literal> on a document, let’s
    look at everything else we’re storing.<indexterm id="I_indexterm3_d1e6840" significance="normal"><primary>blog posts</primary><secondary>CouchDB document for</secondary></indexterm><indexterm id="I_indexterm3_d1e6845" significance="normal"><primary>documents</primary><secondary>data other than _id and _rev</secondary></indexterm></para><programlisting id="I_programlisting3_d1e6850" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "_id":"Hello-Sofa",
  "_rev":"2-2143609722",
  "type":"post",</programlisting><para>The first thing is the type of the document. Note that this is an
    application-level parameter, not anything particular to CouchDB. The type
    is just an arbitrarily named <phrase role="keep-together">key/value</phrase> pair as far as CouchDB is
    concerned. For us, as we’re adding blog posts to Sofa, it has a little
    deeper meaning. Sofa uses the <literal moreinfo="none">type</literal> field to determine
    which validations to apply. It can then rely on documents of that type
    being valid in the views and the user interface. This removes the need to
    check for every field and nested JSON value before using it. This is
    purely by convention, and you can make up your own or infer the type of a
    document by its structure (“has an array with three elements”—a.k.a.
    <emphasis>duck typing</emphasis>). We just thought this was easy to follow
    and hope you agree.<indexterm id="I_indexterm3_d1e6863" significance="normal"><primary>duck typing</primary></indexterm><indexterm id="I_indexterm3_d1e6866" significance="normal"><primary>types</primary></indexterm></para><programlisting id="I_programlisting3_d1e6869" language="javascript" linenumbering="unnumbered" format="linespecific">  "author":"jchris",
  "title":"Hello Sofa",</programlisting><para>The <literal moreinfo="none">author</literal> and <literal moreinfo="none">title</literal> fields
    are set when the post is created. The <literal moreinfo="none">title</literal> field can
    be changed, but the <literal moreinfo="none">author</literal> field is locked by the
    validation function for security. Only the author may edit the
    post.</para><programlisting id="I_programlisting3_d1e6885" language="javascript" linenumbering="unnumbered" format="linespecific">  "tags":["example","blog post","json"],</programlisting><para>Sofa’s tag system just stores them as an array on the document. This
    kind of denormalization is a particularly good fit for CouchDB.</para><programlisting id="I_programlisting3_d1e6889" language="javascript" linenumbering="unnumbered" format="linespecific">  "format":"markdown",
  "body":"some markdown text",
  "html":"&lt;p&gt;the html text&lt;/p&gt;",</programlisting><para>Blog posts are composed in the <ulink url="http://daringfireball.net/projects/markdown/">Markdown HTML
    format</ulink> to make them easy to author. The Markdown format as typed
    by the user is stored in the <literal moreinfo="none">body</literal> field. Before the
    blog post is saved, Sofa converts it to HTML in the client’s browser.
    There is an interface for previewing the Markdown conversion, so you can
    be sure it will display as you like.<indexterm id="I_indexterm3_d1e6899" significance="normal"><primary>created_at field</primary></indexterm><indexterm id="I_indexterm3_d1e6902" significance="normal"><primary>HTML</primary><secondary>Markdown format</secondary></indexterm><indexterm id="I_indexterm3_d1e6907" significance="normal"><primary>Markdown HTML format</primary></indexterm></para><programlisting id="I_programlisting3_d1e6910" language="javascript" linenumbering="unnumbered" format="linespecific">  "created_at":"2009/05/25 06:10:40 +0000"
}</programlisting><para>The <literal moreinfo="none">created_at</literal> field is used to order blog posts
    in the Atom feed and on the HTML index page.</para></sect1><sect1 id="I_sect13_d1e6918"><title>The Edit Page</title><para>The first page we need to build in order to get one of these blog
    entries into our post is the interface for creating and editing
    posts.<indexterm class="startofrange" id="ch03_editpage" significance="normal"><primary>edit page</primary></indexterm><indexterm class="startofrange" id="ch03_docsedit" significance="normal"><primary>documents</primary><secondary>edit page</secondary></indexterm></para><para>Editing is more complex than just rendering posts for visitors to
    read, but that means once you’ve read this chapter, you’ll have seen most
    of the techniques we touch on in the other chapters.</para><para>The first thing to look at is the <emphasis>show function</emphasis>
    used to render the HTML page. If you haven’t already, read <xref linkend="showfunctions"/> to learn about the details of the API. We’ll
    just look at this code in the context of Sofa, so you can see how it all
    fits together.<indexterm id="I_indexterm3_d1e6940" significance="normal"><primary>show functions</primary><secondary>edit page show function</secondary></indexterm></para><programlisting id="I_programlisting3_d1e6945" language="javascript" linenumbering="unnumbered" format="linespecific">function(doc, req) {
  // !json templates.edit
  // !json blog
  // !code vendor/couchapp/path.js
  // !code vendor/couchapp/template.js</programlisting><para>Sofa’s edit page show function is very straightforward. In the
    previous section, we showed the important templates and libraries we’ll
    use. The important line is the <literal role="keep-together" moreinfo="none">!json</literal> macro, which loads the
    <filename moreinfo="none">edit.html</filename> template from the
    <filename moreinfo="none">templates</filename> directory. These macros are run by
    CouchApp, as Sofa is being deployed to CouchDB. For more information about
    the macros, see <indexterm id="I_indexterm3_d1e6958" significance="normal"><primary sortas="json macro">!json macro</primary><secondary>loading edit.html template</secondary></indexterm><indexterm id="I_indexterm3_d1e6963" significance="normal"><primary>templates</primary><secondary>edit.html template, loaded by !json macro</secondary></indexterm><indexterm id="I_indexterm3_d1e6968" significance="normal"><primary>macros</primary><secondary>!json</secondary><tertiary>loading edit.html template</tertiary></indexterm><xref linkend="showingdocumentsincustomformats"/>.</para><programlisting id="I_programlisting3_d1e6977" language="javascript" linenumbering="unnumbered" format="linespecific">  // we only show html
  return template(templates.edit, {
    doc : doc,
    docid : toJSON((doc &amp;&amp; doc._id) || null),
    blog : blog,
    assets : assetPath(),
    index : listPath('index','recent-posts',{descending:true,limit:8})
  });
}</programlisting><para>The rest of the function is simple. We’re just rendering the HTML
    template with data culled from the document. In the case where the
    document does not yet exist, we make sure to set the
    <literal moreinfo="none">docid</literal> to <literal moreinfo="none">null</literal>. This allows us to use
    the same template both for creating new blog posts as well as editing
    existing ones.</para><sect2><title>The HTML Scaffold</title><para>The only missing piece of this puzzle is the HTML that it takes to
      save a document like this.<indexterm id="I_indexterm3_d1e6992" significance="normal"><primary>documents</primary><secondary>edit page</secondary><tertiary>HTML scaffold</tertiary></indexterm><indexterm id="I_indexterm3_d1e6999" significance="normal"><primary>HTML</primary><secondary>listing for edit.html</secondary></indexterm></para><para>In your browser, visit
      <filename moreinfo="none">http://127.0.0.1:5984/blog/_design/sofa/_show/edit</filename>
      and, using your text editor, open the source file
      <filename moreinfo="none">templates/edit.html</filename> (or view source in your
      browser). Everything is ready to go; all we have to do is wire up
      CouchDB using <phrase role="keep-together">in-page</phrase> JavaScript.
      See <xref linkend="figure_12-2"/>.</para><para>Just like any web application, the important part of the HTML is
      the form for accepting edits. The edit form captures a few basic data
      items: the post title, the body (in Markdown format), and any tags the
      author would like to apply.</para><programlisting id="I_programlisting3_d1e7019" language="html" linenumbering="unnumbered" format="linespecific">&lt;!-- form to create a Post --&gt;
&lt;form id="new-post" action="new.html" method="post"&gt;
  &lt;h1&gt;Create a new post&lt;/h1&gt;
  &lt;p&gt;&lt;label&gt;Title&lt;/label&gt;
    &lt;input type="text" size="50" name="title"&gt;&lt;/p&gt;
  &lt;p&gt;&lt;label for="body"&gt;Body&lt;/label&gt;
    &lt;textarea name="body" rows="28" cols="80"&gt;
    &lt;/textarea&gt;&lt;/p&gt;
  &lt;p&gt;&lt;input id="preview" type="button" value="Preview"/&gt;
    &lt;input type="submit" value="Save &amp;rarr;"/&gt;&lt;/p&gt;
&lt;/form&gt;</programlisting><para>We start with just a raw HTML document, containing a normal HTML
      form. We use JavaScript to convert user input into a JSON document and
      save it to CouchDB. In the spirit of focusing on CouchDB, we won’t dwell
      on the JavaScript here. It’s a combination of Sofa-specific application
      code, CouchApp’s JavaScript helpers, and jQuery for interface elements.
      The basic story is that it watches for the user to click “Save,” and
      then applies some callbacks to the document before sending it to
      CouchDB.<indexterm id="I_indexterm3_d1e7023" class="endofrange" startref="ch03_editpage" significance="normal"/><indexterm id="I_indexterm3_d1e7024" class="endofrange" startref="ch03_docsedit" significance="normal"/><indexterm id="I_indexterm3_d1e7025" significance="normal"><primary>JavaScript</primary><secondary>converting user input to JSON in HTML form</secondary></indexterm></para><figure float="none" id="figure_12-2"><title>HTML listing for edit.html</title><mediaobject id="I_mediaobject3_d1e7033"><imageobject role="print"><imagedata fileref="figs/print/codb_1202.pdf" format="PDF" scale="90"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1202.png" format="PNG" scale="90"/></imageobject></mediaobject></figure></sect2></sect1><sect1 id="I_sect13_d1e7038"><title>Saving a Document</title><para>The JavaScript that drives blog post creation and editing centers
    around the HTML form from <xref linkend="figure_12-2"/>. The CouchApp
    jQuery plug-in provides some abstraction, so we don’t have to concern
    ourselves with the details of how the form is converted to a JSON document
    when the user hits the submit button. <literal moreinfo="none">$.CouchApp</literal> also
    ensures that the user is logged in and makes her information available to
    the application. See <xref linkend="figure_12-3"/>.<indexterm class="startofrange" id="ch12_editformJS" significance="normal"><primary>edit.html form, JavaScript callbacks for</primary></indexterm><indexterm class="startofrange" id="ch12_docsaving" significance="normal"><primary>documents</primary><secondary>saving</secondary></indexterm><indexterm class="startofrange" id="ch12_JScallbacks" significance="normal"><primary>JavaScript</primary><secondary>callbacks for edit.html</secondary></indexterm><indexterm id="I_indexterm3_d1e7063" significance="normal"><primary>jQuery plug-in (CouchApp)</primary></indexterm><indexterm id="I_indexterm3_d1e7067" significance="normal"><primary>CouchApp</primary><secondary>jQuery plug-in</secondary></indexterm></para><programlisting id="I_programlisting3_d1e7072" language="javascript" linenumbering="unnumbered" format="linespecific">$.CouchApp(function(app) {
  app.loggedInNow(function(login) {</programlisting><para>The first thing we do is ask the CouchApp library to make sure the
    user is logged in. Assuming the answer is yes, we’ll proceed to set up the
    page as an editor. This means we apply a JavaScript event handler to the
    form and specify callbacks we’d like to run on the document, both when it
    is loaded and when it saved.</para><figure float="none" id="figure_12-3"><title>JavaScript callbacks for edit.html</title><mediaobject id="I_mediaobject3_d1e7079"><imageobject role="print"><imagedata fileref="figs/print/codb_1203.pdf" format="PDF" scale="90"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1203.png" format="PNG" scale="90"/></imageobject></mediaobject></figure><programlisting id="I_programlisting3_d1e7084" language="javascript" linenumbering="unnumbered" format="linespecific">    // w00t, we're logged in (according to the cookie)
    $("#header").prepend('&lt;span id="login"&gt;'+login+'&lt;/span&gt;');
    // setup CouchApp document/form system, adding app-specific callbacks
    var B = new Blog(app);</programlisting><?dbfo-need height=”1in”
?><para>Now that we know the user is logged in, we can render his username
    at the top of the page. The variable <literal moreinfo="none">B</literal> is just a
    shortcut to some of the Sofa-specific blog rendering code. It contains
    methods for converting blog post bodies from Markdown to HTML, as well as
    a few other odds and ends. We pulled these functions into
    <filename moreinfo="none">blog.js</filename> so we could keep them out of the way of main
    code.<indexterm class="startofrange" id="ch12_dpcFormhelper" significance="normal"><primary>docForm( ) helper function</primary></indexterm><indexterm class="startofrange" id="ch12_CouchAppdocForm" significance="normal"><primary>CouchApp</primary><secondary>app.docForm( ) helper function</secondary></indexterm></para><programlisting id="I_programlisting3_d1e7103" language="javascript" linenumbering="unnumbered" format="linespecific">    var postForm = app.docForm("form#new-post", {
      id : &lt;%= docid %&gt;,
      fields : ["title", "body", "tags"],
      template : {
        type : "post",
        format : "markdown",
        author : login
      },</programlisting><para>CouchApp’s <literal moreinfo="none">app.docForm()</literal> helper is a function to
    set up and maintain a correspondence between a CouchDB document and an
    HTML form. Let’s look at the first three arguments passed to it by Sofa.
    The <literal moreinfo="none">id</literal> argument tells <literal moreinfo="none">docForm()</literal>
    where to save the document. This can be null in the case of a new
    document. We set <literal moreinfo="none">fields</literal> to an array of form elements
    that will correspond directly to JSON fields in the CouchDB document.
    Finally, the <literal moreinfo="none">template</literal> argument is given a JavaScript
    object that will be used as the starting point, in the case of a new
    document. In this case, we ensure that the document has a type equal to
    “post,” and that the default format is Markdown. We also set the author to
    be the login name of the current user.</para><programlisting id="I_programlisting3_d1e7122" language="javascript" linenumbering="unnumbered" format="linespecific">      onLoad : function(doc) {
        if (doc._id) {
          B.editing(doc._id);
          $('h1').html('Editing &lt;a href="../post/'+doc._id+'"&gt;'+doc._id+'&lt;/a&gt;');
          $('#preview').before('&lt;input type="button" id="delete" 
              value="Delete Post"/&gt; ');
          $("#delete").click(function() {
            postForm.deleteDoc({
              success: function(resp) {
                $("h1").text("Deleted "+resp.id);
                $('form#new-post input').attr('disabled', true);
              }
            });
            return false;
          });
        }
        $('label[for=body]').append(' &lt;em&gt;with '+(doc.format||'html')+'&lt;/em&gt;');</programlisting><para>The <literal moreinfo="none">onLoad</literal> callback is run when the document is
    loaded from CouchDB. It is useful for decorating the document before
    passing it to the form, or for setting up other user interface elements.
    In this case, we check to see if the document already has an ID. If it
    does, that means it’s been saved, so we create a button for deleting it
    and set up the callback to the delete function. It may look like a lot of
    code, but it’s pretty standard for Ajax applications. If there is one
    criticism to make of this section, it’s that the logic for creating the
    delete button could be moved to the <filename moreinfo="none">blog.js</filename> file so
    we can keep more user-interface details out of the main flow.</para><programlisting id="I_programlisting3_d1e7133" language="javascript" linenumbering="unnumbered" format="linespecific">      },
      beforeSave : function(doc) {
        doc.html = B.formatBody(doc.body, doc.format);
        if (!doc.created_at) {
          doc.created_at = new Date();
        }
        if (!doc.slug) {
          doc.slug = app.slugifyString(doc.title);
          doc._id = doc.slug;
        }
        if(doc.tags) {
          doc.tags = doc.tags.split(",");
          for(var idx in doc.tags) {
            doc.tags[idx] = $.trim(doc.tags[idx]);
          }
        }
      },</programlisting><para>The <literal moreinfo="none">beforeSave()</literal> callback to
    <literal moreinfo="none">docForm</literal> is run after the user clicks the submit button.
    In Sofa’s case, it manages setting the blog post’s timestamp, transforming
    the title into an acceptable document ID (for prettier URLs), and
    processing the document tags from a string into an array. It also runs the
    Markdown-to-HTML conversion in the browser so that once the document is
    saved, the rest of the application has direct access to the HTML.</para><programlisting id="I_programlisting3_d1e7143" language="javascript" linenumbering="unnumbered" format="linespecific">      success : function(resp) {
        $("#saved").text("Saved _rev: "+resp.rev).fadeIn(500).fadeOut(3000);
        B.editing(resp.id);
      }
    });</programlisting><para>The last callback we use in Sofa is the <literal moreinfo="none">success</literal>
    callback. It is fired when the document is successfully saved. In our
    case, we use it to flash a message to the user that lets her know she’s
    succeeded, as well as to add a link to the blog post so that when you
    create a blog post for the first time, you can click through to see its
    permalink page.</para><para>That’s it for the <literal moreinfo="none">docForm()</literal> callbacks.</para><programlisting id="I_programlisting3_d1e7155" language="javascript" linenumbering="unnumbered" format="linespecific">    $("#preview").click(function() {
      var doc = postForm.localDoc();
      var html = B.formatBody(doc.body, doc.format);
      $('#show-preview').html(html);
      // scroll down
      $('body').scrollTo('#show-preview', {duration: 500});
    });</programlisting><para>Sofa has a function to preview blog posts before saving them. Since
    this doesn’t affect how the document is saved, the code that watches for
    events from the “preview” button is not applied within the
    <literal moreinfo="none">docForm()</literal> callbacks.</para><programlisting id="I_programlisting3_d1e7162" language="javascript" linenumbering="unnumbered" format="linespecific">  }, function() {
    app.go('&lt;%= assets %&gt;/account.html#'+document.location);
  });
});</programlisting><para>The last bit of code here is triggered when the user is not logged
    in. All it does is redirect him to the account page so that he can log in
    and try editing again.<indexterm id="I_indexterm3_d1e7166" class="endofrange" startref="ch12_dpcFormhelper" significance="normal"/><indexterm id="I_indexterm3_d1e7167" class="endofrange" startref="ch12_CouchAppdocForm" significance="normal"/><indexterm id="I_indexterm3_d1e7168" class="endofrange" startref="ch12_editformJS" significance="normal"/><indexterm id="I_indexterm3_d1e7169" class="endofrange" startref="ch12_JScallbacks" significance="normal"/></para><sect2><title>Validation</title><para>Hopefully, you can see how the previous code will send a JSON
      document to CouchDB when the user clicks save. That’s great for creating
      a user interface, but it does nothing to protect the database from
      unwanted updates. This is where validation functions come into play.
      With a proper validation function, even a determined hacker cannot get
      unwanted documents into your database. Let’s look at how Sofa’s works.
      For more on validation functions, see <xref linkend="validationfunctions"/>.<indexterm id="I_indexterm3_d1e7177" significance="normal"><primary>validation functions</primary><secondary>Sofa, document saved to CouchDB</secondary></indexterm><indexterm id="I_indexterm3_d1e7182" significance="normal"><primary>documents</primary><secondary>saving</secondary><tertiary>validation</tertiary></indexterm></para><programlisting id="I_programlisting3_d1e7189" language="javascript" linenumbering="unnumbered" format="linespecific">function (newDoc, oldDoc, userCtx) {
  // !code lib/validate.js</programlisting><para>This line imports a library from Sofa that makes the rest of the
      function much more readable. It is just a wrapper around the basic
      ability to mark requests as either <phrase role="keep-together"><literal moreinfo="none">forbidden</literal> or
      <literal moreinfo="none">unauthorized</literal></phrase>. In this chapter, we’ve
      concentrated on the business logic of the validation function. Just be
      aware that unless you use Sofa’s <filename moreinfo="none">validate.js</filename>,
      you’ll need to work with the more primitive logic that the library
      abstracts.<indexterm id="I_indexterm3_d1e7203" significance="normal"><primary>requests</primary><secondary>forbidden or unauthorized</secondary></indexterm></para><programlisting id="I_programlisting3_d1e7208" language="javascript" linenumbering="unnumbered" format="linespecific">  unchanged("type");
  unchanged("author");
  unchanged("created_at");</programlisting><para>These lines do just what they say. If the document’s
      <literal moreinfo="none">type</literal>, <literal moreinfo="none">author</literal>, or
      <literal moreinfo="none">created_at</literal> fields are changed, they throw an error
      saying the update is forbidden. Note that these lines make no
      assumptions about the content of these fields. They merely state that
      updates must not change the content from one revision of the document to
      the next.</para><programlisting id="I_programlisting3_d1e7221" language="javascript" linenumbering="unnumbered" format="linespecific">  if (newDoc.created_at) dateFormat("created_at");</programlisting><para>The <literal moreinfo="none">dateFormat</literal> helper makes sure that the date
      (if one is provided) is in the format that Sofa’s views expect.</para><programlisting id="I_programlisting3_d1e7228" language="javascript" linenumbering="unnumbered" format="linespecific">  // docs with authors can only be saved by their author
  // admin can author anything...
  if (!isAdmin(userCtx) &amp;&amp; newDoc.author &amp;&amp; newDoc.author != userCtx.name) {
      unauthorized("Only "+newDoc.author+" may edit this document.");
  }</programlisting><para>If the person saving the document is an admin, let the edit
      proceed. Otherwise, make certain that the author and the person saving
      the document are the same. This ensures that authors may edit only their
      own posts.</para><programlisting id="I_programlisting3_d1e7232" language="javascript" linenumbering="unnumbered" format="linespecific">  // authors and admins can always delete
  if (newDoc._deleted) return true;</programlisting><para>The next block of code will check the validity of various types of
      documents. However, deletions will normally not be valid according to
      those specifications, because their content is just <literal moreinfo="none">_deleted:
      true</literal>, so we short-circut the validation function here.</para><programlisting id="I_programlisting3_d1e7240" language="javascript" linenumbering="unnumbered" format="linespecific">  if (newDoc.type == 'post') {
    require("created_at", "author", "body", "html", "format", "title", "slug");
    assert(newDoc.slug == newDoc._id, "Post slugs must be used as the _id.")
  }
}</programlisting><para>Finally, we have the validation for the actual post document
      itself. Here we require the fields that are particular to the post
      document. Because we’ve validated that they are present, we can count on
      them in views and user interface code.</para></sect2><sect2><title>Save Your First Post</title><para>Let’s see how this all works together! Fill out the form with some
      practice data, and hit “save” to see a success response.<indexterm id="I_indexterm3_d1e7250" significance="normal"><primary>PUT requests</primary><secondary>JSON over, to save blog post</secondary></indexterm><indexterm id="I_indexterm3_d1e7255" significance="normal"><primary>HTTP requests</primary><secondary>PUT request</secondary><tertiary>JSON over to save blog post</tertiary></indexterm><indexterm id="I_indexterm3_d1e7262" significance="normal"><primary>JSON (JavaScript Object Notation)</primary><secondary sortas="HTTP">over HTTP to save blog post
          (example)</secondary></indexterm><indexterm id="I_indexterm3_d1e7267" significance="normal"><primary>documents</primary><secondary>saving</secondary><tertiary>blog post (example)</tertiary></indexterm></para><para><xref linkend="figure_12-4"/> shows how JavaScript has used HTTP
      to <emphasis>PUT</emphasis> the document to a URL constructed of the
      database name plus the document ID. It also shows how the document is
      just sent as a JSON string in the body of the PUT request. If you were
      to <emphasis>GET</emphasis> the document URL, you’d see the same set of
      JSON data, with the addition of the <literal moreinfo="none">_rev</literal> parameter as
      applied by CouchDB.</para><figure float="none" id="figure_12-4"><title>JSON over HTTP to save the blog post</title><mediaobject id="I_mediaobject3_d1e7289"><imageobject role="print"><imagedata fileref="figs/print/codb_1204.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1204.png" format="PNG"/></imageobject></mediaobject></figure><para>To see the JSON version of the document you’ve saved, you can also
      browse to it in Futon. Visit
      <emphasis>http://127.0.0.1:5984/_utils/database.html?blog/_all_docs</emphasis>
      and you should see a document with an ID corresponding to the one you
      just saved. Click it to see what Sofa is sending to CouchDB.<indexterm id="I_indexterm3_d1e7299" class="endofrange" startref="ch12_docsaving" significance="normal"/></para></sect2></sect1><sect1 id="I_sect13_d1e7300"><title>Wrapping Up</title><para>We’ve covered how to design JSON formats for your application, how
    to enforce those designs with validation functions, and the basics of how
    documents are saved. In the next chapter, we’ll show how to load documents
    from CouchDB and display them in the browser.<indexterm id="I_indexterm3_d1e7305" class="endofrange" startref="ch12_docsstoring" significance="normal"/></para></sect1></chapter><chapter id="showingdocumentsincustomformats"><title>Showing Documents in <phrase role="keep-together">Custom
  Formats</phrase></title><para>CouchDB’s show functions are a RESTful API inspired by a similar
  feature in Lotus Notes. In a nutshell, they allow you to serve documents to
  clients, in any format you choose.<indexterm id="I_indexterm4_d1e7313" significance="normal"><primary>RESTful API</primary><secondary>CouchDB show functions</secondary></indexterm><indexterm class="startofrange" id="ch13_showfunc" significance="normal"><primary>show functions</primary></indexterm><indexterm class="startofrange" id="ch13_docsshow" significance="normal"><primary>documents</primary><secondary>showing in custom formats</secondary></indexterm></para><para>A show function builds an HTTP response with any Content-Type, based
  on a stored JSON document. For Sofa, we’ll use them to show the blog post
  permalink pages. This will ensure that these pages are indexable by search
  engines, as well as make the pages more accessible.<indexterm id="I_indexterm4_d1e7328" significance="normal"><primary>blog posts</primary><secondary>displaying with Sofa show function</secondary></indexterm> Sofa’s show function displays each blog post as an HTML page,
  with links to stylesheets and other assets, which are stored as attachments
  to Sofa’s design document.</para><para>Hey, this is great—we’ve rendered a blog post! See <xref linkend="figure_13-1"/>.</para><figure float="none" id="figure_13-1"><title>A rendered post</title><mediaobject id="I_mediaobject4_d1e7341"><imageobject role="print"><imagedata fileref="figs/print/codb_1301.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1301.png" format="PNG"/></imageobject></mediaobject></figure><para>The complete show function and template will render a static,
  cacheable resource that does not depend on details about the current user or
  anything else aside from the requested document and Content-Type. Generating
  HTML from a show function will not cause any side effects in the database,
  which has positive implications for building simple scalable
  applications.</para><sect1 id="I_sect14_d1e7348"><title>Rendering Documents with Show Functions</title><para>Let’s look at the source code. The first thing we’ll see is the
    JavaScript function body, which is very simple—it simply runs a template
    function to generate the HTML page. Let’s break it down:<indexterm class="startofrange" id="ch13_blogpostrender" significance="normal"><primary>blog posts</primary><secondary>rendering with show functions</secondary></indexterm><indexterm id="I_indexterm4_d1e7358" significance="normal"><primary>macros</primary><secondary>using in JavaScript show function</secondary></indexterm><indexterm class="startofrange" id="ch13_showfuncrender" significance="normal"><primary>show functions</primary><secondary>rendering documents with</secondary></indexterm><indexterm class="startofrange" id="ch13_docsrendershow" significance="normal"><primary>documents</primary><secondary>showing in custom formats</secondary><tertiary>rendering with show functions</tertiary></indexterm></para><programlisting id="I_programlisting4_d1e7375" language="javascript" linenumbering="unnumbered" format="linespecific">function(doc, req) {
  // !json templates.post
  // !json blog
  // !code vendor/couchapp/template.js
  // !code vendor/couchapp/path.js</programlisting><para>We’re familiar with the <literal moreinfo="none">!code</literal> and
    <literal moreinfo="none">!json</literal> macros from <xref linkend="storingdocuments"/>.
    In this case, we’re using them to import a template and some metadata
    about the blog (as JSON data), as well as to include link and template
    rendering functions as inline code.<indexterm id="I_indexterm4_d1e7387" significance="normal"><primary sortas="json macro">!json macro</primary><secondary>using with JavaScript show function</secondary></indexterm><indexterm id="I_indexterm4_d1e7392" significance="normal"><primary sortas="code macro">!code macro</primary><secondary>using with JavaScript show function</secondary></indexterm></para><para>Next, we render the template:</para><programlisting id="I_programlisting4_d1e7399" language="javascript" linenumbering="unnumbered" format="linespecific">  return template(templates.post, {
    title : doc.title,
    blogName : blog.title,
    post : doc.html,
    date : doc.created_at,
    author : doc.author,</programlisting><para>The blog post title, HTML body, author, and date are taken from the
    document, with the blog’s title included from its JSON value. The next
    three calls all use the <filename moreinfo="none">path.js</filename> library to generate
    links based on the request path. This ensures that links within the
    application are correct.</para><programlisting id="I_programlisting4_d1e7406" language="javascript" linenumbering="unnumbered" format="linespecific">    assets : assetPath(),
    editPostPath : showPath('edit', doc._id),
    index : listPath('index','recent-posts',{descending:true, limit:5})
  });
}</programlisting><para>So we’ve seen that the function body itself just calculates some
    values (based on the document, the request, and some deployment specifics,
    like the name of the database) to send to the template for rendering. The
    real action is in the HTML template. Let’s take a look.</para><sect2><title>The Post Page Template</title><para>The template defines the output HTML, with the exception of a few
      tags that are <phrase role="keep-together">replaced</phrase> with
      dynamic content. In Sofa’s case, the dynamic tags look like
      <literal moreinfo="none">&lt;%= replace_me %&gt;</literal>, which is a common templating
      tag delimiter.<indexterm id="I_indexterm4_d1e7421" significance="normal"><primary>templating tags (&lt;%= replace_me %&gt;)</primary></indexterm><indexterm id="I_indexterm4_d1e7424" significance="normal"><primary>&lt;%= replace_me %&gt; templating tags</primary></indexterm><indexterm id="I_indexterm4_d1e7427" significance="normal"><primary>templates</primary><secondary>post page template</secondary></indexterm><indexterm id="I_indexterm4_d1e7432" significance="normal"><primary>show functions</primary><secondary>rendering documents with</secondary><tertiary>post page template</tertiary></indexterm></para><para>The template engine used by Sofa is adapted from John Resig’s blog
      post, <ulink url="http://ejohn.org/blog/javascript-micro-templating/">“JavaScript
      Micro-Templating”</ulink>. It was chosen as the simplest one that worked
      in the server-side context without modification. Using a different
      template engine would be a simple exercise.</para><para>Let’s look at the template string. Remember that it is included in
      the JavaScript using the CouchApp <literal moreinfo="none">!json</literal> macro, so
      that CouchApp can handle escaping it and including it to be used by the
      templating engine.</para><programlisting id="I_programlisting4_d1e7449" language="html" linenumbering="unnumbered" format="linespecific">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;&lt;%= title %&gt; : &lt;%= blogName %&gt;&lt;/title&gt;</programlisting><para>This is the first time we’ve seen a template tag in action—the
      blog post title, as well as the name of the blog as defined in
      <filename moreinfo="none">blog.json</filename> are both used to craft the HTML
      <literal moreinfo="none">&lt;title&gt;</literal> tag.</para><programlisting id="I_programlisting4_d1e7459" language="html" linenumbering="unnumbered" format="linespecific">    &lt;link rel="stylesheet" href="../../screen.css" type="text/css"&gt;</programlisting><para>Because show functions are served from within the design document
      path, we can link to attachments on the design document using relative
      URIs. Here we’re linking to <filename moreinfo="none">screen.css</filename>, a file
      stored in the <filename moreinfo="none">_attachments</filename> folder of the Sofa
      source directory.<indexterm id="I_indexterm4_d1e7469" significance="normal"><primary>design documents</primary><secondary>show functions in</secondary><tertiary>linking to attachments</tertiary></indexterm></para><programlisting id="I_programlisting4_d1e7476" language="html" linenumbering="unnumbered" format="linespecific">  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="header"&gt;
      &lt;a id="edit" href="&lt;%= editPostPath %&gt;"&gt;Edit this post&lt;/a&gt;
      &lt;h2&gt;&lt;a href="&lt;%= index %&gt;"&gt;&lt;%= blogName %&gt;&lt;/a&gt;&lt;/h2&gt;</programlisting><para>Again, we’re seeing template tags used to replace content. In this
      case, we link to the edit page for this post, as well as to the index
      page of the blog.</para><programlisting id="I_programlisting4_d1e7480" language="html" linenumbering="unnumbered" format="linespecific">    &lt;/div&gt;
    &lt;div id="content"&gt;
      &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;
      &lt;div id="post"&gt;
        &lt;span class="date"&gt;&lt;%= date %&gt;&lt;/span&gt;</programlisting><para>The post title is used for the <literal moreinfo="none">&lt;h1&gt;</literal> tag,
      and the date is rendered in a special tag with a class of
      <literal moreinfo="none">date</literal>. See <xref linkend="sect1_dynamic_dates"/> for
      an explanation of why we output static dates in the HTML instead of
      rendering a user-friendly string like “3 days ago” to describe the
      date.<indexterm id="I_indexterm4_d1e7493" significance="normal"><primary>HTML</primary><secondary>rendering for blog posts (example)</secondary></indexterm><indexterm id="I_indexterm4_d1e7498" significance="normal"><primary>dates</primary><secondary>outputting static dates in HTML</secondary></indexterm></para><?dbfo-need height=”1in”
?><programlisting id="I_programlisting4_d1e7504" language="html" linenumbering="unnumbered" format="linespecific">        &lt;div class="body"&gt;&lt;%= post %&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</programlisting><para>In the close of the template, we render the post HTML (as
      converted from Markdown and saved from the author’s browser).<indexterm id="I_indexterm4_d1e7508" class="endofrange" startref="ch13_showfuncrender" significance="normal"/><indexterm id="I_indexterm4_d1e7509" class="endofrange" startref="ch13_docsrendershow" significance="normal"/><indexterm id="I_indexterm4_d1e7510" class="endofrange" startref="ch13_blogpostrender" significance="normal"/></para></sect2></sect1><sect1 id="sect1_dynamic_dates"><title>Dynamic Dates</title><para>When running CouchDB behind a caching proxy, this means each show
    function should have to be rendered only once per updated document.
    However, it also explains why the timestamp looks like <literal moreinfo="none">2008/12/25
    23:27:17 +0000</literal> instead of “9 days ago.”<indexterm id="I_indexterm4_d1e7519" significance="normal"><primary>documents</primary><secondary>showing in custom formats</secondary><tertiary>dynamic dates</tertiary></indexterm><indexterm id="I_indexterm4_d1e7526" significance="normal"><primary>time</primary><secondary>dynamic changes in final HTML</secondary></indexterm><indexterm id="I_indexterm4_d1e7531" significance="normal"><primary>HTML</primary><secondary>dynamic changes in final HTML, using client-side
        JavaScript</secondary></indexterm><indexterm id="I_indexterm4_d1e7536" significance="normal"><primary>JavaScript</primary><secondary>client-side, making dynamic changes in final
        HTML</secondary></indexterm><indexterm id="I_indexterm4_d1e7541" significance="normal"><primary>show functions</primary><secondary>rendering documents with</secondary><tertiary>dynamic dates</tertiary></indexterm><indexterm id="I_indexterm4_d1e7548" significance="normal"><primary>dates</primary><secondary>dynamic</secondary></indexterm></para><para>It also means that for presentation items that depend on the current
    time, or the identity of the browsing user, we’ll need to use client-side
    JavaScript to make dynamic changes to the final HTML.</para><programlisting id="I_programlisting4_d1e7555" language="javascript" linenumbering="unnumbered" format="linespecific">    $('.date').each(function() {
      $(this).text(app.prettyDate(this.innerHTML));
    });</programlisting><para>We include this detail about the browser-side JavaScript
    implementation not to teach you about Ajax, but because it epitomizes the
    kind of thinking that makes sense when you are presenting documents to
    client applications. CouchDB should provide the most useful format for the
    document, as requested by the client. But when it comes time to integrate
    information from other queries or bring the display up-to-date with other
    web services, by asking the client’s application to do the lifting, you
    move computing cycles and memory costs from CouchDB to the client. Since
    there are typically many more clients than CouchDBs, pushing the load back
    to the clients means each CouchDB can serve more users.<indexterm id="I_indexterm4_d1e7559" class="endofrange" startref="ch13_showfunc" significance="normal"/><indexterm id="I_indexterm4_d1e7560" class="endofrange" startref="ch13_docsshow" significance="normal"/></para></sect1></chapter><chapter id="viewinglistsofblogposts"><title>Viewing Lists of Blog Posts</title><para>The last few chapters dealt with getting data into and out of CouchDB.
  You learned how to model your data into documents and retrieve it via the
  HTTP API. In this chapter, we’ll look at the views used to power Sofa’s
  index page, and the list function that renders those views as HTML or XML,
  depending on the client’s request.<indexterm class="startofrange" id="ch14_viewsblogposts" significance="normal"><primary>views</primary><secondary>lists of blog posts</secondary></indexterm><indexterm class="startofrange" id="ch14_blogpostsviewing" significance="normal"><primary>blog posts</primary><secondary>viewing lists of</secondary></indexterm></para><para>Now that we’ve successfully created a blog post and rendered it as
  HTML, we’ll be building the front page where visitors will land when they’ve
  found your blog. This page will have a list of the 10 most recent blog
  posts, with titles and short summaries. The first step is to write the
  MapReduce query that constructs the index used by CouchDB at query time to
  find blog posts based on when they were written.</para><para>In <xref linkend="findingyourdatawithviews"/>, we noted that reduce
  isn’t needed for many common queries. For the index page, we’re only
  interested in an ordering of the posts by date, so we don’t need to use a
  reduce function, as the map function alone is enough to order the posts by
  date.</para><sect1 id="I_sect15_d1e7582"><title>Map of Recent Blog Posts</title><para>You’re now ready to write the map function that builds a list of all
    blog posts. The goals for this view are simple: sort all blog posts by
    date.<indexterm id="I_indexterm5_d1e7587" significance="normal"><primary>views</primary><secondary>lists of blog posts</secondary><tertiary>map of recent posts</tertiary></indexterm></para><para>Here is the source code for the view function. I’ll call out the
    important bits as we encounter them.</para><programlisting id="I_programlisting5_d1e7596" language="javascript" linenumbering="unnumbered" format="linespecific">function(doc) {
  if (doc.type == "post") {</programlisting><para>The first thing we do is ensure that the document we’re dealing with
    is a post. We don’t want comments or anything other than blog posts
    getting on the front page. The expression <literal moreinfo="none">doc.type ==
    "post"</literal> evaluates to true for posts but no other kind of
    document. In <xref linkend="validationfunctions"/>, we saw that the
    validation function gives us certain guarantees about posts, designed to
    make us comfortable about putting them on the front page of our
    blog.<indexterm id="I_indexterm5_d1e7605" significance="normal"><primary>validation functions</primary><secondary>validating blog posts</secondary></indexterm></para><programlisting id="I_programlisting5_d1e7610" language="javascript" linenumbering="unnumbered" format="linespecific">    var summary = (doc.html.replace(/&lt;(.|\n)*?&gt;/g, '').substring(0,350) + '...');</programlisting><para>This line shortens the blog post’s HTML (generated from Markdown
    before saving) and strips out most tags and images, at least well enough
    to keep them from showing up on the index page, for brevity.</para><para>The next section is the crux of the view. We’re emitting for each
    document a key (<literal moreinfo="none">doc.created_at</literal>) and a value. The key is
    used for sorting, so that we can pull out all the posts in a particular
    date range efficiently.<indexterm id="I_indexterm5_d1e7619" significance="normal"><primary>key/value pairs</primary><secondary>blog post documents</secondary></indexterm><indexterm id="I_indexterm5_d1e7624" significance="normal"><primary>dates</primary><secondary>sorting blog posts by</secondary></indexterm></para><programlisting id="I_programlisting5_d1e7629" language="javascript" linenumbering="unnumbered" format="linespecific">    emit(doc.created_at, {
      html : doc.html,
      summary : summary,
      title : doc.title,
      author : doc.author
    });</programlisting><para>The value we’ve emitted is a JavaScript object, which copies some
    fields from the document (but not all), and the summary string we’ve just
    generated. It’s preferable to avoid emitting entire documents. As a
    general rule, you want to keep your views as lean as possible. Only emit
    data you plan to use in your application. In this case we emit the summary
    (for the index page), the HTML (for the Atom feed), the blog post title,
    and its author.<indexterm id="I_indexterm5_d1e7633" significance="normal"><primary>objects</primary><secondary>recent post documents</secondary></indexterm></para><programlisting id="I_programlisting5_d1e7638" language="javascript" linenumbering="unnumbered" format="linespecific">  }
};</programlisting><para>You should be able to follow the definition of the previous map
    function just fine by now. The <literal moreinfo="none">emit()</literal> call creates an
    entry for each blog post document in our view’s result set. We’ll call the
    view <literal moreinfo="none">recent-posts</literal>. Our design document looks like this
    now:<indexterm id="I_indexterm5_d1e7649" significance="normal"><primary>design documents</primary><secondary>recent-posts view (example)</secondary></indexterm></para><programlisting id="I_programlisting5_d1e7654" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "_design/sofa",
  "views": {
    "recent-posts": {
      "map": "function(doc) { if (doc.type == "post") { ... code to emit posts ... }"
    }
  }
  "_attachments": {
    ...
  }
}</programlisting><para>CouchApp manages aggregating the filesystem files into our JSON
    design document, so we can edit our view in a file called
    <filename moreinfo="none">views/recent-posts/map.js</filename>. Once the map function is
    stored on the design document, our view is ready to be queried for the
    latest 10 posts. Again, this looks very similar to displaying a single
    post. The only real difference now is that we get back an array of JSON
    objects instead of just a single JSON object.<indexterm id="I_indexterm5_d1e7661" significance="normal"><primary>views</primary><secondary>lists of blog posts</secondary><tertiary>querying the view</tertiary></indexterm></para><para>The GET request to the URI is:</para><screen format="linespecific">/blog/_design/sofa/_view/recent-posts</screen><para>A view defined in the document
    <filename moreinfo="none">/database/_design/designdocname</filename> in the
    <literal moreinfo="none">views</literal> field ends up being callable under
    <filename moreinfo="none">/database/_design/designdocname/_view/viewname</filename>.</para><para>You can pass in HTTP query arguments to customize your view query.
    In this case, we pass in:</para><screen format="linespecific">descending: true, limit: 5</screen><para>This gets the latest post first and only the first five posts in
    all.</para><para>The actual view request URL is:</para><screen format="linespecific">/blog/_design/sofa/_view/recent-posts?descending=true&amp;limit=5</screen></sect1><sect1 id="I_sect15_d1e7693"><title>Rendering the View as HTML Using a List Function</title><para>The <literal moreinfo="none">_list</literal> function was covered in detail in <xref linkend="designdocuments"/>. In our example application, we’ll use a
    JavaScript list function to render a view of recent blog posts as both XML
    and HTML formats. CouchDB’s JavaScript view server also ships with the
    ability to respond appropriately to HTTP content negotiation and Accept
    headers.<indexterm id="I_indexterm5_d1e7703" significance="normal"><primary>formats</primary><secondary>XML and HTML for blog posts</secondary></indexterm><indexterm class="startofrange" id="ch14_HTMLview" significance="normal"><primary>HTML</primary><secondary>rendering recent blog post view as, using list
        function</secondary></indexterm><indexterm class="startofrange" id="ch14_listfuncrenderingview" significance="normal"><primary>list functions</primary><secondary>rendering recent-posts view as HTML</secondary></indexterm><indexterm class="startofrange" id="ch14_viewsrenderHTML" significance="normal"><primary>views</primary><secondary>lists of blog posts</secondary><tertiary>rendering view as HTML using list function</tertiary></indexterm></para><para>The essence of the <literal moreinfo="none">_list</literal> API is a function that
    is fed one row at a time and sends the response back one chunk at a
    time.</para><sect2><title>Sofa’s List Function</title><para>Let’s take a look at Sofa’s list function. This is a rather long
      listing, and it introduces a few new concepts, so we’ll take it slow and
      be sure to cover everything of interest.<indexterm class="startofrange" id="ch14_Sofalist" significance="normal"><primary>Sofa</primary><secondary>list function</secondary></indexterm></para><programlisting id="I_programlisting5_d1e7740" language="javascript" linenumbering="unnumbered" format="linespecific">function(head, req) {
  // !json templates.index
  // !json blog
  // !code vendor/couchapp/path.js
  // !code vendor/couchapp/date.js
  // !code vendor/couchapp/template.js
  // !code lib/atom.js</programlisting><para>The top of the function declares the arguments
      <literal moreinfo="none">head</literal> and <literal moreinfo="none">req</literal>. Our function does
      not use <literal moreinfo="none">head</literal>, just <literal moreinfo="none">req</literal>, which
      contains information about the request such as the headers sent by the
      client and a representation of the query string as sent by the client.
      The first lines of the function are CouchApp macros that pull in code
      and data from elsewhere in the design document. As we’ve described in
      more detail in <xref linkend="managingdesigndocuments"/>, these macros
      allow us to work with short, readable functions that pull in library
      code from elsewhere in the design document. Our list function uses the
      CouchApp JavaScript helpers for generating URLs
      (<filename moreinfo="none">path.js</filename>), for working with date objects
      (<filename moreinfo="none">date.js</filename>), and the template function we’re using to
      render HTML.<indexterm id="I_indexterm5_d1e7765" significance="normal"><primary>URLs</primary><secondary>generating to link to index page</secondary></indexterm><indexterm id="I_indexterm5_d1e7770" significance="normal"><primary>design documents</primary><secondary>macros pulling data from elsewhere into</secondary></indexterm><indexterm id="I_indexterm5_d1e7775" significance="normal"><primary>macros</primary><secondary>CouchApp, pulling code and data into design
          document</secondary></indexterm></para><programlisting id="I_programlisting5_d1e7780" language="javascript" linenumbering="unnumbered" format="linespecific">  var indexPath = listPath('index','recent-posts',{descending:true, limit:5});
  var feedPath = listPath('index','recent-posts',{descending:true, limit:5, 
      format:"atom"});</programlisting><para>The next two lines of the function generate URLs used to link to
      the index page itself, as well as the XML Atom feed version of it. The
      <literal moreinfo="none">listPath</literal> function is defined in
      <filename moreinfo="none">path.js</filename>—the upshot is that it knows how to link to
      lists generated by the same design document it is run from.<indexterm id="I_indexterm5_d1e7790" significance="normal"><primary>listPath( ) function</primary></indexterm><indexterm id="I_indexterm5_d1e7793" significance="normal"><primary>Atom feeds</primary><secondary>recent blog posts</secondary></indexterm><indexterm id="I_indexterm5_d1e7798" significance="normal"><primary>XML Atom feed (blog posts)</primary></indexterm></para><para>The next section of the function is responsible for rendering the
      HTML output of the blog. Refer to <xref linkend="showfunctions"/> for
      details about the API we use here. In short, clients can describe the
      format(s) they prefer in the HTTP Accept header, or in a <phrase role="keep-together"><literal moreinfo="none">format</literal> query
      parameter.</phrase> On the server, we declare which formats we provide,
      as well as assign each format a priority. In cases where the client
      accepts multiple formats, the first declared format is returned. It is
      not uncommon for browsers to accept a wide range of formats, so take
      care to put HTML at the top of the list, or else you can end up with
      browsers receiving alternate formats when they expect HTML.<indexterm id="I_indexterm5_d1e7810" significance="normal"><primary>formats</primary><secondary>specifying for blog output</secondary></indexterm><indexterm id="I_indexterm5_d1e7815" significance="normal"><primary>provides( ) function</primary></indexterm><indexterm id="I_indexterm5_d1e7818" significance="normal"><primary>show functions</primary><secondary>rendering HTML output of a blog</secondary></indexterm></para><programlisting id="I_programlisting5_d1e7823" language="javascript" linenumbering="unnumbered" format="linespecific">  provides("html", function() {</programlisting><para>The <literal moreinfo="none">provides</literal> function takes two arguments: the
      name of the format (which is keyed to a list of default MIME types) and
      a function to execute when rendering that format. Note that when using
      <literal moreinfo="none">provides</literal>, all <literal moreinfo="none">send</literal> and
      <literal moreinfo="none">getRow</literal> calls must happen within the render function.
      Now let’s look at how the HTML is actually generated.</para><programlisting id="I_programlisting5_d1e7839" language="javascript" linenumbering="unnumbered" format="linespecific">    send(template(templates.index.head, {
      title : blog.title,
      feedPath : feedPath,
      newPostPath : showPath("edit"),
      index : indexPath,
      assets : assetPath()
    }));</programlisting><para>The first thing we see is a template being run with an object that
      contains the blog title and a few relative URLs. The template function
      used by Sofa is fairly simple; it just replaces some parts of the
      template string with passed in values. In this case, the template string
      is stored in the variable <phrase role="keep-together"><literal moreinfo="none">templates.index.head</literal>,</phrase> which was
      imported using a CouchApp macro at the top of the function. The second
      argument to the template function are the values that will be inserted
      into the template; in this case, <literal moreinfo="none">title</literal>,
      <literal moreinfo="none">feedPath</literal>, <literal moreinfo="none">newPostPath</literal>,
      <literal moreinfo="none">index</literal>, and <literal moreinfo="none">assets</literal>. We’ll look at
      the template itself later in <phrase role="keep-together">this
      chapter</phrase>. For now, it’s sufficient to know that the template
      stored in <literal role="keep-together" moreinfo="none">templates.index.head</literal>
      renders the topmost portion of the HTML page, which does not change
      regardless of the contents of our recent posts view.<indexterm id="I_indexterm5_d1e7870" significance="normal"><primary>getRow( ) function</primary></indexterm></para><para>Now that we have rendered the top of the page, it’s time to loop
      over the blog posts, rendering them one at a time. The first thing we do
      is declare our variables and our loop:</para><programlisting id="I_programlisting5_d1e7876" language="javascript" linenumbering="unnumbered" format="linespecific">    var row, key;
    while (row = getRow()) {
      var post = row.value;
      key = row.key;</programlisting><para>The <literal moreinfo="none">row</literal> variable is used to store each JSON
      view row as it is sent to our function. The <literal moreinfo="none">key</literal>
      variable plays a different role. Because we don’t know ahead of time
      which of our rows will be the last row to be processed, we keep the key
      available in its own variable, to be used after all rows are rendered,
      to generate the link to the next page of results.</para><programlisting id="I_programlisting5_d1e7886" language="javascript" linenumbering="unnumbered" format="linespecific">send(template(templates.index.row, {
    title : post.title,
    summary : post.summary,
    date : post.created_at,
    link : showPath('post', row.id)
  }));
}</programlisting><para>Now that we have the row and its key safely stored, we use the
      template engine again for rendering. This time we use the template
      stored in <literal moreinfo="none">templates.index.row</literal>, with a data item that
      includes the blog post title, a URL for its page, the summary of the
      blog post we generated in our map view, and the date the post was
      created.</para><para>Once all the blog posts included in the view result have been
      listed, we’re ready to close the list and finish rendering the page. The
      last string does not need to be sent to the client using
      <literal moreinfo="none">send()</literal>, but it can be returned from the HTML
      function. Aside from that minor detail, rendering the tail template
      should be familiar by now.</para><programlisting id="I_programlisting5_d1e7898" language="javascript" linenumbering="unnumbered" format="linespecific">    return template(templates.index.tail, {
      assets : assetPath(),
      older : olderPath(key)
    });
  });</programlisting><para>Once the tail has been returned, we close the HTML generating
      function. If we didn’t care to offer an Atom feed of our blog, we’d be
      done here. But we know most readers are going to be accessing the blog
      through a feed reader or some kind of syndication, so an Atom feed is
      crucial.<indexterm id="I_indexterm5_d1e7902" significance="normal"><primary>Atom.header( ) function</primary></indexterm></para><programlisting id="I_programlisting5_d1e7905" language="javascript" linenumbering="unnumbered" format="linespecific">  provides("atom", function() {</programlisting><para>The Atom generation function is defined in just the same way as
      the HTML generation function—by being passed to
      <literal moreinfo="none">provides()</literal> with a label describing the format it
      outputs. The general pattern of the Atom function is the same as the
      HTML function: output the first section of the feed, then output the
      feed entries, and finally close the feed.</para><programlisting id="I_programlisting5_d1e7912" language="javascript" linenumbering="unnumbered" format="linespecific">    // we load the first row to find the most recent change date
    var row = getRow();</programlisting><para>One difference is that for the Atom feed, we need to know when it
      was last changed. This will normally be the time at which the first item
      in the feed was changed, so we load the first row before outputting any
      data to the client (other than HTTP headers, which are set when the
      <literal moreinfo="none">provides</literal> function picks the format). Now that we have
      the first row, we can use the date from it to set the Atom feed’s
      last-updated field.</para><programlisting id="I_programlisting5_d1e7920" language="javascript" linenumbering="unnumbered" format="linespecific">    // generate the feed header
    var feedHeader = Atom.header({
      updated : (row ? new Date(row.value.created_at) : new Date()),
      title : blog.title,
      feed_id : makeAbsolute(req, indexPath),
      feed_link : makeAbsolute(req, feedPath),
    });</programlisting><para>The <literal moreinfo="none">Atom.header</literal> function is defined in
      <filename moreinfo="none">lib/atom.js</filename>, which was imported by CouchApp at the
      top of our function. This library uses JavaScript’s E4X extension to
      generate feed XML.<indexterm id="I_indexterm5_d1e7930" significance="normal"><primary>headers</primary><secondary>generating header for Atom feed</secondary></indexterm><indexterm id="I_indexterm5_d1e7935" significance="normal"><primary>E4X extension (JavaScript)</primary></indexterm><indexterm id="I_indexterm5_d1e7938" significance="normal"><primary>JavaScript</primary><secondary>E4X extension</secondary></indexterm></para><programlisting id="I_programlisting5_d1e7943" language="javascript" linenumbering="unnumbered" format="linespecific">    // send the header to the client
    send(feedHeader);</programlisting><para>Once the feed header has been generated, sending it to the client
      uses the familiar <literal moreinfo="none">send()</literal> call. Now that we’re done
      with the header, we’ll generate each Atom entry, based on a row in the
      view. We use a slightly different loop format in this case than in the
      HTML case, as we’ve already loaded the first row in order to use its
      timestamp in the feed header.</para><programlisting id="I_programlisting5_d1e7950" language="javascript" linenumbering="unnumbered" format="linespecific">    // loop over all rows
    if (row) {
      do {</programlisting><para>The JavaScript <literal moreinfo="none">do</literal>/<literal moreinfo="none">while</literal> loop
      is similar to the <literal moreinfo="none">while</literal> loop used in the HTML
      function, except that it’s guaranteed to run at least once, as it
      evaluates the conditional statement after each iteration. This means we
      can output an entry for the row we’ve already loaded, before calling
      <literal moreinfo="none">getRow()</literal> to load the next entry.<indexterm id="I_indexterm5_d1e7966" significance="normal"><primary>JavaScript</primary><secondary>do/while loop, generating Atom entries for rows in a
          view</secondary></indexterm></para><programlisting id="I_programlisting5_d1e7971" language="javascript" linenumbering="unnumbered" format="linespecific">        // generate the entry for this row
        var feedEntry = Atom.entry({
          entry_id : makeAbsolute(req, '/' +
            encodeURIComponent(req.info.db_name) +
            '/' + encodeURIComponent(row.id)),
          title : row.value.title,
          content : row.value.html,
          updated : new Date(row.value.created_at),
          author : row.value.author,
          alternate : makeAbsolute(req, showPath('post', row.id))
        });
        // send the entry to client
        send(feedEntry);</programlisting><para>Rendering the entries also uses the Atom library in
      <filename moreinfo="none">atom.js</filename>. The big difference between the Atom
      entries and the list items in HTML, is that for our HTML screen we only
      output the summary of the entry text, but for the Atom entries we output
      the entire entry. By changing the value of <literal moreinfo="none">content</literal>
      from <literal moreinfo="none">row.value.html</literal> to
      <literal moreinfo="none">row.value.summary</literal>, you could change the Atom feed to
      only include shortened post summaries, forcing subscribers to click
      through to the actual post to read it.</para><programlisting id="I_programlisting5_d1e7987" language="javascript" linenumbering="unnumbered" format="linespecific">      } while (row = getRow());
    }</programlisting><para>As we mentioned earlier, this loop construct puts the loop
      condition at the end of the loop, so here is where we load the next row
      of the loop.</para><programlisting id="I_programlisting5_d1e7992" language="javascript" linenumbering="unnumbered" format="linespecific">    // close the loop after all rows are rendered
    return "&lt;/feed&gt;";
  });
};</programlisting><para>Once all rows have been looped over, we end the feed by returning
      the closing XML tag to the client as the last chunk of data.</para></sect2><sect2><title>The Final Result</title><para><xref linkend="figure_14-1"/> shows the final result.</para><figure float="none" id="figure_14-1"><title>The rendered index page</title><mediaobject id="I_mediaobject5_d1e8005"><imageobject role="print"><imagedata fileref="figs/print/codb_1401.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1401.png" format="PNG"/></imageobject></mediaobject></figure><para>This is our final list of blog posts. That wasn’t too hard, was
      it? We now have the front page of the blog, we know how to query single
      documents as well as views, and we know how to pass arguments to
      views.<indexterm id="I_indexterm5_d1e8012" class="endofrange" startref="ch14_Sofalist" significance="normal"/><indexterm id="I_indexterm5_d1e8013" class="endofrange" startref="ch14_listfuncrenderingview" significance="normal"/><indexterm id="I_indexterm5_d1e8014" class="endofrange" startref="ch14_viewsrenderHTML" significance="normal"/><indexterm id="I_indexterm5_d1e8015" class="endofrange" startref="ch14_HTMLview" significance="normal"/><indexterm id="I_indexterm5_d1e8016" class="endofrange" startref="ch14_viewsblogposts" significance="normal"/><indexterm id="I_indexterm5_d1e8017" class="endofrange" startref="ch14_blogpostsviewing" significance="normal"/></para></sect2></sect1></chapter></part><part id="part4"><title>Deploying CouchDB</title><chapter id="scalingbasics"><title>Scaling Basics</title><para>Scaling is an overloaded term. Finding a discrete definition is
  tricky. Everyone and her grandmother have their own idea of what scaling
  means. Most definitions are valid, but they can be contradicting. To make
  things even worse, there are a lot of misconceptions about scaling. To
  really define it, one needs a scalpel to find out the <phrase role="keep-together">important</phrase> bits.<indexterm class="startofrange" id="ch15_scaling" significance="normal"><primary>scaling</primary></indexterm></para><para>First, scaling doesn’t refer to a specific technique or technology;
  scaling, or <emphasis>scalability</emphasis>, is an attribute of a specific
  architecture. What is being <emphasis>scaled</emphasis> varies for nearly
  every project.</para><blockquote><attribution>Joe Stump, Lead Architect of Digg.com and
    SimpleGeo.com</attribution><para>Scaling is specialization.</para></blockquote><para>Joe’s quote is the one that we find to be the most accurate
  description of scaling. It is also wishy-washy, but that is the nature of
  scaling. An example: a website like Facebook.com— with a whole lot of users
  and data associated with those users and with more and more users coming in
  every day—might want to scale over user data that typically lives in a
  database. In contrast, Flickr.com at its core is like Facebook with users
  and data for users, but in Flickr’s case, the data that grows fastest is
  images uploaded by users. These images do not necessarily live in a
  database, so scaling image storage is Flickr’s path to growth.</para><note><para>It is common to think of scaling as <emphasis>scaling
    out</emphasis>. This is shortsighted. Scaling can also mean
    <emphasis>scaling in</emphasis>—that is, being able to use fewer computers
    when demand declines. More on that later.</para></note><para>These are just two services. There are a lot more, and every one has
  different things they want to scale. CouchDB is a database; we are not going
  to cover every aspect of scaling any system. We concentrate on the bits that
  are interesting to you, the CouchDB user. We have identified three general
  properties that you can scale with CouchDB:</para><?dbfo-need height=”1in”
?><itemizedlist><listitem><para>Read requests</para></listitem><listitem><para>Write requests</para></listitem><listitem><para>Data</para></listitem></itemizedlist><sect1 id="I_sect11_d1e8069"><title>Scaling Read Requests</title><para>A read request retrieves a piece of information from the database.
    It passes the following stations within CouchDB. First, the HTTP server
    module needs to accept the request. For that, it opens a socket to send
    data over. The next station is the HTTP request handle module that
    analyzes the request and directs it to the appropriate submodule in
    CouchDB. For single documents, the request then gets passed to the
    database module where the data for the document is looked up on the
    filesystem and returned all the way up again.<indexterm id="I_indexterm1_d1e8074" significance="normal"><primary>read requests</primary><secondary>scaling</secondary></indexterm><indexterm id="I_indexterm1_d1e8079" significance="normal"><primary>scaling</primary><secondary>read requests</secondary></indexterm></para><para>All this takes processing time and enough sockets (or file
    descriptors) must be available. The storage backend of the server must be
    able to fulfill all read requests. There are a few more things that can
    limit a system to accept more read requests; the basic point here is that
    a single server can process only so many concurrent requests. If your
    <phrase role="keep-together">applications</phrase> generate more requests,
    you need to set up a second server that your application can read
    from.</para><para>The nice thing about read requests is that they can be cached.
    Often-used items can be held in memory and can be returned at a much
    higher level than the one that is your bottleneck. Requests that can use
    this cache don’t ever hit your database and are thus virtually toll-free.
    <xref linkend="loadbalancing"/> explains this scenario.<indexterm id="I_indexterm1_d1e8093" significance="normal"><primary>caching</primary><secondary>read requests</secondary></indexterm></para></sect1><sect1 id="I_sect11_d1e8098"><title>Scaling Write Requests</title><para>A write request is like a read request, only a little worse. It not
    only reads a piece of data from disk, it writes it back after modifying
    it. Remember, the nice thing about reads is that they’re cacheable.
    Writes: not so much. A cache must be notified when a write changes data,
    or clients must be told to not use the cache. If you have multiple servers
    for scaling reads, a write must occur on all servers. In any case, you
    need to work harder with a write. <xref linkend="clustering"/> covers
    methods for scaling write requests across servers.<indexterm id="I_indexterm1_d1e8105" significance="normal"><primary>write requests, scaling</primary></indexterm><indexterm id="I_indexterm1_d1e8108" significance="normal"><primary>scaling</primary><secondary>write requests</secondary></indexterm></para></sect1><sect1 id="I_sect11_d1e8114"><?dbfo-need height=”3in”
?><title>Scaling Data</title><para>The third way of scaling is scaling data. Today’s hard drives are
    cheap and have a lot of capacity, and they will only get better in the
    future, but there is only so much data a single server can make sensible
    use of. It must maintain one more indexes to the data that uses disk space
    again. Creating backups will take longer and other maintenance tasks
    become a pain.<indexterm id="I_indexterm1_d1e8120" significance="normal"><primary>scaling</primary><secondary>data</secondary></indexterm><indexterm id="I_indexterm1_d1e8125" significance="normal"><primary>data, scaling</primary></indexterm></para><para>The solution is to chop the data into manageable chunks and put each
    chunk on a separate server. All servers with a chunk now form a
    <emphasis>cluster</emphasis> that holds all your data. <xref linkend="clustering"/> takes a look at creating and using these
    clusters.</para><para>While we are taking separate looks at scaling of reads, writes, and
    data, these rarely occur isolated. Decisions to scale one will affect the
    others. We will describe individual as well as combined solutions in the
    following chapters.</para></sect1><sect1 id="I_sect11_d1e8137"><title>Basics First</title><para>Replication is the basis for all of the three scaling methods.
    Before we go scaling, <xref linkend="replication"/> will familiarize you
    with CouchDB’s excellent replication feature.<indexterm id="I_indexterm1_d1e8144" class="endofrange" startref="ch15_scaling" significance="normal"/></para></sect1></chapter><chapter id="replication"><title>Replication</title><para>This chapter introduces CouchDB’s world-class replication system.
  Replication synchronizes two copies of the same database, allowing users to
  have low latency access data no matter where they are. These databases can
  live on the same server or on two different servers—CouchDB doesn’t make a
  distinction. If you change one copy of the database, replication will send
  these changes to the other copy.<indexterm class="startofrange" id="ch16_replication" significance="normal"><primary>replication</primary></indexterm></para><para>Replication is a one-off operation: you send an HTTP request to
  CouchDB that includes a <emphasis>source</emphasis> and a
  <emphasis>target</emphasis> database, and CouchDB will send the changes from
  the source to the target. That is all. Granted, calling something
  world-class and then only needing one sentence to explain it does seem odd.
  But part of the reason why CouchDB’s replication is so powerful lies in its
  simplicity.</para><para>Let’s see what replication looks like:</para><screen format="linespecific">POST /_replicate HTTP/1.1
{"source":"database","target":"http://example.org/database"}</screen><para>This call sends all the documents in the local database
  <literal moreinfo="none">database</literal> to the remote database
  <literal moreinfo="none">http://example.org/database</literal>. A database is considered
  “local” when it is on the same CouchDB instance you send the <literal moreinfo="none">POST
  /_replicate</literal> HTTP request to. All other instances of CouchDB are
  “remote.”<indexterm id="I_indexterm2_d1e8176" significance="normal"><primary>databases</primary><secondary>local and remote</secondary></indexterm></para><para>If you want to send changes from the target to the source database,
  you just make the same HTTP requests, only with source and target database
  swapped. That is all.</para><screen format="linespecific">POST /_replicate HTTP/1.1
{"source":"http://example.org/database","target":"database"}</screen><para>A remote database is identified by the same URL you use to talk to it.
  CouchDB replication works over HTTP using the same mechanisms that are
  available to you. This example shows that replication is a
  <emphasis>unidirectional</emphasis> process. Documents are copied from one
  database to another and not automatically vice versa. If you want
  <emphasis>bidirectional</emphasis> replication, you need to trigger two
  replications with <emphasis>source</emphasis> and
  <emphasis>target</emphasis> swapped.<indexterm id="I_indexterm2_d1e8199" significance="normal"><primary>bidirectional replication</primary></indexterm><indexterm id="I_indexterm2_d1e8202" significance="normal"><primary>unidirectional replication</primary></indexterm></para><sect1 id="I_sect12_d1e8205"><title>The Magic</title><para>When you ask CouchDB to replicate one database to another, it will
    go and compare the two databases to find out which documents on the source
    differ from the target and then submit a batch of the changed documents to
    the target until all changes are transferred. Changes include new
    documents, changed documents, and deleted documents. Documents that
    already exist on the target in the same revision are not transferred; only
    newer revisions are.<indexterm id="I_indexterm2_d1e8210" significance="normal"><primary>replication</primary><secondary>sequence numbers for database changes</secondary></indexterm></para><para>Databases in CouchDB have a <emphasis>sequence number</emphasis>
    that gets incremented every time the database is changed. CouchDB
    remembers what changes came with which sequence number. That way, CouchDB
    can answer questions like, “What changed in database A between sequence
    number 212 and now?” by returning a list of new and changed documents.
    Finding the differences between databases this way is an efficient
    operation. It also adds to the robustness of replication.<indexterm id="I_indexterm2_d1e8220" significance="normal"><primary>databases</primary><secondary>sequence number</secondary></indexterm><indexterm id="I_indexterm2_d1e8225" significance="normal"><primary>sequence numbers in databases</primary></indexterm></para><note><para>CouchDB views use the same mechanism when determining when a view
      needs updating and which documents to replication. You can use this to
      build your own solutions as well.</para></note><para>You can use replication on a single CouchDB instance to create
    snapshots of your databases to be able to test code changes without
    risking data loss or to be able to refer back to older states of your
    database. But replication gets really fun if you use two or more different
    computers, potentially geographically spread out.</para><para>With different servers, potentially hundreds or thousands of miles
    apart, problems are bound to happen. Servers crash, network connections
    break off, things go wrong. When a replication process is interrupted, it
    leaves two replicating CouchDBs in an inconsistent state. Then, when the
    problems are gone and you trigger replication again, it continues where it
    left off.</para></sect1><sect1 id="I_sect12_d1e8235"><title>Simple Replication with the Admin Interface</title><para>You can run replication from your web browser using Futon, CouchDB’s
    built-in administration interface. Start CouchDB and open your browser to
    <filename moreinfo="none">http://127.0.0.1:5984/_utils/</filename>. On the righthand side,
    you will see a list of things to visit in Futon. Click on
    “Replication.”<indexterm id="I_indexterm2_d1e8243" significance="normal"><primary>Futon</primary><secondary>running replication with</secondary></indexterm><indexterm id="I_indexterm2_d1e8248" significance="normal"><primary>replication</primary><secondary>using Futon admin interface</secondary></indexterm></para><para>Futon will show you an interface to start replication. You can
    specify a source and a target by either picking a database from the list
    of local databases or filling in the URL of a remote database.</para><para>Click on the Replicate button, wait a bit, and have a look at the
    lower half of the screen where CouchDB gives you some statistics about the
    replication run or, if an error <phrase role="keep-together">occurred</phrase>, an explanatory message.</para><para>Congratulations—you ran your first replication.</para></sect1><sect1 id="I_sect12_d1e8263"><title>Replication in Detail</title><para>So far, we’ve skipped over the result from a replication request.
    Now is a good time to look at it in detail. Here’s a nicely formatted
    example:<indexterm id="I_indexterm2_d1e8268" significance="normal"><primary>replication</primary><secondary>details of</secondary></indexterm></para><programlisting id="I_programlisting2_d1e8273" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "ok": true,
  "source_last_seq": 10,
  "session_id": "c7a2bbbf9e4af774de3049eb86eaa447",
  "history": [
    {
      "session_id": "c7a2bbbf9e4af774de3049eb86eaa447",
      "start_time": "Mon, 24 Aug 2009 09:36:46 GMT",
      "end_time": "Mon, 24 Aug 2009 09:36:47 GMT",
      "start_last_seq": 0,
      "end_last_seq": 1,
      "recorded_seq": 1,
      "missing_checked": 0,
      "missing_found": 1,
      "docs_read": 1,
      "docs_written": 1,
      "doc_write_failures": 0,
    }
  ]
}</programlisting><para>The <literal moreinfo="none">"ok": true</literal> part, similar to other responses,
    tells us everything went well. <literal moreinfo="none">source_last_seq</literal> includes
    the source’s <literal moreinfo="none">update_seq</literal> value that was considered by
    this replication. Each replication request is assigned a
    <literal moreinfo="none">session_id</literal>, which is just a UUID; you can also talk
    about a <emphasis>replication session</emphasis> identified by this
    ID.<indexterm id="I_indexterm2_d1e8293" significance="normal"><primary>update_seq values</primary></indexterm><indexterm id="I_indexterm2_d1e8296" significance="normal"><primary>session_id (replication)</primary></indexterm><indexterm id="I_indexterm2_d1e8299" significance="normal"><primary>replication sessions</primary></indexterm><indexterm id="I_indexterm2_d1e8302" significance="normal"><primary>source_last_seq field</primary></indexterm></para><para>The next bit is the replication <emphasis>history</emphasis>.
    CouchDB maintains a list of history sessions for future reference. The
    history array is currently capped at 50 entries. Each unique replication
    trigger object (the JSON string that includes the source and target
    databases as well as potential options) gets its own history. Let’s see
    what a history entry is all about.</para><para>The <literal moreinfo="none">session_id</literal> is recorded here again for
    convenience. The start and end time for the replication session are
    recorded. The <literal moreinfo="none">_last_seq</literal> denotes the
    <literal moreinfo="none">update_seq</literal>s that were valid at the beginning and the
    end of the session. <literal moreinfo="none">recorded_seq</literal> is the
    <literal moreinfo="none">update_seq</literal> of the target again. It’s different from
    <literal moreinfo="none">end_last_seq</literal> if a replication process dies in the
    middle and is restarted. <literal moreinfo="none">missing_checked</literal> is the number
    of docs on the target that are already there and don’t need to be
    replicated. <literal moreinfo="none">missing_found</literal> is the number of missing
    documents on the source.</para><para>The last three—<literal moreinfo="none">docs_read</literal>,
    <literal moreinfo="none">docs_written</literal>, and
    <literal moreinfo="none">doc_write_failures</literal>—show how many documents we read from
    the source, wrote to the target, and how many failed. If all is well,
    <literal moreinfo="none">_read</literal> and <literal moreinfo="none">_written</literal> are identical and
    <literal moreinfo="none">doc_write_failures</literal> is 0. If not, you know something
    went wrong during replication. Possible failures are a server crash on
    either side, a lost network connection, or a
    <literal moreinfo="none">validate_doc_update</literal> function rejecting a document
    write.<indexterm id="I_indexterm2_d1e8361" significance="normal"><primary>validate_doc_update function</primary><secondary>rejecting a document write</secondary></indexterm><indexterm id="I_indexterm2_d1e8366" significance="normal"><primary>docs_written field</primary></indexterm><indexterm id="I_indexterm2_d1e8369" significance="normal"><primary>docs_read field</primary></indexterm><indexterm id="I_indexterm2_d1e8372" significance="normal"><primary>doc_write_failures field</primary></indexterm></para><para>One common scenario is triggering replication on nodes that have
    admin accounts enabled. Creating design documents is restricted to admins,
    and if the replication is triggered without admin credentials, writing the
    design documents during replication will fail and be recorded as
    <literal moreinfo="none">doc_write_failures</literal>. If you have admins, be sure to
    include the credentials in the replication request:<indexterm id="I_indexterm2_d1e8380" significance="normal"><primary>admin accounts</primary><secondary>replication requests and</secondary></indexterm></para><screen format="linespecific">&gt; curl -X POST http://127.0.0.1:5984/_replicate \
  -d '{"source":"http://example.org/database", \
       "target":"http://admin:password@e127.0.0.1:5984/database"}'</screen></sect1><sect1 id="I_sect12_d1e8387"><title>Continuous Replication</title><para>Now that you know how replication works under the hood, we share a
    neat little trick. When you add <literal moreinfo="none">"continuous":true</literal> to
    the replication trigger object, CouchDB will not stop after replicating
    all missing documents from the source to the target. It will listen on
    CouchDB’s <literal moreinfo="none">_changes</literal> API (see <xref linkend="changenotifications"/>) and automatically replicate over any new
    docs as they come into the source to the target. In fact, they are not
    replicated right away; there’s a complex algorithm determining the ideal
    moment to replicate for maximum performance. The algorithm is complex and
    is fine-tuned every once in a while, and documenting it here wouldn’t make
    much sense.<indexterm id="I_indexterm2_d1e8400" significance="normal"><primary sortas="changes API">_changes API</primary></indexterm><indexterm id="I_indexterm2_d1e8403" significance="normal"><primary>continuous replication</primary></indexterm><indexterm id="I_indexterm2_d1e8406" significance="normal"><primary>replication</primary><secondary>continuous</secondary></indexterm></para><screen format="linespecific">&gt; curl -X POST http://127.0.0.1:5984/_replicate \
  -d '{"source":"db", "target":"db-replica", "continuous":true}'</screen><para>At the time of writing, CouchDB doesn’t remember continuous
    replications over a server restart. For the time being, you are required
    to trigger them again when you restart CouchDB. In the future, CouchDB
    will allow you to define permanent continuous replications that survive a
    server restart without you having to do anything.</para></sect1><sect1 id="I_sect12_d1e8415"><title>That’s It?</title><para>Replication is the foundation on which the following chapters build
    on. Make sure you have understood this chapter. If you don’t feel
    comfortable yet, just read it again and play around with the replication
    interface in Futon.</para><para>We haven’t yet told you everything about replication. The next
    chapters show you how to manage replication conflicts (see <xref linkend="conflictmanagement"/>), how to use a set of synchronized CouchDB
    instances for load balancing (see <xref linkend="loadbalancing"/>), and
    how to build a cluster of CouchDBs that can handle more data or write
    requests than a single node (see <xref linkend="clustering"/>).<indexterm id="I_indexterm2_d1e8428" class="endofrange" startref="ch16_replication" significance="normal"/></para></sect1></chapter><chapter id="conflictmanagement"><title>Conflict Management</title><para>Suppose you are sitting in a coffee shop working on your book. J.
  Chris comes over and tells you about his new phone. The new phone came with
  a new number, and you have J. Chris dictate it while you change it using
  your laptop’s address book application.<indexterm class="startofrange" id="ch17_conflictmanage" significance="normal"><primary>conflict management</primary></indexterm></para><para>Luckily, your address book is built on CouchDB, so when you come home,
  all you need to do to get your home computer up-to-date with J. Chris’s
  number is replicate your address book from your laptop. Neat, eh? What’s
  more, CouchDB has a mechanism to maintain continuous replication, so you can
  keep a whole set of computers in sync with the same data, whenever a network
  connection is available.</para><para>Let’s change the scenario a little bit. Since J. Chris didn’t
  anticipate meeting you at the coffee shop, he also sent you an email with
  the new number. At the time you weren’t using WiFi because you wanted
  concentrate on your work, so you didn’t read his email until you got home.
  But it was a long day and by then you had forgotten that you changed the
  number in the address book on your laptop. When you read the email at home,
  you simply copy-and-pasted the number into the address book on your home
  computer. Now—and here’s the twist—it turns out you entered the wrong number
  in your laptop’s address book.</para><para>You now have a document in each of the databases that has different
  information. This situation is called a <emphasis>conflict</emphasis>.
  Conflicts occur in distributed systems. They are a natural state of your
  data. How does CouchDB’s replication system deal with conflicts?<indexterm id="I_indexterm3_d1e8446" significance="normal"><primary>conflicts, defined</primary></indexterm></para><para>When you replicate two databases in CouchDB and you have conflicting
  changes, CouchDB will detect this and will flag the affected document with
  the special attribute <literal moreinfo="none">"_conflicts":true</literal>. Next, CouchDB
  determines which of the changes will be stored as the latest revision
  (remember, documents in CouchDB are versioned). The version that gets picked
  to be the latest revision is the <emphasis>winning revision</emphasis>. The
  <emphasis>losing revision</emphasis> gets stored as the previous
  revision.<indexterm id="I_indexterm3_d1e8460" significance="normal"><primary>revisions</primary><secondary>conflicts in, winning and losing revisions</secondary></indexterm><indexterm id="I_indexterm3_d1e8465" significance="normal"><primary>replication</primary><secondary>conflict detection and resolution</secondary></indexterm></para><para>CouchDB does not attempt to merge the conflicting revision. Your
  application dictates how the merging should be done. The choice of picking
  the winning revision is <phrase role="keep-together">arbitrary.</phrase> In
  the case of the phone number, there is no way for a computer to decide on
  the <emphasis>right</emphasis> revision. This is not specific to CouchDB; no
  other software can do this (ever had your phone’s sync-contacts tool ask you
  which contact from which source to take?).</para><para>Replication guarantees that conflicts are detected and that each
  instance of CouchDB makes the same choice regarding winners and losers,
  independent of all the other instances. There is no group decision made;
  instead, a deterministic algorithm determines the order of the conflicting
  revision. After replication, all instances taking part have the same data.
  The data set is said to be in a <emphasis>consistent state</emphasis>. If
  you ask any instance for a document, you will get the same answer regardless
  which one you ask.</para><para>Whether or not CouchDB picked the version that your application needs,
  you need to go and resolve the conflict, just as you need to resolve a
  conflict in a version control system like Subversion. Simply create a
  version that you want to be the latest by either picking the latest, or the
  previous, or both (by merging them) and save it as the now latest revision.
  Done. Replicate again and your resolution will populate over to all other
  instances of CouchDB. Your conflict resolving on one node could lead to
  further conflicts, all of which will need to be addressed, but eventually,
  you will end up with a conflict-free database on all nodes.</para><sect1 id="I_sect13_d1e8485"><title>The Split Brain</title><para>This is an interesting conflicts scenario in that we helped a BBC
    build a solution for it that is now in production. The basic setup is
    this: to guarantee that the company’s website is online 24/7, even in the
    event of the loss of a data center, it has multiple data centers backing
    up the website. The “loss” of a data center is a rare occasion, but it can
    be as simple as a network outage, where the data center is still alive and
    well but can’t be reached by anyone.<indexterm id="I_indexterm3_d1e8490" significance="normal"><primary>conflict management</primary><secondary>split brain scenario</secondary></indexterm></para><para>The “split brain” scenario is where two (for simplicity’s sake we’ll
    stick to two) data centers are up and well connected to end users, but the
    connection between the data centers—which is most likely not the same
    connection that end users use to talk to the computers in the data
    center—fails.</para><para>The inter data center connection is used to keep both centers
    <emphasis>in sync</emphasis> so that either one can take over for the
    other in case of a failure. If that link goes down, you end up with two
    halves of a system that act independently—the split brain.</para><para>As long as all end users can get to their data, the split brain is
    not scary. Resolving the split brain situation by bringing up the
    connection that links the data centers and starting synchronization again
    is where it gets hairy. Arbitrary conflict resolution, like CouchDB does
    by default, can lead to unwanted effects on the user’s side. Data could
    revert to an earlier stage and leave the impression that changes weren’t
    reliably saved, when in fact they were.</para></sect1><sect1 id="I_sect13_d1e8504"><title>Conflict Resolution by Example</title><para>Let’s go through an illustrated example of how conflicts emerge and
    how to solve them in super slow motion. <xref linkend="figure_17-1"/>
    illustrates the basic setup: we have two CouchDB databases, and we are
    replicating from database A to database B. To keep this simple, we assume
    triggered replication and not continuous replication, and we don’t
    replicate back from database B to A. All other replication scenarios can
    be reduced to this setup, so this explains everything we need to
    know.<indexterm class="startofrange" id="ch17_replicationconflicts" significance="normal"><primary>replication</primary><secondary>conflict management by example</secondary></indexterm><indexterm class="startofrange" id="ch17_conflictmanageexamples" significance="normal"><primary>conflict management</primary><secondary>resolution by example</secondary></indexterm></para><figure float="none" id="figure_17-1"><title>Conflict management by example: step 1</title><mediaobject id="I_mediaobject3_d1e8524"><imageobject role="print"><imagedata fileref="figs/print/codb_1701.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1701.png" format="PNG"/></imageobject></mediaobject></figure><para>We start out by creating a document in database A (<xref linkend="figure_17-2"/>). Note the clever use of imagery to identify a
    specific revision of a document. Since we are not using continuous
    replication, database B won’t know about the new document for now.</para><figure float="none" id="figure_17-2"><title>Conflict management by example: step 2</title><mediaobject id="I_mediaobject3_d1e8536"><imageobject role="print"><imagedata fileref="figs/print/codb_1702.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1702.png" format="PNG"/></imageobject></mediaobject></figure><para>We now trigger replication and tell it to use database A as the
    source and database B as the target (<xref linkend="figure_17-3"/>). Our
    document gets copied over to database B. To be precise, the latest
    revision of our document gets copied over.</para><figure float="none" id="figure_17-3"><title>Conflict management by example: step 3</title><mediaobject id="I_mediaobject3_d1e8548"><imageobject role="print"><imagedata fileref="figs/print/codb_1703.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1703.png" format="PNG"/></imageobject></mediaobject></figure><para>Now we go to database B and update the document (<xref linkend="figure_17-4"/>). We change some values and upon change, CouchDB
    generates a new revision for us. Note that this revision has a new image.
    Node A is ignorant of any activity.</para><figure float="none" id="figure_17-4"><title>Conflict management by example: step 4</title><mediaobject id="I_mediaobject3_d1e8560"><imageobject role="print"><imagedata fileref="figs/print/codb_1704.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1704.png" format="PNG"/></imageobject></mediaobject></figure><para>Now we make a change to our document in database A by changing some
    other values (<xref linkend="figure_17-5"/>). See how it makes a
    different image for us to see the difference? It is important to note that
    this is still the same document. It’s just that there are two different
    revisions of that same document in each database.</para><figure float="none" id="figure_17-5"><title>Conflict management by example: step 5</title><mediaobject id="I_mediaobject3_d1e8572"><imageobject role="print"><imagedata fileref="figs/print/codb_1705.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1705.png" format="PNG"/></imageobject></mediaobject></figure><para>Now we trigger replication again from database A to database B as
    before (<xref linkend="figure_17-6"/>). By the way, it doesn’t make a
    difference if the two databases live in the same CouchDB server or on
    different servers connected over a network. <figure float="none" id="figure_17-6"><title>Conflict management by example: step 6</title><mediaobject id="I_mediaobject3_d1e8585"><imageobject role="print"><imagedata fileref="figs/print/codb_1706.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1706.png" format="PNG"/></imageobject></mediaobject></figure> When replicating, CouchDB detects that there are two different
    revisions for the same document, and it creates a conflict (<xref linkend="figure_17-7"/>). A document conflict means that there are now
    two latest revisions for this document.</para><figure float="none" id="figure_17-7"><title>Conflict management by example: step 7</title><mediaobject id="I_mediaobject3_d1e8596"><imageobject role="print"><imagedata fileref="figs/print/codb_1707.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1707.png" format="PNG"/></imageobject></mediaobject></figure><para>Finally, we tell CouchDB which version we would like to be the
    latest revision by resolving the conflict (<xref linkend="figure_17-8"/>). Now both databases have the same data.</para><figure float="none" id="figure_17-8"><title>Conflict management by example: step 8</title><mediaobject id="I_mediaobject3_d1e8608"><imageobject role="print"><imagedata fileref="figs/print/codb_1708.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_1708.png" format="PNG"/></imageobject></mediaobject></figure><para>Other possible outcomes include choosing the other revision and
    replicating that decision back to database A, or creating yet another
    revision in database B that includes parts of both conflicting revisions
    (a <emphasis>merge</emphasis>) and replicating that back to database
    A.<indexterm id="I_indexterm3_d1e8618" class="endofrange" startref="ch17_replicationconflicts" significance="normal"/><indexterm id="I_indexterm3_d1e8619" class="endofrange" startref="ch17_conflictmanageexamples" significance="normal"/></para></sect1><sect1 id="I_sect13_d1e8621"><title>Working with Conflicts</title><para>Now that we’ve walked through replication with pretty pictures,
    let’s get our hands dirty and see what the API calls and responses for
    this and other scenarios look like. We’ll be continuing <xref linkend="thecoreapi"/> by using <literal moreinfo="none">curl</literal> on the command
    line to make raw API requests.<indexterm class="startofrange" id="ch17_replconflictsworking" significance="normal"><primary>replication</primary><secondary>working with conflicts</secondary></indexterm><indexterm class="startofrange" id="ch17_conflictmanageworking" significance="normal"><primary>conflict management</primary><secondary>working with conflicts</secondary></indexterm></para><para>First, we create two databases that we can use for replication.
    These live on the same CouchDB instance, but they might as well live on a
    remote instance—CouchDB doesn’t care. To save us some typing, we create a
    shell variable for our CouchDB base URL that we want to talk to. We then
    create two databases, <literal moreinfo="none">db</literal> and
    <literal moreinfo="none">db-replica</literal>:</para><?dbfo-need height=”1in”
?><screen format="linespecific">HOST="http://127.0.0.1:5984"

&gt; curl -X PUT $HOST/db
{"ok":true}

&gt; curl -X PUT $HOST/db-replica
{"ok":true}</screen><para>In the next step, we create a simple document
    <literal moreinfo="none">{"count":1}</literal> in <literal moreinfo="none">db</literal> and trigger
    replication to <literal moreinfo="none">db-replica</literal>:</para><screen format="linespecific">curl -X PUT $HOST/db/foo -d '{"count":1}'
{"ok":true,"id":"foo","rev":"1-74620ecf527d29daaab9c2b465fbce66"}

curl -X POST $HOST/_replicate 
-d '{"source":"db","target":"http://127.0.0.1:5984/db-replica"}'
{"ok":true,...,"docs_written":1,"doc_write_failures":0}]}</screen><para>We skip a bit of the output of the replication session (see <xref linkend="replication"/> for details). If you see
    <literal moreinfo="none">"docs_written":1</literal> and
    <literal moreinfo="none">"doc_write_failures":0</literal>, our document made it over to
    <literal role="keep-together" moreinfo="none">db-replica</literal>. We now update the
    document to <literal moreinfo="none">{"count":2}</literal> in
    <literal moreinfo="none">db-replica</literal>. Note that we now need to include the
    correct <literal moreinfo="none">_rev</literal> property.<indexterm id="I_indexterm3_d1e8688" significance="normal"><primary sortas="rev property">_rev property</primary></indexterm></para><screen format="linespecific">&gt; curl -X PUT $HOST/db-replica/foo 
-d '{"count":2,"_rev":"1-74620ecf527d29daaab9c2b465fbce66"}'
{"ok":true,"id":"foo","rev":"2-de0ea16f8621cbac506d23a0fbbde08a"}</screen><para>Next, we create the conflict! We change our document on
    <literal moreinfo="none">db</literal> to <literal moreinfo="none">{"count":3}</literal>. Our document is
    now logically in conflict, but CouchDB doesn’t know about it until we
    replicate again:</para><screen format="linespecific">&gt; curl -X PUT $HOST/db/foo 
-d '{"count":3,"_rev":"1-74620ecf527d29daaab9c2b465fbce66"}'
{"ok":true,"id":"foo","rev":"2-7c971bb974251ae8541b8fe045964219"}

&gt; curl -X POST $HOST/_replicate 
-d '{"source":"db","target":"http://127.0.0.1:5984/db-replica"}'
{"ok":true,..."docs_written":1,"doc_write_failures":0}]}</screen><para>To see that we have a conflict, we create a simple view in
    <literal moreinfo="none">db-replica</literal>. The map function looks like this:<indexterm id="I_indexterm3_d1e8709" significance="normal"><primary>views</primary><secondary>creating view for conflicts</secondary></indexterm></para><programlisting id="I_programlisting3_d1e8714" language="javascript" linenumbering="unnumbered" format="linespecific">function(doc) {
  if(doc._conflicts) {
    emit(doc._conflicts, null);
  }
}</programlisting><para>When we query this view, we get this result:</para><programlisting id="I_programlisting3_d1e8718" language="javascript" linenumbering="unnumbered" format="linespecific">{"total_rows":1,"offset":0,"rows":[
{"id":"foo","key":["2-7c971bb974251ae8541b8fe045964219"],"value":null}
]}</programlisting><para>The <literal moreinfo="none">key</literal> here corresponds to the
    <literal moreinfo="none">doc._conflicts</literal> property of our document in <phrase role="keep-together"><literal moreinfo="none">db-replica</literal></phrase>. It is an array listing all
    <emphasis>conflicting revisions</emphasis>. We see that the revision we
    wrote on <literal moreinfo="none">db</literal> (<literal moreinfo="none">{"count":3}</literal>) is in
    conflict. CouchDB’s automatic promotion of one revision to be the winning
    revision chose our first change (<literal moreinfo="none">{"count":2}</literal>). To
    verify that, we just request that document from
    <literal moreinfo="none">db-replica</literal>:<indexterm id="I_indexterm3_d1e8748" significance="normal"><primary>revisions</primary><secondary>conflicting</secondary></indexterm><indexterm id="I_indexterm3_d1e8753" significance="normal"><primary>conflicting revisions</primary></indexterm></para><screen format="linespecific">&gt; curl -X GET $HOST/db-replica/foo
{"_id":"foo","_rev":"2-de0ea16f8621cbac506d23a0fbbde08a","count":2}</screen><para>To resolve the conflict, we need to determine which one we want to
    keep.</para><sidebar id="I_sidebar3_d1e8760"><title>How Does CouchDB Decide Which Revision to Use?</title><para>CouchDB guarantees that each instance that sees the same conflict
      comes up with the same winning and losing revisions. It does so by
      running a deterministic algorithm to pick the winner. The application
      should not rely on the details of this algorithm and must always resolve
      conflicts. We’ll tell you how it works anyway.</para><para>Each revision includes a list of previous revisions. The revision
      with the longest revision history list becomes the winning revision. If
      they are the same, the <literal moreinfo="none">_rev</literal> values are compared in
      ASCII sort order, and the highest wins. So, in our example, <literal role="keep-together" moreinfo="none">2-de0ea16f8621cbac506d23a0fbbde08a</literal> beats
      <literal role="keep-together" moreinfo="none">2-7c971bb974251ae8541b8fe045964219</literal>.</para><para>One advantage of this algorithm is that CouchDB nodes do not have
      to talk to each other to agree on winning revisions. We already learned
      that the network is prone to errors and avoiding it for conflict
      resolution makes CouchDB very robust.</para></sidebar><para>Let’s say we want to keep the highest value. This means we don’t
    agree with CouchDB’s automatic choice. To do this, we first overwrite the
    target document with our value and then simply delete the revision we
    don’t like:</para><screen format="linespecific">curl -X DELETE $HOST/db-replica/foo?rev=2-de0ea16f8621cbac506d23a0fbbde08a
{"ok":true,"id":"foo","rev":"3-bfe83a296b0445c4d526ef35ef62ac14"}

curl -X PUT $HOST/db-replica/foo 
-d '{"count":3,"_rev":"2-7c971bb974251ae8541b8fe045964219"}'
{"ok":true,"id":"foo","rev":"3-5d0319b075a21b095719bc561def7122"}</screen><para>CouchDB creates yet another revision that reflects our decision.
    Note that the <literal moreinfo="none">3-</literal> didn’t get incremented this time. We
    didn’t create a new version of the document body; we just deleted a
    conflicting revision. To see that all is well, we check whether our
    revision ended up in the document.</para><screen format="linespecific">curl GET $HOST/db-replica/foo
{"_id":"foo","_rev":"3-5d0319b075a21b095719bc561def7122","count":3}</screen><para>We also verify that our document is no longer in conflict by
    querying our conflicts view again, and we see that there are no more
    conflicts:</para><screen format="linespecific">{"total_rows":0,"offset":0,"rows":[]}</screen><para>Finally, we replicate from <literal moreinfo="none">db-replica</literal> back to
    <literal moreinfo="none">db</literal> by simply swapping <literal moreinfo="none">source</literal> and
    <phrase role="keep-together"><literal moreinfo="none">target</literal></phrase> in our request to
    <literal moreinfo="none">_replicate</literal>:</para><screen format="linespecific">curl -X POST $HOST/_replicate 
-d '{"target":"db","source":"http://127.0.0.1:5984/db-replica"}'</screen><para>We see that our revision ends up in <literal moreinfo="none">db</literal>,
    too:</para><screen format="linespecific">curl GET $HOST/db/foo
{"_id":"foo","_rev":"3-5d0319b075a21b095719bc561def7122","count":3}</screen><para>And we’re done.<indexterm id="I_indexterm3_d1e8823" class="endofrange" startref="ch17_replconflictsworking" significance="normal"/><indexterm id="I_indexterm3_d1e8824" class="endofrange" startref="ch17_conflictmanageworking" significance="normal"/></para></sect1><sect1 id="I_sect13_d1e8825"><title>Deterministic Revision IDs</title><para>Let’s have a look at this revision ID:
    <literal moreinfo="none">3-5d0319b075a21b095719bc561def7122</literal>. Parts of the format
    might look familiar. The first part is an integer followed by a dash
    (<literal moreinfo="none">3-</literal>). The integer increments for each new revision the
    document receives. Updates to the same document on multiple instances
    create their own independent increments. When replicating, CouchDB knows
    that there are two different revisions (like in our previous example) by
    looking at the second part.<indexterm id="I_indexterm3_d1e8836" significance="normal"><primary>conflict management</primary><secondary>deterministic revision IDs</secondary></indexterm><indexterm id="I_indexterm3_d1e8841" significance="normal"><primary>revisions</primary><secondary>deterministic revision IDs</secondary></indexterm></para><para>The second part is an md5-hash over a set of document properties:
    the JSON body, the attachments, and the <literal moreinfo="none">_deleted</literal> flag.
    This allows CouchDB to save on replication time in case you make the same
    change to the same document on two instances. Earlier versions (0.9 and
    back) used random integers to specify revisions, and making the same
    change on two instances would result in two different revision IDs,
    creating a conflict where it was not really necessary. CouchDB 0.10 and
    above uses deterministic revision IDs using the md5 hash.</para><para>For example, let’s create two documents, <literal moreinfo="none">a</literal> and
    <literal moreinfo="none">b</literal>, with the same contents:</para><screen format="linespecific">curl -X PUT $HOST/db/a -d '{"a":1}'
{"ok":true,"id":"a","rev":"1-23202479633c2b380f79507a776743d5"}

&gt; curl -X PUT $HOST/db/b -d '{"a":1}'
{"ok":true,"id":"b","rev":"1-23202479633c2b380f79507a776743d5"}</screen><para>Both revision IDs are the same, a consequence of the deterministic
    algorithm used by CouchDB.</para></sect1><sect1 id="I_sect13_d1e8863"><title>Wrapping Up</title><para>This concludes our tour of the conflict management system. You
    should now be able to create distributed setups that deal with conflicts
    in a proper way.<indexterm id="I_indexterm3_d1e8868" class="endofrange" startref="ch17_conflictmanage" significance="normal"/></para></sect1></chapter><chapter id="loadbalancing"><title>Load Balancing</title><para>Jill is woken up at 4:30 a.m. by her mobile phone. She receives text
  message after text message, one every minute. Finally, Joe calls. Joe is
  furious, and Jill has trouble understanding what Joe is saying. In fact,
  Jill has a hard time figuring out why Joe would call her in the middle of
  the night. Then she remembers: Joe is running an online shop selling sports
  gear on one of her servers, and he is furious because the server went down
  and now his customers in New Zealand are angry because they can’t get to the
  online shop.<indexterm id="I_indexterm4_d1e8874" significance="normal"><primary>load balancing</primary></indexterm></para><para>This is a typical scenario, and you have probably seen many variations
  of it, being in the role of Jill, Joe, or both. If you are Jill, you want to
  sleep at night, and if you are Joe, you want your customers to buy from you
  whenever it pleases them.</para><sect1 id="I_sect14_d1e8879"><title>Having a Backup</title><para>The problems persist: computers fail, and in many ways. There are
    hardware problems, power outages, bugs in the operating system or
    application software, etc. Only CouchDB doesn’t have any bugs. (Well, of
    course, that’s not true. All software has bugs, with the possible
    exception of things written by Daniel J. Bernstein and Donald
    Knuth.)<indexterm id="I_indexterm4_d1e8884" significance="normal"><primary>backup server</primary></indexterm><indexterm id="I_indexterm4_d1e8887" significance="normal"><primary>load balancing</primary><secondary>having a backup server</secondary></indexterm><indexterm id="I_indexterm4_d1e8892" significance="normal"><primary>servers</primary><secondary>having a backup</secondary></indexterm><indexterm id="I_indexterm4_d1e8897" significance="normal"><primary>fault-tolerant systems</primary></indexterm></para><para>Whatever the cause is, you want to make sure that the service you
    are providing (in Jill and Joe’s case, the database for an online store)
    is resilient against failure. The road to resilience is a road of finding
    and removing single points of failure. A server’s power supply can fail.
    To keep the server from turning off during such an event, most come with
    at least two power supplies. To take this further, you could get a server
    where everything is duplicated (or more), but that would be a highly
    specialized (and expensive) piece of hardware. It is much cheaper to get
    two similar servers where the one can take over if the other has a
    problem. However, you need to make sure both servers have the same set of
    data in order to switch them without a user noticing.</para><?dbfo-need heigh=”1in”
?><para>Removing all single points of failure will give you a highly
    available or a <phrase role="keep-together">fault-</phrase><phrase role="keep-together">tolerant</phrase> system. The order of tolerance is
    restrained only by your budget. If you can’t afford to lose a customer’s
    shopping cart in any event, you need to store it on at least two servers
    in at least two far apart geographical locations.</para><note><para>Amazon does this for the <ulink role="orm:hideurl" url="http://www.amazon.com">Amazon.com</ulink> website. If one data
      center is the victim of an earthquake, a user will still be able to
      shop.</para><para>It is likely, though, that Amazon’s problems are not your problems
      and that you will have a whole set of new problems when your data center
      goes away. But you still want to be able to live through a server
      failure.</para></note><para>Before we dive into setting up a highly available CouchDB system,
    let’s look at another situation. Joe calls Jill during regular business
    hours and relays his customers’ complaints that loading the online shop
    takes “forever.” Jill takes a quick look at the server and concludes that
    this is a lucky problem to have, leaving Joe puzzled. Jill explains that
    Joe’s shop is suddenly attracting many more users who are buying things.
    Joe chimes in, “I got a great review on that blog. That’s where they must
    be coming from.” A quick referrer check reveals that indeed many of the
    new customers are coming from a single site. The blog post already
    includes comments from unhappy customers voicing their frustration with
    the slow site. Joe wants to make his customers happy and asks Jill what to
    do. Jill advises that they set up a second server that can take half of
    the load of the current server, making sure all requests get answered in a
    reasonable amount of time. Joe agrees, and Jill begins to set things
    up.<indexterm id="I_indexterm4_d1e8920" significance="normal"><primary>high availability and fault tolerance</primary></indexterm></para><para>The solution to the outlined problem looks a lot like the earlier
    one for providing a fault-tolerant setup: install a second server and
    synchronize all data. The difference is that with fault tolerance, the
    second server just sits there and waits for the first one to fail. In the
    server-overload case, a second server helps answer all incoming requests.
    This case is not fault-tolerant: if one server crashes, the other will get
    all the requests and will likely break down, or at least provide very slow
    service, either of which is not acceptable.</para><para>Keep in mind that although the solutions look similar, high
    availability and fault tolerance are not the same. We’ll get back to the
    second scenario later on, but first we will take a look at how to set up a
    fault-tolerant CouchDB system.</para><para>We already gave it away in the previous chapters: the solution to
    synchronizing servers is replication.</para></sect1></chapter><chapter id="clustering"><title>Clustering</title><para>OK, you’ve made it this far. I’m assuming you more or less understand
  what CouchDB is and how the application API works. Maybe you’ve deployed an
  application or two, and now you’re dealing with enough traffic that you need
  to think about scaling. “Scaling” is an imprecise word, but in this chapter
  we’ll be dealing with the aspect of putting together a partitioned or
  sharded cluster that will have to grow at an increasing rate over time from
  day one.<indexterm class="startofrange" id="ch19_cluster" significance="normal"><primary>clustering</primary></indexterm></para><para>We’ll look at request and response dispatch in a CouchDB cluster with
  stable nodes. Then we’ll cover how to add redundant hot-failover twin nodes,
  so you don’t have to worry about losing machines. In a large cluster, you
  should plan for 5–10% of your machines to experience some sort of failure or
  reduced performance, so cluster design must prevent node failures from
  affecting reliability. Finally, we’ll look at adjusting cluster layout
  dynamically by splitting or merging nodes using replication.</para><sect1 id="I_sect15_d1e8939"><title>Introducing CouchDB Lounge</title><para><ulink url="http://tilgovi.github.com/couchdb-lounge/">CouchDB
    Lounge</ulink> is a proxy-based partitioning and clustering application,
    originally developed for <ulink url="http://www.meebo.com">Meebo</ulink>,
    a web-based instant messaging service. Lounge comes with two major
    components: one that handles simple GET and PUT requests for documents,
    and another that distributes view requests.<indexterm id="I_indexterm5_d1e8949" significance="normal"><primary>proxy-based partitioning and clustering application
        (Lounge)</primary></indexterm><indexterm id="I_indexterm5_d1e8952" significance="normal"><primary>clustering</primary><secondary>CouchDB Lounge</secondary></indexterm><indexterm id="I_indexterm5_d1e8957" significance="normal"><primary>Lounge</primary></indexterm></para><para>The <emphasis>dumbproxy</emphasis> handles simple requests for
    anything that isn’t a CouchDB view. This comes as a module for <ulink url="http://nginx.net/">nginx</ulink>, a high-performance reverse HTTP
    proxy. Because of the way reverse HTTP proxies work, this automatically
    allows configurable security, encryption, load distribution, compression,
    and, of course, aggressive caching of your database resources.</para><para>The <emphasis>smartproxy</emphasis> handles only CouchDB view
    requests, and dispatches them to all the other nodes in the cluster so as
    to distribute the work, making view performance a function of the
    cluster’s cumulative processing power. This comes as a daemon for Twisted,
    a popular and high-performance event-driven network programming framework
    for Python.<indexterm id="I_indexterm5_d1e8973" significance="normal"><primary>Python</primary><secondary>Twisted framework</secondary></indexterm></para></sect1><sect1 id="I_sect15_d1e8978"><title>Consistent Hashing</title><para>CouchDB’s storage model uses unique IDs to save and retrieve
    documents. Sitting at the core of Lounge is a simple method of hashing
    your document IDs. Lounge then uses the first few characters of this hash
    to determine which shard to dispatch the request to. You can configure
    this behavior by writing a <emphasis>shard map</emphasis> for Lounge,
    which is just a simple text configuration file.<indexterm id="I_indexterm5_d1e8986" significance="normal"><primary>document IDs</primary><secondary>hashing</secondary></indexterm><indexterm class="startofrange" id="ch19_clusterconsisthash" significance="normal"><primary>clustering</primary><secondary>consistent hashing</secondary></indexterm><indexterm class="startofrange" id="ch19_hashing" significance="normal"><primary>hashing</primary><secondary>consistent</secondary></indexterm><indexterm id="I_indexterm5_d1e9001" significance="normal"><primary>shard maps (Lounge)</primary></indexterm></para><para>Because Lounge allocates a portion of the hash (known as a keyspace)
    to each node, you can add as many nodes as you like. Because the hash
    function produces hexidecimal strings that bare no apparent relation to
    your DocIDs, and because we dispatch requests based on the first few
    characters, we ensure that all nodes see roughly equal load. And because
    the hash function is consistent, Lounge will take any arbitrary DocID from
    an HTTP request URI and point it to the same node each time.<indexterm id="I_indexterm5_d1e9006" significance="normal"><primary>keyspaces</primary></indexterm></para><para>This idea of splitting a collection of shards based on a keyspace is
    commonly illustrated as a ring, with the hash wrapped around the outside.
    Each tic mark designates the boundaries in the keyspace between two
    partitions. The hash function maps from document IDs to positions on the
    ring. The ring is continuous so that you can always add more nodes by
    splitting a single partition into pieces. With four physical servers, you
    allocate the keyspace into 16 independent partitions by distributing them
    across the servers like so:</para><informaltable frame="all"><tgroup cols="2" colsep="1" rowsep="1"><tbody><row><entry>A</entry><entry>0,1,2,3</entry></row><row><entry>B</entry><entry>4,5,6,7</entry></row><row><entry>C</entry><entry>8,9,a,b</entry></row><row><entry>D</entry><entry>c,d,e,f</entry></row></tbody></tgroup></informaltable><para>If the hash of your DocID starts with <literal moreinfo="none">0</literal>, it would
    be dispatched to shard <literal moreinfo="none">A</literal>. <phrase role="keep-together">Similarly for</phrase> <literal moreinfo="none">1</literal>,
    <literal moreinfo="none">2</literal>, or <literal moreinfo="none">3</literal>. Whereas, if the hash
    started with <literal moreinfo="none">c</literal>, <literal moreinfo="none">d</literal>,
    <literal moreinfo="none">e</literal>, or <literal moreinfo="none">f</literal>, it <phrase role="keep-together">would be dispatched</phrase> to shard
    <literal moreinfo="none">D</literal>. As a full example, the hash
    <literal moreinfo="none">71db329b58378c8fa8876f0ec04c72e5</literal> is mapped to the node
    <literal moreinfo="none">B</literal>, database <literal moreinfo="none">7</literal> in the table just
    shown. This could map to <filename moreinfo="none">http://B.couches.local/db-7/</filename>
    on your backend cluster. In this way, the hash table is just a mapping
    from hashes to backend database URIs. Don’t worry if this all sounds very
    complex; all you have to do is provide a mapping of shards to nodes and
    Lounge will build the hash ring appropriately—so no need to get your hands
    dirty if you don’t want to.</para><para>To frame the same concept with web architecture, because CouchDB
    uses HTTP, the proxy can partition documents according to the request URL,
    without inspecting the body. This is a core principle behind REST and is
    one of the many benefits using HTTP affords us. In practice, this is
    accomplished by running the hash function against the request URI and
    comparing the result to find the portion of the keyspace allocated. Lounge
    then looks up the associated shard for the hash in a configuration table,
    forwarding the HTTP request to the backend CouchDB server.</para><para>Consistent hashing is a simple way to ensure that you can always
    find the documents you saved, while balancing storage load evenly across
    partitions. Because the hash function is simple (it is based on CRC32),
    you are free to implement your own HTTP intermediaries or clients that can
    similarly resolve requests to the correct physical location of your
    data.</para><sect2><title>Redundant Storage</title><para>Consistent hashing solves the problem of how to break up a single
      logical database evenly across a set of partitions, which can then be
      distributed across multiple servers. It does not address the problem of
      how to ensure that data you’ve stored is safe from loss due to hardware
      or software failure. If you are serious about your data, you can’t
      consider it saved until you have at least two copies of it, preferably
      in different geographical locations.<indexterm id="I_indexterm5_d1e9095" significance="normal"><primary>storage, redundant</primary></indexterm></para><para>CouchDB replication makes maintaining hot-failover redundant
      slaves or load-<phrase role="keep-together">balanced</phrase>
      multi-master databases relatively painless. The specifics of how to
      manage replication are covered in <xref linkend="replication"/>. What
      is important in this context is to understand that maintaining redundant
      copies is orthogonal to the harder task of ensuring that the cluster
      consistently chooses the same partition for a particular document
      ID.</para><para>For data safety, you’ll want to have at least two or three copies
      of everything. However, if you encapsulate redundancy, the higher layers
      of the cluster can treat each partition as a single unit and let the
      logical partitions themselves manage redundancy and <phrase role="keep-together">failover</phrase>.</para></sect2><sect2><title>Redundant Proxies</title><para>Just as we can’t accept the possibility of hardware failure
      leading to data loss, we’ll need to run multiple instances of the proxy
      nodes to avoid the chance that a proxy node crash could leave portions
      of the cluster unavailable. By running redundant proxy instances, and
      load balancing across them, we can increase cluster throughput as well
      as reliability.<indexterm id="I_indexterm5_d1e9115" significance="normal"><primary>proxies</primary><secondary>redundant</secondary></indexterm></para></sect2><sect2 id="sect2_view_merging"><title>View Merging</title><para>Consistent hashing leaves documents on the proper node, but
      documents can still <literal moreinfo="none">emit()</literal> any key. The point of
      incremental MapReduce is to bring the function to the data, so we
      shoudn’t redistribute the emitted keys; instead, we send the queries to
      the CouchDB nodes via HTTP proxy, and merge the results using the
      Twisted Python Smartproxy.<indexterm id="I_indexterm5_d1e9128" significance="normal"><primary>views</primary><secondary>merging</secondary></indexterm><indexterm id="I_indexterm5_d1e9133" significance="normal"><primary>Python</primary><secondary>Twisted Smartproxy</secondary></indexterm><indexterm id="I_indexterm5_d1e9138" significance="normal"><primary>Twisted Python Smartproxy</primary></indexterm></para><para>Smartproxy sends each view request to every node, so it needs to
      merge the responses before returning them to the client. Thankfully,
      this operation is not resource-intensive, as merging can be done in
      constant memory space no matter how many rows are returned. The
      Smartproxy receives the first row from each cluster node and compares
      them. We sort the nodes according to their row key using CouchDB’s
      collation rules. Smartproxy pops the top row from the first sorted node
      and returns it to the client.</para><para>This process can be repeated as long as the clients continue to
      send rows, but if a limit is imposed by the client, Smartproxy must end
      the response early, discarding any extra rows sent by the nodes.</para><para>This layout is simple and loosely coupled. It has the advantage
      that it’s simple, which helps in understanding topology and diagnosing
      failures. There is work underway to move the behavior to Erlang, which
      ought to make managing dynamic clusters possible as well as let us
      integrate cluster control into the CouchDB runtime.<indexterm id="I_indexterm5_d1e9147" class="endofrange" startref="ch19_hashing" significance="normal"/><indexterm id="I_indexterm5_d1e9148" class="endofrange" startref="ch19_clusterconsisthash" significance="normal"/></para></sect2></sect1><sect1 id="I_sect15_d1e9149"><title>Growing the Cluster</title><para>Using CouchDB at web scale likely requires CouchDB clusters that can
    be scaled dynamically. Growing sites must continuously add more storage
    capacity, so we need a strategy to increase the size of our cluster
    without taking it down. Some workloads can result in temporary growth in
    data size, in which case we’ll also need a process for shrinking the
    cluster without an interruption in service.<indexterm class="startofrange" id="ch19_clustergrowing" significance="normal"><primary>clustering</primary><secondary>growing the cluster</secondary></indexterm></para><para>In this section, we’ll see how we can use CouchDB’s replication
    filters to split one database into several partitions, and how to use that
    technique to grow the cluster without downtime. There are simple steps you
    can take to avoid partitioning databases while growing the cluster.</para><para><emphasis>Oversharding</emphasis> is a technique where you partition
    the cluster so that there are multiple shards on each physical machine.
    Moving a partition from one machine to another is simpler than splitting
    it into smaller partitions, as the configuration map of the cluster used
    by the proxy only needs to change to point to shards at their new homes,
    rather than adding new logical shards. It’s also less resource-intensive
    to move a partition than to split it into many.<indexterm id="I_indexterm5_d1e9165" significance="normal"><primary>oversharding</primary></indexterm></para><para>One question we need to answer is, “How much should we overshard?”
    The answer depends on your application and deployment, but there are some
    forces that push us in one direction over another. If we get the number of
    shards right, we’ll end up with a cluster that can grow optimally.</para><para>In <xref linkend="sect2_view_merging"/>, we discussed how merges
    can be accomplished in constant space, no matter the number of rows
    returned. The memory space and network resources required to merge views,
    as well as to map from document IDs to partitions, does, however, grow
    linearly with the number of partitions under a given proxy. For this
    reason, we’ll want to limit the number of partitions for each proxy.
    However, we can’t accept an upper limit on cluster size. The solution is
    to use a tree of proxies, where the root proxy partitions to some number
    of intermediate proxies, which then proxy to database nodes.<indexterm id="I_indexterm5_d1e9174" significance="normal"><primary>proxies</primary><secondary>number of partitions per proxy</secondary></indexterm><indexterm id="I_indexterm5_d1e9179" significance="normal"><primary>partitions</primary><secondary>determining number per proxy</secondary></indexterm></para><para>The factors that come into play when deciding how many partitions
    each proxy should manage are: the storage available to each individual
    server node, the projected growth rate of the data, the network and memory
    resources available to proxies, and the acceptable latency for requests
    against the cluster.</para><para>Assuming a conservative 64 shards per proxy, and 1 TB of data
    storage per node (including room for compaction, these nodes will need
    roughly 2 TB of drive space), we can see that with a single proxy in front
    of CouchDB data nodes, we’ll be able to store at maximum 64 TB of data (on
    128 or perhaps 192 server nodes, depending on the level of redundancy
    required by the system) before we have to increase the number of <phrase role="keep-together">partitions</phrase>.</para><para>By replacing database nodes with another proxy, and repartitioning
    each of the 64 partitions into another 64 partitions, we end up with 4,096
    partitions and a tree depth of 2. Just as the initial system can hold 64
    partitions on just a few nodes, we can transition to the 2-layer tree
    without needing thousands of machines. If we assume each proxy must be run
    on its own node, and that at first database nodes can hold 16 partitions,
    we’ll see that we need 65 proxies and 256 database machines (not including
    redundancy factors, which should typically multiply the cluster size by
    two or three times). To get started with a cluster that can grow smoothly
    from 64 TB to 4 PB, we can begin with roughly 600 to 1,000 server nodes,
    adding new ones as data size grows and we move partitions to other
    machines.</para><para>We’ve seen that even a cluster with a depth of 2 can hold a vast
    amount of data. Basic arithmetic shows us that by applying the same
    process to create a cluster with three layers of proxies, we can manage
    262 petabytes on thousands of machines. Conservative estimates for the
    latency introduced by each layer is about 100 ms, so even without
    performance tuning we should see overall response times of 300 ms even
    with a tree depth of 3, and we should be able to manage queries over
    exabyte datasets in less than a second.</para><para>By using oversharding and iteratively replacing full shards
    (database nodes that host only one partition) with proxy nodes that point
    to another set of oversharded partitions, we can grow the cluster to very
    large sizes while incurring a minimum of latency.</para><para>Now we need to look at the mechanics of the two processes that allow
    the cluster to grow: moving a partition from an overcrowded node to an
    empty node, and splitting a large partition into many subpartitions.
    Moving partitions is simpler, which is why it makes sense to use it when
    possible, running the more resource-intensive repartition process only
    when partitions get large enough that only one or two can fit on each
    database server.</para><sect2><title>Moving Partitions</title><para>As we mentioned earlier, each partition is made up of
      <emphasis>N</emphasis> redundant CouchDB <phrase role="keep-together">data</phrase><phrase role="keep-together">bases</phrase>, each stored on different physical
      servers. To keep things easy to conceptualize, any operations should be
      applied to all redundant copies automatically. For the sake of
      discussion, we’ll just talk about the abstract partition, but be aware
      that the redundant nodes will all be the same size and so should require
      the same operations during cluster growth.<indexterm id="I_indexterm5_d1e9213" significance="normal"><primary>partitions</primary><secondary>moving</secondary></indexterm></para><para>The simplest way to move a partition from one node to another is
      to create an empty database on the target node and use CouchDB
      replication to fill the new node with data from the old node. When the
      new copy of the partition is up-to-date with the original, the proxy
      node can be reconfigured to point to the new machine. Once the proxy
      points to the new partition location, one final round of replication
      will bring it up-to-date, and the old partition can be retired, freeing
      space on the original machine.</para><para>Another method for moving partition databases is to rsync the
      files on disk from the old node to the new one. Depending on how
      recently the partition was compacted, this should result in efficient,
      low-CPU initialization of a new node. Replication can then be used to
      bring the rsynced file up-to-date. See more about rsync and replication
      in <xref linkend="replication"/>.</para></sect2><sect2><title>Splitting Partitions</title><para>The last major thing we need to run a CouchDB cluster is the
      capability to split an oversized partition into smaller pieces. In <xref linkend="replication"/>, we discussed how to do continuous replication
      using the <literal moreinfo="none">_changes API</literal>. The <literal moreinfo="none">_changes
      API</literal> can use filters (see <xref linkend="changenotifications"/>), and replication can be configured to
      use a filter function to replicate only a subset of a total database.
      Splitting partitions is accomplished by creating the target partitions
      and configuring them with the range of hash keys they are interested in.
      They then apply filtered replication to the source partition database,
      requesting only documents that meet their hash criteria. The result is
      multiple partial copies of the source database, so that each new
      partition has an equal share of the data. In total, they have a complete
      copy of the original data. Once the replication is complete and the new
      partitions have also brought their redundant backups up-to-date, a proxy
      for the new set of partitions is brought online and the top-level proxy
      is pointed at it instead of the old partition. Just like with moving a
      partition, we should do one final round of replication after the old
      partition is no longer reachable by the cluster, so that any last second
      updates are not lost. Once that is done, we can retire the old partition
      so that its hardware can be reused elsewhere in the cluster.<indexterm id="I_indexterm5_d1e9239" class="endofrange" startref="ch19_clustergrowing" significance="normal"/><indexterm id="I_indexterm5_d1e9240" significance="normal"><primary>partitions</primary><secondary>splitting</secondary></indexterm><indexterm id="I_indexterm5_d1e9246" class="endofrange" startref="ch19_cluster" significance="normal"/></para></sect2></sect1></chapter></part><part id="part5"><title>Reference</title><chapter id="changenotifications"><title>Change Notifications</title><para>Say you are building a message service with CouchDB. Each user has an
  inbox database and other users send messages by dropping them into the inbox
  database. When users want to read all messages received, they can just open
  their inbox databases and see all messages.<indexterm class="startofrange" id="ch20_changes" significance="normal"><primary>change notifications</primary></indexterm></para><para>So far, so simple, but now you’ve got your users hitting the Refresh
  button all the time once they’ve looked at their messages to see if there
  are new messages. This is commonly referred to as
  <emphasis>polling</emphasis>. A lot of users are generating a lot of
  requests that, most of the time, don’t show anything new, just the list of
  all the messages they already know about.</para><para>Wouldn’t it be nice to ask CouchDB to give you notice when a new
  message arrives? The <literal moreinfo="none">_changes</literal> database API does just
  that.</para><para>The scenario just described can be seen as the <emphasis>cache
  invalidation problem</emphasis>; that is, when do I know that what I am
  displaying right now is no longer an apt representation of the underlying
  data store? Any sort of cache invalidation, not only
  backend/frontend-related, can be built using
  <literal moreinfo="none">_changes</literal>.<indexterm id="I_indexterm1_d1e9276" significance="normal"><primary sortas="changes API">_changes API</primary></indexterm><indexterm id="I_indexterm1_d1e9279" significance="normal"><primary>cache invalidation problem</primary></indexterm></para><para><literal moreinfo="none">_changes</literal> is also designed and suited to extract an
  activity stream from a database, whether for simple display or, equally
  important, to act on a new document (or a document change) when it
  occurs.</para><para>The beauty of systems that use the changes API is that they are
  <emphasis>decoupled</emphasis>. A program that is interested only in latest
  updates doesn’t need to know about programs that create new documents and
  vice versa.</para><para>Here’s what a <literal moreinfo="none">changes</literal> item looks like:</para><programlisting id="I_programlisting1_d1e9296" language="javascript" linenumbering="unnumbered" format="linespecific">{"seq":12,"id":"foo","changes":[{"rev":"1-23202479633c2b380f79507a776743d5"}]}</programlisting><para>There are three fields:</para><variablelist><varlistentry><term><literal moreinfo="none">seq</literal></term><listitem><para>The <literal moreinfo="none">update_seq</literal> of the database that was
        created when the document with the <literal moreinfo="none">id</literal> got created
        or changed.</para></listitem></varlistentry><varlistentry><term><literal moreinfo="none">id</literal></term><listitem><para>The document ID.</para></listitem></varlistentry><varlistentry><term><literal moreinfo="none">changes</literal></term><listitem><para>An array of fields, which by default includes the document’s
        revision ID, but can also include information about document conflicts
        and other things.<indexterm id="I_indexterm1_d1e9328" significance="normal"><primary>update_seq field</primary></indexterm><indexterm id="I_indexterm1_d1e9331" significance="normal"><primary>seq field</primary></indexterm></para></listitem></varlistentry></variablelist><para>The changes API is available for each database. You can get changes
  that happen in a single database per request. But you can easily send
  multiple requests to multiple <phrase role="keep-together">databases’</phrase> changes API if you need
  that.<indexterm id="I_indexterm1_d1e9340" significance="normal"><primary>change notifications</primary><secondary>types of requests</secondary></indexterm></para><para>Let’s create a database that we can use as an example later in this
  chapter:</para><screen format="linespecific">&gt; HOST="http://127.0.0.1:5984"
&gt; curl -X PUT $HOST/db
{"ok":true}</screen><para>There are three ways to request notifications:
  <emphasis>polling</emphasis> (the default), <emphasis>long
  polling</emphasis> and <emphasis>continuous</emphasis>. Each is useful in a
  different scenario, and we’ll discuss all of them in detail.</para><sect1 id="I_sect11_d1e9360"><title>Polling for Changes</title><para>In the previous example, we tried to avoid the polling method, but
    it is very simple and in some cases the only one suitable for a problem.
    Because it is the simplest case, it is the default for the changes
    API.<indexterm id="I_indexterm1_d1e9365" significance="normal"><primary>polling for changes</primary></indexterm><indexterm id="I_indexterm1_d1e9368" significance="normal"><primary>change notifications</primary><secondary>polling for</secondary></indexterm></para><para>Let’s see what the changes for our test database look like. First,
    the request (we’re using <literal moreinfo="none">curl</literal> again):</para><screen format="linespecific">curl -X GET $HOST/db/_changes</screen><para>The result is simple:</para><programlisting id="I_programlisting1_d1e9382" language="javascript" linenumbering="unnumbered" format="linespecific">{"results":[

],
"last_seq":0}</programlisting><para>There’s nothing there because we didn’t put anything in yet—no
    surprise. But you can guess where we’d see results—when they start to come
    in. Let’s create a document:</para><screen format="linespecific">curl -X PUT $HOST/db/test -d '{"name":"Anna"}'</screen><para>CouchDB replies:</para><programlisting id="I_programlisting1_d1e9390" language="javascript" linenumbering="unnumbered" format="linespecific">{"ok":true,"id":"test","rev":"1-aaa8e2a031bca334f50b48b6682fb486"}</programlisting><para>Now let’s run the changes request again:</para><programlisting id="I_programlisting1_d1e9395" language="javascript" linenumbering="unnumbered" format="linespecific">{"results":[
{"seq":1,"id":"test","changes":[{"rev":"1-aaa8e2a031bca334f50b48b6682fb486"}]}
],
"last_seq":1}</programlisting><para>We get a notification about our new document. This is pretty neat!
    But wait—when we created the document and got information like the
    revision ID, why would we want to make a request to the changes API to get
    it again? Remember that the purpose of the changes API is to allow you to
    build decoupled systems. The program that creates the document is very
    likely not the same program that requests changes for the database, since
    it already knows what it put in there (although this is blurry, the same
    program could be interested in changes made by others).</para><para>Behind the scenes, we created another document. Let’s see what the
    changes for the database look like now:</para><programlisting id="I_programlisting1_d1e9401" language="javascript" linenumbering="unnumbered" format="linespecific">{"results":[
{"seq":1,"id":"test","changes":[{"rev":"1-aaa8e2a031bca334f50b48b6682fb486"}]},
{"seq":2,"id":"test2","changes":[{"rev":"1-e18422e6a82d0f2157d74b5dcf457997"}]}
],
"last_seq":2}</programlisting><para>See how we get a new line in the result that represents the new
    document? In addition, the first document we put in there got listed
    again. The default result for the changes API is the history of all
    changes that the database has seen.</para><para>We’ve already seen the change for <literal moreinfo="none">"seq":1</literal>, and
    we’re no longer really interested in it. We can tell the changes API about
    that by using the <literal moreinfo="none">since=1</literal> query parameter:</para><screen format="linespecific">curl -X GET $HOST/db/_changes?since=1</screen><para>This returns all changes <emphasis>after</emphasis> the
    <literal moreinfo="none">seq</literal> specified by <literal moreinfo="none">since</literal>:</para><programlisting id="I_programlisting1_d1e9426" language="javascript" linenumbering="unnumbered" format="linespecific">{"results":[
{"seq":2,"id":"test2","changes":[{"rev":"1-e18422e6a82d0f2157d74b5dcf457997"}]}
],
"last_seq":2}</programlisting><para>While we’re discussing options, use
    <literal moreinfo="none">style=all_docs</literal> to get more revision and conflict
    information in the <literal moreinfo="none">changes</literal> array for each result row.
    If you want to specify the default explicitly, the value is
    <literal moreinfo="none">main_only</literal>.</para></sect1><sect1 id="I_sect11_d1e9439"><title>Long Polling</title><para>The technique of long polling was invented for web browsers to
    remove one of the problems with the regular polling approach: it doesn’t
    run any requests if nothing changed. Long polling works like this: when
    making a request to the long polling API, you open an HTTP connection to
    CouchDB until a new row appears in the changes result, and both you and
    CouchDB keep the HTTP connection open. As soon as a result appears, the
    connection is closed.<indexterm id="I_indexterm1_d1e9444" significance="normal"><primary>change notifications</primary><secondary>long polling requests for</secondary></indexterm><indexterm id="I_indexterm1_d1e9449" significance="normal"><primary>long polling</primary></indexterm></para><para>This works well for low-frequency updates. If a lot of changes occur
    for a client, you find yourself opening many new requests, and the
    usefulness of this approach over regular polling declines. Another general
    consequence of this technique is that for each client requesting a long
    polling change notification, CouchDB will have to keep an HTTP connection
    open. CouchDB is well capable of doing so, as it is designed to handle
    many concurrent requests. But you need to make sure your operating system
    allows CouchDB to use at least as many sockets as you have long polling
    clients (and a few spare for regular requests, of course).</para><para>To make a long polling request, add the
    <literal moreinfo="none">feed=longpoll</literal> query parameter. For this listing, we
    added timestamps to show you when things happen.</para><screen format="linespecific">00:00: &gt; curl -X GET "$HOST/db/_changes?feed=longpoll&amp;since=2"
00:00: {"results":[
00:10: {"seq":3,"id":"test3","changes":[{"rev":"1-02c6b758b08360abefc383d74ed5973d"}]}
00:10: ],
00:10: "last_seq":3}</screen><para>At <literal moreinfo="none">00:10</literal>, we create another document behind your
    back again, and CouchDB promptly sends us the change. Note that we used
    <literal moreinfo="none">since=2</literal> to avoid getting any of the previous
    notifications. Also note that we have to use double quotes for the
    <literal moreinfo="none">curl</literal> command because we are using an ampersand, which
    is a special character for our shell.</para><para>The <literal moreinfo="none">style</literal> option works for long polling requests
    just like for regular polling requests.</para><para>Networks are a tricky beast, and sometimes you don’t know whether
    there are no changes coming or your network connection went stale. If you
    add another query <phrase role="keep-together">parameter</phrase>,
    <literal moreinfo="none">heartbeat=<replaceable>N</replaceable></literal>, where
    <emphasis>N</emphasis> is a number, CouchDB will send you a newline
    character each <emphasis>N</emphasis> milliseconds. As long as you are
    receiving newline characters, you know there are no new change
    notifications, but CouchDB is still ready to send you the next one when it
    occurs.</para></sect1><sect1 id="I_sect11_d1e9493"><title>Continuous Changes</title><para>Long polling is great, but you still end up opening an HTTP request
    for each change notification. For web browsers, this is the only way to
    avoid the problems of regular polling. But web browsers are not the only
    client software that can be used to talk to CouchDB. If you are using
    Python, Ruby, Java, or any other language really, you have yet another
    option.<indexterm id="I_indexterm1_d1e9498" significance="normal"><primary>continuous changes</primary></indexterm><indexterm id="I_indexterm1_d1e9501" significance="normal"><primary>change notifications</primary><secondary>continuous changes requests</secondary></indexterm></para><para>The <emphasis>continuous changes API</emphasis> allows you to
    receive change notifications as they come in using a single HTTP
    connection. You make a request to the continuous changes API and both you
    and CouchDB will hold the connection open “forever.” CouchDB will send you
    newlines for notifications when the occur and—as opposed to long
    polling—will keep the HTTP connection open, waiting to send the next
    notification.</para><para>This is great for both infrequent and frequent notifications, and it
    has the same consequence as long polling: you’re going to have a lot of
    long-living HTTP connections. But again, CouchDB easily supports
    these.</para><para>Use the <literal moreinfo="none">feed=continuous</literal> parameter to make a
    continuous changes API request. Following is the result, again with
    timestamps. At <literal moreinfo="none">00:10</literal> and <literal moreinfo="none">00:15</literal>,
    we’ll create a new document each:</para><screen format="linespecific">00:00: &gt; curl -X GET "$HOST/db/_changes?feed=continuous&amp;since=3"
00:10: {"seq":4,"id":"test4","changes":[{"rev":"1-02c6b758b08360abefc383d74ed5973d"}]}
00:15: {"seq":5,"id":"test5","changes":[{"rev":"1-02c6b758b08360abefc383d74ed5973d"}]}</screen><para>Note that the continuous changes API result doesn’t include a
    wrapping JSON object with a results member with the individual
    notification results as array items; it includes only a raw line per
    notification. Also note that the lines are no longer separated by a comma.
    Whereas the regular and long polling APIs result is a full valid JSON
    object when the HTTP request returns, the continuous changes API sends
    individual rows as valid JSON objects. The difference makes it easier for
    clients to parse the respective results. The <literal moreinfo="none">style</literal> and
    <literal moreinfo="none">heartbeat</literal> parameters work as expected with the
    continuous changes API.</para></sect1><sect1 id="I_sect11_d1e9534"><title>Filters</title><para>The change notification API and its three modes of operation already
    give you a lot of options requesting and processing changes in CouchDB.
    Filters for changes give you an additional level of flexibility. Let’s say
    the messages from our first scenario have priorities, and a user is
    interested only in notifications about messages with a
    <literal moreinfo="none">high</literal> <phrase role="keep-together">priority</phrase>.<indexterm id="I_indexterm1_d1e9545" significance="normal"><primary>filters for changes</primary></indexterm><indexterm id="I_indexterm1_d1e9548" significance="normal"><primary>change notifications</primary><secondary>filters for changes</secondary></indexterm></para><para>Enter filters. Similar to view functions, a filter is a JavaScript
    function that gets stored in a design document and is later executed by
    CouchDB. They live in special member <literal moreinfo="none">filters</literal> under a
    name of your choice. Here is an example:</para><programlisting id="I_programlisting1_d1e9558" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "_id": "_design/app",
  "_rev": "1-b20db05077a51944afd11dcb3a6f18f1",
  "filters": {
    "important": "function(doc, req) { if(doc.priority == 'high') { return true; } 
    else { return false; }}"
  }
}</programlisting><para>To query the changes API with this filter, use the
    <literal moreinfo="none">filter=designdocname/filtername</literal> query parameter:</para><screen format="linespecific">curl "$HOST/db/_changes?filter=app/important"</screen><para>The result now includes only rows for document updates for which the
    filter function returns <literal moreinfo="none">true</literal>—in our case, where the
    <literal moreinfo="none">priority</literal> property of our document has the value
    <literal moreinfo="none">high</literal>. This is pretty neat, but CouchDB takes it up
    another notch.</para><para>Let’s take the initial example application where users can send
    messages to each other. Instead of having a database per user that acts as
    the inbox, we now use a single database as the inbox for all users. How
    can a user register for changes that represent a new message being put in
    her inbox?</para><?dbfo-need height=”1in”
?><para>We can make the filter function using a request parameter:</para><programlisting id="I_programlisting1_d1e9583" language="javascript" linenumbering="unnumbered" format="linespecific">function(doc, req)
{
  if(doc.name == req.query.name) {
    return true;
  }

  return false;
}</programlisting><para>If you now run a request adding a <literal moreinfo="none">?name=Steve</literal>
    parameter, the filter function will only return result rows for documents
    that have the <literal moreinfo="none">name</literal> field set to “Steve.” If you are
    running a request for a different user, just change the request parameter
    (<literal moreinfo="none">name=Joe</literal>).</para><para>Now, adding a query parameter to a filtered changes request is easy.
    What would hinder Steve from passing in <literal moreinfo="none">name=Joe</literal> as the
    parameter and seeing Joe’s inbox? Not much. Can CouchDB help with this? We
    wouldn’t bring this up if it couldn’t, would we?</para><para>The <literal moreinfo="none">req</literal> parameter of the filter function includes
    a member <literal moreinfo="none">userCtx</literal>, the <emphasis>user
    context</emphasis>. This includes information about the user that has
    already been authenticated over HTTP earlier in the phase of the request.
    Specifically, <literal moreinfo="none">req.userCtx.name</literal> includes the username of
    the user who makes the filtered changes request. We can be sure that the
    user is who he says he is because he has been authenticated against one of
    the authenticating schemes in CouchDB. With this, we don’t even need the
    dynamic filter parameter (although it can still be useful in other
    situations).<indexterm id="I_indexterm1_d1e9616" significance="normal"><primary>userCtx (user context) object</primary><secondary sortas="change filters">in change filters</secondary></indexterm></para><para>If you have configured CouchDB to use authentication for requests, a
    user will have to make an authenticated request and the result is
    available in our filter function:</para><programlisting id="I_programlisting1_d1e9623" language="javascript" linenumbering="unnumbered" format="linespecific">function(doc, req)
{
  if(doc.name) {
    if(doc.name == req.userCtx.name) {
      return true;
    }
  }

  return false;
}</programlisting></sect1><sect1 id="I_sect11_d1e9625"><title>Wrapping Up</title><para>The changes API lets you build sophisticated notification schemes
    useful in many scenarios with isolated and asynchronous components yet
    working to the same beat. In combination with replication, this API is the
    foundation for building distributed, highly available, and
    high-performance CouchDB clusters.<indexterm id="I_indexterm1_d1e9630" class="endofrange" startref="ch20_changes" significance="normal"/></para></sect1></chapter><chapter id="viewcookbookforsqljockeys"><title>View Cookbook for SQL Jockeys</title><para>This is a collection of some common SQL queries and how to get the
  same result in CouchDB. The key to remember here is that CouchDB does not
  work like an SQL database at all and that best practices from the SQL world
  do not translate well or at all to CouchDB. This chapter’s “cookbook”
  assumes that you are familiar with the CouchDB basics such as creating and
  updating databases and documents.<indexterm class="startofrange" id="ch21_viewsSQLqueries" significance="normal"><primary>views</primary><secondary>replacing SQL queries with</secondary></indexterm><indexterm class="startofrange" id="ch21_SQLqueriesviews" significance="normal"><primary>SQL queries, replacing with CouchDB views</primary></indexterm></para><sect1 id="I_sect12_d1e9644"><title>Using Views</title><para>How you would do this in SQL:</para><programlisting id="I_programlisting2_d1e9649" format="linespecific">CREATE TABLE</programlisting><para>or:</para><programlisting id="I_programlisting2_d1e9653" format="linespecific">ALTER TABLE</programlisting><para>Using views is a two-step process. First you
    <emphasis>define</emphasis> a view; then you <emphasis>query</emphasis>
    it. This is analogous to defining a table structure (with indexes) using
    <literal moreinfo="none">CREATE TABLE</literal> or <literal moreinfo="none">ALTER TABLE</literal> and
    querying it using an SQL query.<indexterm class="startofrange" id="ch21_viewSQLCREATEALTER" significance="normal"><primary>views</primary><secondary>replacing SQL queries with</secondary><tertiary>using views</tertiary></indexterm><indexterm id="I_indexterm2_d1e9676" significance="normal"><primary>SQL queries, replacing with CouchDB views</primary><secondary>using views</secondary></indexterm></para><sect2><title>Defining a View</title><para>Defining a view is done by creating a special document in a
      CouchDB database. The only real specialness is the
      <literal moreinfo="none">_id</literal> of the document, which starts with
      <literal moreinfo="none">_design/</literal>—for example,
      <literal moreinfo="none">_design/application</literal>. Other than that, it is just a
      regular CouchDB document. To make sure CouchDB understands that you are
      defining a view, you need to prepare the contents of that design
      document in a special format. Here is an example:<indexterm id="I_indexterm2_d1e9695" significance="normal"><primary>design documents</primary><secondary>view definitions</secondary></indexterm><indexterm id="I_indexterm2_d1e9700" significance="normal"><primary>SQL queries, replacing with CouchDB views</primary><secondary>using views</secondary><tertiary>defining a view</tertiary></indexterm></para><programlisting id="I_programlisting2_d1e9707" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "_id": "_design/application",
  "_rev": "1-C1687D17",
  "views": {
    "viewname": {
      "map": "function(doc) { ... }",
      "reduce": "function(keys, values) { ... }"
    }
  }
}</programlisting><para>We are defining a view <literal moreinfo="none">viewname</literal>. The definition
      of the view consists of two functions: the <emphasis>map</emphasis>
      function and the <emphasis>reduce</emphasis> function. Specifying a
      reduce function is optional. We’ll look at the nature of the functions
      later. Note that <literal moreinfo="none">viewname</literal> can be whatever you like:
      <literal moreinfo="none">users</literal>, <literal moreinfo="none">by-name</literal>, or
      <literal moreinfo="none">by-date</literal> are just some examples.<indexterm id="I_indexterm2_d1e9733" significance="normal"><primary>reduce functions</primary><secondary sortas="view definitions">in view definitions</secondary></indexterm><indexterm id="I_indexterm2_d1e9738" significance="normal"><primary>map functions</primary><secondary sortas="view definitions">in view definitions</secondary></indexterm></para><para>A single design document can also include multiple view
      definitions, each identified by a unique name:</para><programlisting id="I_programlisting2_d1e9745" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "_id": "_design/application",
  "_rev": "1-C1687D17",
  "views": {
    "viewname": {
      "map": "function(doc) { ... }",
      "reduce": "function(keys, values) { ... }"
    },
    "anotherview": {
      "map": "function(doc) { ... }",
      "reduce": "function(keys, values) { ... }"
    }
  }
}</programlisting></sect2><sect2><title>Querying a View</title><para>The name of the design document and the name of the view are
      significant for querying the view. To query the view
      <literal moreinfo="none">viewname</literal>, you perform an HTTP <literal moreinfo="none">GET</literal>
      request to the following URI:<indexterm id="I_indexterm2_d1e9758" significance="normal"><primary>querying views</primary></indexterm><indexterm id="I_indexterm2_d1e9761" significance="normal"><primary>SQL queries, replacing with CouchDB views</primary><secondary>using views</secondary><tertiary>querying a view</tertiary></indexterm></para><screen format="linespecific">/database/_design/application/_view/viewname</screen><para><literal moreinfo="none">database</literal> is the name of the database you
      created your design document in. Next up is the design document name,
      and then the view name prefixed with <literal moreinfo="none">_view/</literal>. To query
      <literal moreinfo="none">anotherview</literal>, replace <literal moreinfo="none">viewname</literal> in
      that URI with <literal moreinfo="none">anotherview</literal>. If you want to query a
      view in a different design document, adjust the design document
      name.</para></sect2><sect2><title>MapReduce Functions</title><para>MapReduce is a concept that solves problems by applying a two-step
      process, aptly named the <emphasis>map</emphasis> phase and the
      <emphasis>reduce</emphasis> phase. The map phase looks at all documents
      in CouchDB separately one after the other and creates a <emphasis>map
      result</emphasis>. The map result is an ordered list of key/value pairs.
      Both <literal moreinfo="none">key</literal> and <literal moreinfo="none">value</literal> can be
      specified by the user writing the map function. A map function may call
      the built-in <literal moreinfo="none">emit(key, value)</literal> function 0 to
      <emphasis>N</emphasis> times per document, creating a row in the map
      result per invocation.<indexterm id="I_indexterm2_d1e9813" significance="normal"><primary>SQL queries, replacing with CouchDB views</primary><secondary>using views</secondary><tertiary>map and reduce functions</tertiary></indexterm><indexterm id="I_indexterm2_d1e9820" significance="normal"><primary>map functions</primary></indexterm></para><para>CouchDB is smart enough to run a map function only once for every
      document, even on subsequent queries on a view. Only changes to
      documents or new documents need to be processed anew.</para><sect3><title>Map functions</title><para>Map functions run in isolation for every document. They can’t
        modify the document, and they can’t talk to the outside world—they
        can’t have <emphasis>side effects</emphasis>. This is required so that
        CouchDB can guarantee correct results without having to recalculate a
        complete result when only one document gets changed.</para><para>The map result looks like this:</para><programlisting id="I_programlisting2_d1e9835" language="javascript" linenumbering="unnumbered" format="linespecific">{"total_rows":3,"offset":0,"rows":[
  {"id":"fc2636bf50556346f1ce46b4bc01fe30","key":"Lena","value":5},
  {"id":"1fb2449f9b9d4e466dbfa47ebe675063","key":"Lisa","value":4},
  {"id":"8ede09f6f6aeb35d948485624b28f149","key":"Sarah","value":6}
}</programlisting><para>It is a list of rows sorted by the value of
        <literal moreinfo="none">key</literal>. The <literal moreinfo="none">id</literal> is added
        automatically and refers back to the document that created this row.
        The <literal moreinfo="none">value</literal> is the data you’re looking for. For
        example purposes, it’s the girl’s age.</para><para>The map function that produces this result is:</para><programlisting id="I_programlisting2_d1e9850" language="javascript" linenumbering="unnumbered" format="linespecific">function(doc) {
  if(doc.name &amp;&amp; doc.age) {
    emit(doc.name, doc.age);
  }
}</programlisting><para>It includes the <literal moreinfo="none">if</literal> statement as a sanity
        check to ensure that we’re operating on the right fields and calls the
        <literal moreinfo="none">emit</literal> function with the name and age as the key and
        value.</para></sect3><sect3><title>Reduce functions</title><para>Reduce functions are explained in <xref linkend="sect1_aggregate_functions"/>.<indexterm id="I_indexterm2_d1e9867" class="endofrange" startref="ch21_viewSQLCREATEALTER" significance="normal"/></para></sect3></sect2></sect1><sect1 id="I_sect12_d1e9868"><title>Look Up by Key</title><para>How you would do this in SQL:</para><programlisting id="I_programlisting2_d1e9873" format="linespecific">SELECT <emphasis>field</emphasis> FROM <emphasis>table</emphasis> WHERE value="<emphasis>searchterm</emphasis>"</programlisting><para>Use case: get a <emphasis>result</emphasis> (which can be a record
    or set of records) associated with a <emphasis>key</emphasis>
    (<literal moreinfo="none">"searchterm"</literal>).<indexterm id="I_indexterm2_d1e9895" significance="normal"><primary>lookups</primary><secondary>by key</secondary></indexterm><indexterm id="I_indexterm2_d1e9900" significance="normal"><primary>SQL queries, replacing with CouchDB views</primary><secondary>lookups by key</secondary></indexterm><indexterm class="startofrange" id="ch21_viewsSQLlookup" significance="normal"><primary>views</primary><secondary>replacing SQL queries with</secondary><tertiary>lookups by key</tertiary></indexterm></para><para>To look something up quickly, regardless of the storage mechanism,
    an index is needed. An index is a data structure optimized for quick
    search and retrieval. CouchDB’s map result is stored in such an index,
    which happens to be a B+ tree.</para><para>To look up a value by <literal moreinfo="none">"searchterm"</literal>, we need to
    put all values into the key of a view. All we need is a simple map
    function:</para><programlisting id="I_programlisting2_d1e9919" language="javascript" linenumbering="unnumbered" format="linespecific">function(doc) {
  if(doc.value) {
    emit(doc.value, null);
  }
}</programlisting><para>This creates a list of documents that have a
    <literal moreinfo="none">value</literal> field sorted by the data in the
    <literal moreinfo="none">value</literal> field. To find all the records that match
    <literal moreinfo="none">"searchterm"</literal>, we query the view and specify the search
    term as a query parameter:</para><screen format="linespecific">/database/_design/application/_view/viewname?key="searchterm"</screen><para>Consider the documents from the previous section, and say we’re
    indexing on the <literal moreinfo="none">age</literal> field of the documents to find all
    the five-year-olds:</para><programlisting id="I_programlisting2_d1e9939" language="javascript" linenumbering="unnumbered" format="linespecific">function(doc) {
  if(doc.age &amp;&amp; doc.name) {
    emit(doc.age, doc.name);
  }
}</programlisting><para>Query:</para><screen format="linespecific">/ladies/_design/ladies/_view/age?key=5</screen><para>Result:</para><programlisting id="I_programlisting2_d1e9948" language="javascript" linenumbering="unnumbered" format="linespecific">{"total_rows":3,"offset":1,"rows":[
{"id":"fc2636bf50556346f1ce46b4bc01fe30","key":5,"value":"Lena"}
]}</programlisting><para>Easy.</para><para>Note that you have to emit a value. The view result includes the
    associated document ID in every row. We can use it to look up more data
    from the document itself. We can also use the
    <literal moreinfo="none">?include_docs=true</literal> parameter to have CouchDB fetch the
    documents <phrase role="keep-together">individually</phrase> for
    us.<indexterm id="I_indexterm2_d1e9960" class="endofrange" startref="ch21_viewsSQLlookup" significance="normal"/></para></sect1><sect1 id="I_sect12_d1e9961"><title>Look Up by Prefix</title><para>How you would do this in SQL:</para><programlisting id="I_programlisting2_d1e9966" format="linespecific">SELECT <emphasis>field</emphasis> FROM <emphasis>table</emphasis> WHERE <emphasis>value</emphasis> LIKE "<emphasis>searchterm</emphasis>%"</programlisting><para>Use case: find all documents that have a field value that starts
    with <literal moreinfo="none">searchterm</literal>. For example, say you stored a MIME
    type (like <literal moreinfo="none">text/html</literal> or <literal moreinfo="none">image/jpg</literal>)
    for each document and now you want to find all documents that are images
    according to the MIME type.<indexterm id="I_indexterm2_d1e9991" significance="normal"><primary>SQL queries, replacing with CouchDB views</primary><secondary>lookup by prefix</secondary></indexterm><indexterm id="I_indexterm2_d1e9996" significance="normal"><primary>views</primary><secondary>replacing SQL queries with</secondary><tertiary>lookups by prefix</tertiary></indexterm><indexterm id="I_indexterm2_d1e10003" significance="normal"><primary>lookups</primary><secondary>by prefix</secondary></indexterm></para><para>The solution is very similar to the previous example: all we need is
    a map function that is a little more clever than the first one. But first,
    an example document:</para><programlisting id="I_programlisting2_d1e10010" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "_id": "Hugh Laurie",
  "_rev": "1-9fded7deef52ac373119d05435581edf",
  "mime-type": "image/jpg",
  "description": "some dude"
}</programlisting><para>The clue lies in extracting the prefix that we want to search for
    from our document and putting it into our view index. We use a regular
    expression to match our prefix:</para><programlisting id="I_programlisting2_d1e10014" language="javascript" linenumbering="unnumbered" format="linespecific">function(doc) {
  if(doc["mime-type"]) {
    // from the start (^) match everything that is not a slash ([^\/]+) until
    // we find a slash (\/). Slashes needs to be escaped with a backslash (\/)
    var prefix = doc["mime-type"].match(/^[^\/]+\//);
    if(prefix) {
      emit(prefix, null);
    }
  }
}</programlisting><para>We can now query this view with our desired MIME type prefix and not
    only find all images, but also text, video, and all other formats:</para><screen format="linespecific">/files/_design/finder/_view/by-mime-type?key="image/"</screen></sect1><sect1 id="sect1_aggregate_functions"><title>Aggregate Functions</title><para>How you would do this in SQL:</para><programlisting id="I_programlisting2_d1e10025" format="linespecific">SELECT COUNT(<emphasis>field</emphasis>) FROM <emphasis>table</emphasis></programlisting><para>Use case: calculate a derived value from your data.<indexterm id="I_indexterm2_d1e10034" significance="normal"><primary>functions</primary><secondary>aggregate functions in SQL, replacing with
        views</secondary></indexterm><indexterm id="I_indexterm2_d1e10039" significance="normal"><primary>views</primary><secondary>replacing SQL queries with</secondary><tertiary>aggregate functions</tertiary></indexterm><indexterm id="I_indexterm2_d1e10046" significance="normal"><primary>SQL queries, replacing with CouchDB views</primary><secondary>aggregate functions</secondary></indexterm><indexterm id="I_indexterm2_d1e10051" significance="normal"><primary>aggregate functions in SQL</primary></indexterm></para><para>We haven’t explained reduce functions yet. Reduce functions are
    similar to aggregate functions in SQL. They compute a value over multiple
    documents.<indexterm id="I_indexterm2_d1e10056" significance="normal"><primary>reduce functions</primary><secondary>overview of</secondary></indexterm></para><para>To explain the mechanics of reduce functions, we’ll create one that
    doesn’t make a whole lot of sense. But this example is easy to understand.
    We’ll explore more useful reductions later.<indexterm id="I_indexterm2_d1e10063" significance="normal"><primary>intermediate result</primary></indexterm><indexterm id="I_indexterm2_d1e10066" significance="normal"><primary>map result</primary></indexterm></para><para>Reduce functions operate on the output of the map function (also
    called the <emphasis>map re⁠sult</emphasis> or <emphasis>intermediate
    result</emphasis>). The reduce function’s job, unsurprisingly, is to
    reduce the list that the map function produces.</para><para>Here’s what our summing reduce function looks like:</para><programlisting id="I_programlisting2_d1e10079" language="javascript" linenumbering="unnumbered" format="linespecific">function(keys, values) {
  var sum = 0;
  for(var idx in values) {
    sum = sum + values[idx];
  }
  return sum;
}</programlisting><para>Here’s an alternate, more idiomatic JavaScript version:</para><programlisting id="I_programlisting2_d1e10083" language="javascript" linenumbering="unnumbered" format="linespecific">function(keys, values) {
  var sum = 0;
  values.forEach(function(element) {
    sum = sum + element;
  });
  return sum;
}</programlisting><para>This reduce function takes two arguments: a list of
    <literal moreinfo="none">keys</literal> and a list of <literal moreinfo="none">values</literal>. For our
    summing purposes we can ignore the <literal moreinfo="none">keys</literal>-list and
    consider only the <literal moreinfo="none">value</literal> list. We’re looping over the
    list and add each item to a running total that we’re returning at the end
    of the function.<indexterm id="I_indexterm2_d1e10100" significance="normal"><primary>key/value pairs</primary><secondary>reduce function arguments</secondary></indexterm></para><para>You’ll see one difference between the map and the reduce function.
    The map function uses <literal moreinfo="none">emit()</literal> to create its result,
    whereas the reduce function returns a value.</para><para>For example, from a list of integer values that specify the age,
    calculate the sum of all years of life for the news headline, “786 life
    years present at event.” A little contrived, but very simple and thus good
    for demonstration purposes. Consider the documents and the map view we
    used earlier in this chapter.</para><para>The reduce function to calculate the total age of all girls
    is:</para><programlisting id="I_programlisting2_d1e10114" language="javascript" linenumbering="unnumbered" format="linespecific">function(keys, values) {
  return sum(values);
}</programlisting><para>Note that, instead of the two earlier versions, we use CouchDB’s
    predefined <literal moreinfo="none">sum()</literal> function. It does the same thing as
    the other two, but it is such a common piece of code that CouchDB has it
    included.<indexterm id="I_indexterm2_d1e10121" significance="normal"><primary>sum( ) function</primary></indexterm></para><para>The result for our reduce view now looks like this:</para><programlisting id="I_programlisting2_d1e10126" language="javascript" linenumbering="unnumbered" format="linespecific">{"rows":[
{"key":null,"value":15}
]}</programlisting><para>The total sum of all <literal moreinfo="none">age</literal> fields in all our
    documents is <literal moreinfo="none">15</literal>. Just what we wanted. The
    <literal moreinfo="none">key</literal> member of the result object is
    <literal moreinfo="none">null</literal>, as we can’t know anymore which documents took
    part in the creation of the reduced result. We’ll cover more advanced
    reduce cases later on.</para><para>As a rule of thumb, the reduce function should reduce a single
    scalar value. That is, an integer; a string; or a small, fixed-size list
    or object that includes an aggregated value (or values) from the
    <literal moreinfo="none">values</literal> argument. It should never just return
    <literal moreinfo="none">values</literal> or similar. CouchDB will give you a warning if
    you try to use reduce “the wrong way”:<indexterm id="I_indexterm2_d1e10150" significance="normal"><primary>scalar values</primary></indexterm></para><programlisting id="I_programlisting2_d1e10153" language="javascript" linenumbering="unnumbered" format="linespecific">{"error":"reduce_overflow_error","message":"Reduce output must shrink more rapidly: 
Current output: ..."}</programlisting></sect1><sect1 id="I_sect12_d1e10155"><title>Get Unique Values</title><para>How you would do this in SQL:</para><programlisting id="I_programlisting2_d1e10160" format="linespecific">SELECT DISTINCT <emphasis>field</emphasis> FROM <emphasis>table</emphasis></programlisting><para>Getting unique values is not as easy as adding a keyword. But a
    reduce view and a special query parameter give us the same result. Let’s
    say you want a list of tags that your users have tagged themselves with
    and no duplicates.<indexterm class="startofrange" id="ch21_uniquevals" significance="normal"><primary>unique values, retrieving</primary></indexterm><indexterm class="startofrange" id="ch21_viewsSQLuniquevals" significance="normal"><primary>views</primary><secondary>replacing SQL queries with</secondary><tertiary>getting unique values</tertiary></indexterm><indexterm class="startofrange" id="ch21_SQLuniquevals" significance="normal"><primary>SQL queries, replacing with CouchDB views</primary><secondary>getting unique values</secondary></indexterm></para><para>First, let’s look at the source documents. We punt on
    <literal moreinfo="none">_id</literal> and <literal moreinfo="none">_rev</literal> attributes here:</para><programlisting id="I_programlisting2_d1e10192" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "name":"Chris",
  "tags":["mustache", "music", "couchdb"]
}

{
  "name":"Noah",
  "tags":["hypertext", "philosophy", "couchdb"]
}

{
  "name":"Jan",
  "tags":["drums", "bike", "couchdb"]
}</programlisting><para>Next, we need a list of all tags. A map function will do the
    trick:</para><programlisting id="I_programlisting2_d1e10196" language="javascript" linenumbering="unnumbered" format="linespecific">function(dude) {
  if(dude.name &amp;&amp; dude.tags) {
    dude.tags.forEach(function(tag) {
      emit(tag, null);
    });
  }
}</programlisting><para>The result will look like this:</para><programlisting id="I_programlisting2_d1e10200" language="javascript" linenumbering="unnumbered" format="linespecific">{"total_rows":9,"offset":0,"rows":[
{"id":"3525ab874bc4965fa3cda7c549e92d30","key":"bike","value":null},
{"id":"3525ab874bc4965fa3cda7c549e92d30","key":"couchdb","value":null},
{"id":"53f82b1f0ff49a08ac79a9dff41d7860","key":"couchdb","value":null},
{"id":"da5ea89448a4506925823f4d985aabbd","key":"couchdb","value":null},
{"id":"3525ab874bc4965fa3cda7c549e92d30","key":"drums","value":null},
{"id":"53f82b1f0ff49a08ac79a9dff41d7860","key":"hypertext","value":null},
{"id":"da5ea89448a4506925823f4d985aabbd","key":"music","value":null},
{"id":"da5ea89448a4506925823f4d985aabbd","key":"mustache","value":null},
{"id":"53f82b1f0ff49a08ac79a9dff41d7860","key":"philosophy","value":null}
]}</programlisting><para>As promised, these are all the tags, including duplicates. Since
    each document gets run through the map function in isolation, it cannot
    know if the same key has been emitted already. At this stage, we need to
    live with that. To achieve uniqueness, we need a reduce:</para><programlisting id="I_programlisting2_d1e10205" language="javascript" linenumbering="unnumbered" format="linespecific">function(keys, values) {
  return true;
}</programlisting><para>This reduce doesn’t do anything, but it allows us to specify a
    special query parameter when querying the view:</para><screen format="linespecific">/dudes/_design/dude-data/_view/tags?group=true</screen><para>CouchDB replies:</para><programlisting id="I_programlisting2_d1e10213" language="javascript" linenumbering="unnumbered" format="linespecific">{"rows":[
{"key":"bike","value":true},
{"key":"couchdb","value":true},
{"key":"drums","value":true},
{"key":"hypertext","value":true},
{"key":"music","value":true},
{"key":"mustache","value":true},
{"key":"philosophy","value":true}
]}</programlisting><para>In this case, we can ignore the value part because it is always
    true, but the result includes a list of all our tags and no
    duplicates!</para><para>With a small change we can put the reduce to good use, too. Let’s
    see how many of the non-unique tags are there for each tag. To calculate
    the tag frequency, we just use the summing up we already learned about. In
    the map function, we emit a <literal moreinfo="none">1</literal> instead of
    <literal moreinfo="none">null</literal>:</para><programlisting id="I_programlisting2_d1e10225" language="javascript" linenumbering="unnumbered" format="linespecific">function(dude) {
  if(dude.name &amp;&amp; dude.tags) {
    dude.tags.forEach(function(tag) {
      emit(tag, 1);
    });
  }
}</programlisting><para>In the reduce function, we return the sum of all values:</para><programlisting id="I_programlisting2_d1e10229" language="javascript" linenumbering="unnumbered" format="linespecific">function(keys, values) {
  return sum(values);
}</programlisting><para>Now, if we query the view with the <literal moreinfo="none">?group=true</literal>
    parameter, we get back the count for each tag:</para><programlisting id="I_programlisting2_d1e10237" language="javascript" linenumbering="unnumbered" format="linespecific">{"rows":[
{"key":"bike","value":1},
{"key":"couchdb","value":3},
{"key":"drums","value":1},
{"key":"hypertext","value":1},
{"key":"music","value":1},
{"key":"mustache","value":1},
{"key":"philosophy","value":1}
]}</programlisting></sect1><sect1 id="I_sect12_d1e10239"><title>Enforcing Uniqueness</title><para>How you would do this in SQL:</para><programlisting id="I_programlisting2_d1e10244" format="linespecific">UNIQUE KEY(<emphasis>column</emphasis>)</programlisting><para>Use case: your applications require that a certain value exists only
    once in a database.<indexterm id="I_indexterm2_d1e10251" significance="normal"><primary>views</primary><secondary>replacing SQL queries with</secondary><tertiary>enforcing uniqueness</tertiary></indexterm><indexterm id="I_indexterm2_d1e10258" significance="normal"><primary>SQL queries, replacing with CouchDB views</primary><secondary>enforcing uniqueness</secondary></indexterm><indexterm id="I_indexterm2_d1e10263" significance="normal"><primary>uniqueness, enforcing</primary></indexterm><indexterm id="I_indexterm2_d1e10266" class="endofrange" startref="ch21_SQLuniquevals" significance="normal"/><indexterm id="I_indexterm2_d1e10267" class="endofrange" startref="ch21_viewsSQLuniquevals" significance="normal"/><indexterm id="I_indexterm2_d1e10268" class="endofrange" startref="ch21_uniquevals" significance="normal"/></para><para>This is an easy one: within a CouchDB database, each document must
    have a unique <literal moreinfo="none">_id</literal> field. If you require unique values
    in a database, just assign them to a document’s <literal moreinfo="none">_id</literal>
    field and CouchDB will enforce uniqueness for you.<indexterm id="I_indexterm2_d1e10277" significance="normal"><primary sortas="id field, documents">_id field, documents</primary></indexterm><indexterm id="I_indexterm2_d1e10280" significance="normal"><primary>documents</primary><secondary sortas="id field">_id field</secondary></indexterm></para><para>There’s one caveat, though: in the distributed case, when you are
    running more than one CouchDB node that accepts write requests, uniqueness
    can be guaranteed only per node or outside of CouchDB. CouchDB will allow
    two identical IDs to be written to two different nodes. On replication,
    CouchDB will detect a conflict and flag the document
    accordingly.<indexterm id="I_indexterm2_d1e10287" class="endofrange" startref="ch21_viewsSQLqueries" significance="normal"/><indexterm id="I_indexterm2_d1e10288" class="endofrange" startref="ch21_SQLqueriesviews" significance="normal"/></para></sect1></chapter><chapter id="security"><title>Security</title><para>We mentioned earlier that CouchDB is still in development and that
  features may have been added since the publication of this book. This is
  especially true for the security mechanisms in CouchDB. There is rudimentary
  support in the currently released versions (0.10.0), but as we’re writing
  these lines, additions are being discussed.<indexterm class="startofrange" id="ch22_security" significance="normal"><primary>security</primary></indexterm></para><para>In this chapter, we’ll look at the basic security mechanisms in
  CouchDB: the <emphasis>Admin Party</emphasis>, <emphasis>Basic
  Authentication</emphasis>, <emphasis>Cookie Authentication</emphasis>, and
  <emphasis>OAuth</emphasis>.</para><sect1 id="I_sect13_d1e10311"><title>The Admin Party</title><para>When you start out fresh, CouchDB allows any request to be made by
    anyone. Create a database? No problem, here you go. Delete some documents?
    Same deal. CouchDB calls this the <emphasis>Admin Party</emphasis>.
    Everybody has privileges to do anything. Neat.<indexterm id="I_indexterm3_d1e10319" significance="normal"><primary>admin party</primary></indexterm><indexterm class="startofrange" id="ch22_securityadmin" significance="normal"><primary>security</primary><secondary>admin party</secondary></indexterm></para><para>While it is incredibly easy to get started with CouchDB that way, it
    should be obvious that putting a default installation into the wild is
    adventurous. Any rogue client could come along and delete a
    database.</para><para>A note of relief: by default, CouchDB will listen only on your
    loopback network interface (<literal moreinfo="none">127.0.0.1</literal> or
    <literal moreinfo="none">localhost</literal>) and thus only you will be able to make
    requests to CouchDB, nobody else. But when you start to open up your
    CouchDB to the public (that is, by telling it to bind to your machine’s
    public IP address), you will want to think about restricting access so
    that the next bad guy doesn’t ruin your admin party.</para><para>In our previous discussions, w dropped some keywords about how
    things without the admin party work. First, there’s
    <emphasis>admin</emphasis> itself, which implies some sort of super user.
    Then there are <emphasis>privileges</emphasis>. Let’s explore these terms
    a little more.<indexterm id="I_indexterm3_d1e10345" significance="normal"><primary>privileges</primary></indexterm></para><para>CouchDB has the idea of an <emphasis>admin user</emphasis> (e.g. an
    administrator, a super user, or root) that is allowed to do anything to a
    CouchDB installation. By default, everybody is an admin. If you don’t like
    that, you can create specific admin users with a username and password as
    their credentials.<indexterm id="I_indexterm3_d1e10353" significance="normal"><primary>admin users</primary></indexterm></para><para>CouchDB also defines a set of requests that only admin users are
    allowed to do. If you have defined one or more specific admin users,
    CouchDB will ask for identification for certain requests:</para><itemizedlist><listitem><para>Creating a database (<literal moreinfo="none">PUT /database</literal>)</para></listitem><listitem><para>Deleting a database (<literal moreinfo="none">DELETE /database</literal>)</para></listitem><listitem><para>Creating a design document (<literal moreinfo="none">PUT
        /database/_design/app</literal>)</para></listitem><listitem><para>Updating a design document (<literal moreinfo="none">PUT
        /database/_design/app?rev=1-4E2</literal>)</para></listitem><listitem><para>Deleting a design document (<literal moreinfo="none">DELETE
        /database/_design/app?rev=1-6A7</literal>)</para></listitem><listitem><para>Triggering compaction (<literal moreinfo="none">POST /_compact</literal>)</para></listitem><listitem><para>Reading the task status list (<literal moreinfo="none">GET
        /_active_tasks</literal>)</para></listitem><listitem><para>Restarting the server (<literal moreinfo="none">POST /_restart</literal>)</para></listitem><listitem><para>Reading the active configuration (<literal moreinfo="none">GET
        /_config</literal>)</para></listitem><listitem><para>Updating the active configuration (<literal moreinfo="none">PUT
        /_config</literal>)</para></listitem></itemizedlist><sect2><title>Creating New Admin Users</title><para>Let’s do another walk through the API using
      <literal moreinfo="none">curl</literal> to see how CouchDB behaves when you add admin
      users.<indexterm id="I_indexterm3_d1e10427" significance="normal"><primary>admin users</primary><secondary>creating new</secondary></indexterm></para><screen format="linespecific">&gt; HOST="http://127.0.0.1:5984"
&gt; curl -X PUT $HOST/database
{"ok":true}</screen><para>When starting out fresh, we can add a database. Nothing
      unexpected. Now let’s create an admin user. We’ll call her
      <literal moreinfo="none">anna</literal>, and her password is <literal moreinfo="none">secret</literal>.
      Note the double quotes in the following code; they are needed to denote
      a string value for the configuration API (as we learned earlier):</para><screen format="linespecific">curl -X PUT $HOST/_config/admins/anna -d '"secret"'
""</screen><para>As per the <literal moreinfo="none">_config</literal> API’s behavior, we’re
      getting the previous value for the config item we just wrote. Since our
      admin user didn’t exist, we get an empty string.</para><para>When we now sneak over to the CouchDB log file, we find these two
      entries:</para><screen format="linespecific">[debug] [&lt;0.43.0&gt;] saving to file \
'/Users/jan/Work/couchdb-git/etc/couchdb/local_dev.ini', \
Config: '{{"admins","anna"},"secret"}'

[debug] [&lt;0.43.0&gt;] saving to file \
'/Users/jan/Work/couchdb-git/etc/couchdb/local_dev.ini', Config:\
'{{"admins","anna"}, \
"-hashed-6a1cc3760b4d09c150d44edf302ff40606221526,a69a9e4f0047be899ebfe09a40b2f52c"}'</screen><para>The first is our initial request. You see that our admin user gets
      written to the CouchDB configuration files. We set our CouchDB log level
      to <literal moreinfo="none">debug</literal> to see exactly what is going on. We first
      see the request coming in with a plain-text password and then again with
      a hashed password.</para></sect2><sect2><title>Hashing Passwords</title><para>Seeing the plain-text password is scary, isn’t it? No worries; in
      normal operation when the log level is not set to
      <literal moreinfo="none">debug</literal>, the plain-text password doesn’t show up
      anywhere. It gets hashed right away. The hash is that big, ugly, long
      string that starts out with <phrase role="keep-together"><literal moreinfo="none">-hashed-</literal>.</phrase> How does that
      work?<indexterm id="I_indexterm3_d1e10471" significance="normal"><primary>hashing</primary><secondary>passwords</secondary></indexterm><indexterm id="I_indexterm3_d1e10476" significance="normal"><primary>passwords</primary><secondary>hashing</secondary></indexterm></para><orderedlist numeration="arabic" inheritnum="ignore" continuation="restarts"><listitem><para>Creates a new 128-bit UUID. This is our
          <emphasis>salt</emphasis>.</para></listitem><listitem><para>Creates a sha1 hash of the concatenation of the bytes of the
          plain-text password and the salt (<literal moreinfo="none">sha1(password +
          salt)</literal>).</para></listitem><listitem><para>Prefixes the result with <literal moreinfo="none">-hashed-</literal> and
          appends <literal moreinfo="none">,salt</literal>.</para></listitem></orderedlist><para>To compare a plain-text password during authentication with the
      stored hash, the same procedure is run and the resulting hash is
      compared to the stored hash. The probability of two identical hashes for
      different passwords is too insignificant to mention (c.f. Bruce
      Schneier). Should the stored hash fall into the hands of an attacker, it
      is, by current standards, way too inconvenient (i.e., it’d take a lot of
      money and time) to find the plain-text password from the hash.</para><para>But what’s with the <literal moreinfo="none">-hashed-</literal> prefix? Well,
      remember how the configuration API works? When CouchDB starts up, it
      reads a set of <filename moreinfo="none">.ini</filename> files with config settings. It
      loads these settings into an internal data store (not a database). The
      config API lets you read the current configuration as well as change it
      and create new entries. CouchDB is writing any changes back to the
      <filename moreinfo="none">.ini</filename> files.<indexterm id="I_indexterm3_d1e10516" significance="normal"><primary sortas="ini">.ini files with configuration
          settings</primary></indexterm></para><para>The <filename moreinfo="none">.ini</filename> files can also be edited by hand
      when CouchDB is not running. Instead of creating the admin user as we
      showed previously, you could have stopped CouchDB, opened your
      <filename moreinfo="none">local.ini</filename>, added <literal moreinfo="none">anna = secret</literal>
      to the <literal moreinfo="none">[admins]</literal> section, and restarted CouchDB. Upon
      reading the new line from <filename moreinfo="none">local.ini</filename>, CouchDB would
      run the hashing algorithm and write back the hash to
      <filename moreinfo="none">local.ini</filename>, replacing the plain-text password. To
      make sure CouchDB only hashes plain-text passwords and not an existing
      hash a second time, it prefixes the hash with
      <literal moreinfo="none">-hashed-</literal>, to distinguish between plain-text passwords
      and hashed passwords. This means your plain-text password can’t start
      with the characters <literal moreinfo="none">-hashed-</literal>, but that’s pretty
      unlikely to begin with.<indexterm id="I_indexterm3_d1e10546" class="endofrange" startref="ch22_securityadmin" significance="normal"/></para></sect2></sect1><sect1 id="I_sect13_d1e10547"><title>Basic Authentication</title><para>Now that we have defined an admin, CouchDB will not allow us to
    create new databases unless we give the correct admin user credentials.
    Let’s verify:<indexterm class="startofrange" id="ch22_auth" significance="normal"><primary>authentication</primary><secondary>basic</secondary></indexterm><indexterm class="startofrange" id="ch22_securityauth" significance="normal"><primary>security</primary><secondary>basic authentication</secondary></indexterm></para><screen format="linespecific">&gt; curl -X PUT $HOST/somedatabase
{"error":"unauthorized","reason":"You are not a server admin."}</screen><para>That looks about right. Now we try again with the correct
    credentials:</para><screen format="linespecific">&gt; HOST="http://anna:secret@127.0.0.1:5984"
&gt; curl -X PUT $HOST/somedatabase
{"ok":true}</screen><para>If you have ever accessed a website or FTP server that was
    password-protected, the <literal role="keep-together" moreinfo="none">username:password@</literal> URL variant should look
    familiar.<indexterm id="I_indexterm3_d1e10573" significance="normal"><primary>passwords</primary><secondary>plain-text</secondary></indexterm></para><para>If you are security conscious, the missing <literal moreinfo="none">s</literal> in
    <literal moreinfo="none">http://</literal> will make you nervous. We’re sending our
    password to CouchDB in plain text. This is a bad thing, right? Yes, but
    consider our scenario: CouchDB listens on <literal moreinfo="none">127.0.0.1</literal> on
    a development box that we’re the sole user of. Who could possibly sniff
    our password?</para><para>If you are in a production environment, however, you need to
    reconsider. Will your CouchDB instance communicate over a public network?
    Even a LAN shared with other colocation customers is public. There are
    multiple ways to secure communication between you or your application and
    CouchDB that exceed the scope of this book. We suggest you read up on VPNs
    and setting up CouchDB behind an HTTP proxy (like Apache httpd’s
    mod_proxy, nginx, or varnish) that will handle SSL for you. CouchDB does
    not support exposing its API via SSL at the moment. It can, however,
    replicate with other CouchDB instances that are behind an SSL
    proxy.<indexterm id="I_indexterm3_d1e10591" significance="normal"><primary>proxies</primary><secondary>setting up CouchDB behind HTTP proxy</secondary></indexterm><indexterm id="I_indexterm3_d1e10596" significance="normal"><primary>SSL, CouchDB and</primary></indexterm></para><sect2><title>Update Validations Again</title><para>Do you remember <xref linkend="validationfunctions"/>? We had an
      update validation function that allowed us to verify that the claimed
      author of a document matched the authenticated username.<indexterm id="I_indexterm3_d1e10606" significance="normal"><primary>validation functions</primary><secondary>verifying author as authenticated user</secondary></indexterm></para><programlisting id="I_programlisting3_d1e10611" language="javascript" linenumbering="unnumbered" format="linespecific">function(newDoc, oldDoc, userCtx) {
  if (newDoc.author) {
    if(newDoc.author != userCtx.name) {
      throw("forbidden": "You may only update documents with author " +
        userCtx.name});
    }
  }
}</programlisting><para>What is this <literal moreinfo="none">userCtx</literal> exactly? It is an object
      filled with information about the current request’s authentication data.
      Let’s have a look at what’s in there. We’ll show you a simple trick how
      to introspect what’s going on in all the JavaScript you are
      writing.<indexterm id="I_indexterm3_d1e10618" significance="normal"><primary>userCtx (user context) object</primary></indexterm></para><screen format="linespecific">&gt; curl -X PUT $HOST/somedatabase/_design/log \
  -d '{"validate_doc_update":"function(newDoc, oldDoc, userCtx) { log(userCtx); }"}'
{"ok":true,"id":"_design/log","rev":"1-498bd568e17e93d247ca48439a368718"}</screen><para>Let’s show the <literal moreinfo="none">validate_doc_update</literal>
      function:<indexterm id="I_indexterm3_d1e10628" significance="normal"><primary>validate_doc_update function</primary></indexterm></para><programlisting id="I_programlisting3_d1e10631" language="javascript" linenumbering="unnumbered" format="linespecific">function(newDoc, oldDoc, userCtx) {
  log(userCtx);
}</programlisting><para>This gets called for every future document update and does nothing
      but print a log entry into CouchDB’s log file. If we now create a new
      document:</para><screen format="linespecific">&gt; curl -X POST $HOST/somedatabase/ -d '{"a":1}'
{"ok":true,"id":"36174efe5d455bd45fa1d51efbcff986",
"rev":"1-23202479633c2b380f79507a776743d5"}</screen><para>we should see this in our <filename moreinfo="none">couch.log</filename>
      file:</para><screen format="linespecific">[info] [&lt;0.9973.0&gt;] OS Process :: {"db": "somedatabase","name": "anna","roles": 
["_admin"]}</screen><para>Let’s format this again:</para><programlisting id="I_programlisting3_d1e10647" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "db": "somedatabase",
  "name": "anna",
  "roles": ["_admin"]
}</programlisting><para>We see the current database, the name of the authenticated user,
      and an array of <literal moreinfo="none">roles</literal>, with one role
      <literal moreinfo="none">"_admin"</literal>. We can conclude that admin users in CouchDB
      are really just <emphasis>regular users</emphasis> with the
      <emphasis>admin role</emphasis> attached to them.<indexterm id="I_indexterm3_d1e10663" significance="normal"><primary>admin role</primary></indexterm><indexterm id="I_indexterm3_d1e10666" significance="normal"><primary>roles and users</primary></indexterm><indexterm id="I_indexterm3_d1e10670" significance="normal"><primary>users and roles</primary></indexterm></para><para>By separating users and roles from each other, the authentication
      system allows for flexible extension. For now, we’ll just look at admin
      users.<indexterm id="I_indexterm3_d1e10675" class="endofrange" startref="ch22_auth" significance="normal"/><indexterm id="I_indexterm3_d1e10676" class="endofrange" startref="ch22_securityauth" significance="normal"/></para></sect2></sect1><sect1 id="I_sect13_d1e10677"><title>Cookie Authentication</title><para>Basic authentication that uses plain-text passwords is nice and
    convenient, but not very secure if no extra measures are taken. It is also
    a very poor user experience. If you use basic authentication to identify
    admins, your application’s users need to deal with an ugly, unstylable
    browser modal dialog that says <emphasis>non-professional at
    work</emphasis> more than anything else.<indexterm class="startofrange" id="ch22_cookieauth" significance="normal"><primary>cookie authentication</primary></indexterm><indexterm class="startofrange" id="ch22_securitycookieauth" significance="normal"><primary>security</primary><secondary>cookie authentication</secondary></indexterm><indexterm class="startofrange" id="ch22_authcookie" significance="normal"><primary>authentication</primary><secondary>cookie</secondary></indexterm></para><para>To remedy some of these concerns, CouchDB supports <emphasis>cookie
    authentication</emphasis>. With cookie authentication your application
    doesn’t have to include the ugly login dialog that the users’ browsers
    come with. You can use a regular HTML form to submit logins to CouchDB.
    Upon receipt, CouchDB will generate a one-time token that the client can
    use in its next request to CouchDB. When CouchDB sees the token in a
    subsequent request, it will authenticate the user based on the token
    without the need to see the password again. By default, a token is valid
    for 10 minutes.<indexterm id="I_indexterm3_d1e10703" significance="normal"><primary>tokens</primary></indexterm></para><para>To obtain the first token and thus authenticate a user for the first
    time, the username and password must be sent to the
    <literal moreinfo="none">_session</literal> API. The API is smart enough to decode HTML
    form submissions, so you don’t have to resort to any smarts in your
    application.</para><para>If you are not using HTML forms to log in, you need to send an HTTP
    request that looks as if an HTML form generated it. Luckily, this is super
    simple:</para><screen format="linespecific">&gt; HOST="http://127.0.0.1:5984"
&gt; curl -vX POST $HOST/_session \
  -H 'application/x-www-form-urlencoded' \
  -d 'username=anna&amp;password=secret'</screen><?dbfo-need height=”1in”
?><para>CouchDB replies, and we’ll give you some more detail:</para><screen format="linespecific">&lt; HTTP/1.1 200 OK
&lt; Set-Cookie: AuthSession=YW5uYTo0QUIzOTdFQjrC4ipN-D-53hw1sJepVzcVxnriEw; 
&lt; Version=1; Path=/; HttpOnly
&gt; ...
&lt;
{"ok":true}</screen><para>A <literal moreinfo="none">200</literal> response code tells us all is well, a
    <literal moreinfo="none">Set-Cookie</literal> header includes the token we can use for the
    next request, and the standard JSON response tells us again that the
    request was successful.<indexterm id="I_indexterm3_d1e10728" significance="normal"><primary>headers</primary><secondary>Set-Cookie header</secondary></indexterm><indexterm id="I_indexterm3_d1e10733" significance="normal"><primary>Set-Cookie header</primary></indexterm></para><para>Now we can use this token to make another request as the same user
    without sending the username and password again:</para><screen format="linespecific">&gt; curl -vX PUT $HOST/mydatabase \
  --cookie AuthSession=YW5uYTo0QUIzOTdFQjrC4ipN-D-53hw1sJepVzcVxnriEw \
  -H "X-CouchDB-WWW-Authenticate: Cookie" \
  -H "Content-Type: application/x-www-form-urlencoded"
{"ok":true}</screen><para>You can keep using this token for 10 minutes by default. After 10
    minutes you need to authenticate your user again. The token lifetime can
    be configured with the <literal moreinfo="none">timeout</literal> (in seconds) setting in
    the <literal moreinfo="none">couch_httpd_auth</literal> configuration section.<indexterm id="I_indexterm3_d1e10749" significance="normal"><primary>couch_httpd_auth configuration</primary></indexterm></para><warning><para>Please note that for cookie authentication to work, you need to
      enable the <literal moreinfo="none">cookie_authentication_handler</literal> in your
      <filename moreinfo="none">local.ini</filename>:<indexterm id="I_indexterm3_d1e10761" significance="normal"><primary>cookie_authentication_handler, enabling</primary></indexterm></para><screen format="linespecific">[httpd]
authentication_handlers = \
  {couch_httpd_auth, cookie_authentication_handler}, \
  {couch_httpd_oauth, oauth_authentication_handler}, \
  {couch_httpd_auth, default_authentication_handler}</screen><para>In addition, you need to define a <emphasis>server
      secret</emphasis>:</para><screen format="linespecific">[couch_httpd_auth]<indexterm id="I_indexterm3_d1e10773" significance="normal"><primary>server secret</primary></indexterm>
secret = yours3cr37pr4s3</screen></warning></sect1><sect1 id="I_sect13_d1e10777"><title>Network Server Security</title><para>CouchDB is a networked server, and there are best practices for
    securing these that are beyond the scope of this book. <xref linkend="installingfromsource"/> includes some of those best practices.
    Make sure to understand the implications.<indexterm id="I_indexterm3_d1e10784" class="endofrange" startref="ch22_securitycookieauth" significance="normal"/><indexterm id="I_indexterm3_d1e10785" class="endofrange" startref="ch22_authcookie" significance="normal"/><indexterm id="I_indexterm3_d1e10786" class="endofrange" startref="ch22_cookieauth" significance="normal"/><indexterm id="I_indexterm3_d1e10787" class="endofrange" startref="ch22_security" significance="normal"/></para></sect1></chapter><chapter id="highperformance"><title>High Performance</title><para>This chapter will teach you the fastest ways to insert and query data
  with CouchDB. It will also explain why there is a wide range of performance
  across various techniques.<indexterm class="startofrange" id="ch23_performance" significance="normal"><primary>performance</primary></indexterm></para><para>The take-home message: bulk operations result in lower overhead,
  higher throughput, and more space efficiency. If you can’t work in bulk in
  your application, we’ll also describe other options to get throughput and
  space benefits. Finally, we describe interfacing directly with CouchDB from
  Erlang, which can be a useful technique if you want to integrate CouchDB
  storage with a server for non-HTTP protocols, like SMTP (email) or XMPP
  (chat).<indexterm id="I_indexterm4_d1e10798" significance="normal"><primary>Erlang</primary></indexterm><indexterm id="I_indexterm4_d1e10801" significance="normal"><primary>high performance</primary><see>performance</see></indexterm></para><sect1 id="I_sect14_d1e10806"><title>Good Benchmarks Are Non-Trivial</title><para>Each application is different. Performance requirements are not
    always obvious. Different use cases need to tune different parameters. A
    classic trade-off is latency versus throughput. Concurrency is another
    factor. Many database platforms behave very differently with 100 clients
    than they do with 1,000 or more concurrent clients. Some data profiles
    require serialized operations, which increase total time (latency) for the
    client, and load on the server. We think simpler data and access patterns
    can make a big difference in the cacheability and scalability of your app,
    but we’ll get to that later.<indexterm id="I_indexterm4_d1e10811" significance="normal"><primary>benchmarks</primary></indexterm><indexterm id="I_indexterm4_d1e10814" significance="normal"><primary>performance</primary><secondary>good benchmarks</secondary></indexterm></para><para>The upshot: <emphasis>real benchmarks require real-world
    load.</emphasis> Simulating load is hard. Erlang tends to perform better
    under load (especially on multiple cores), so we’ve often seen test rigs
    that can’t drive CouchDB hard enough to see where it falls over.</para><para>Let’s take a look at what a typical web app looks like. This is not
    exactly how Craigslist works (because we don’t know how Craigslist works),
    but it is a close enough approximation to illustrate problems with
    benchmarking.</para><para>You have a web server, some middleware, and a database. A user
    request comes in, and the web server takes care of the networking and
    parses the HTTP request. The request gets handed to the middleware layer,
    which figures out what to run, then it runs whatever is needed to serve
    the request. The middleware might talk to your database and other external
    resources like files or remote web services. The request bounces back to
    the web server, which sends out any resulting HTML. The HTML includes
    references to other resources living on your web server (like CSS, JS, or
    image files), and the process starts anew for every resource. A little
    different each time, but in general, all requests are similar. And along
    the way there are caches to store intermediate results to avoid expensive
    recomputation.</para><para>That’s a lot of moving parts. Getting a top-to-bottom profile of all
    components to figure out where bottlenecks lie is pretty complex (but nice
    to have). We start making up numbers now. The absolute values are not
    important; only numbers relative to each other are. Say a request takes
    1.5 seconds (1,500 ms) to be fully rendered in a browser.</para><para>In a simple case like Craigslist, there is the initial HTML, a CSS
    file, a JS file, and the favicon. Except for the HTML, these are all
    static resources and involve reading some data from a disk (or from
    memory) and serving it to the browser that then renders it. The most
    notable things to do for performance are keeping data small (GZIP
    compression, high JPG compression) and avoiding requests all together
    (HTTP-level caching in the browser). Making the web server any faster
    doesn’t buy us much (yeah, hand wavey, but we don’t want to focus on
    static resources here). Let’s say all static resources take 500 ms to
    serve and render.<indexterm id="I_indexterm4_d1e10832" significance="normal"><primary>HTTP</primary><secondary>proper use of, improving client experience</secondary></indexterm></para><note><para>Read all about improving client experience with proper use of HTTP
      from Steve <phrase role="keep-together">Souders,</phrase> web
      performance guru. His YSlow tool is indispensable for tuning a
      website.</para></note><para>That leaves us with 1,000 ms for the initial HTML. We’ll chop off
    200 ms for network latency (see <xref linkend="whycouchdb"/>). Let’s
    pretend HTTP parsing, middleware routing and execution, and database
    access share equally the rest of the time, 200 ms each.</para><para>If you now set out to improve one part of the big puzzle that is
    your web app and gain 10 ms in the database access time, this is probably
    time not well spent (unless you have the numbers to prove it).</para><para>However, breaking down a single request like this and looking for
    how much time is spent in each component is also misleading. Even if only
    a small percentage of the time is spent in your database under normal
    load, that doesn’t teach you what will happen during traffic spikes. If
    all requests are hitting the same database, then any locking there could
    block many web requests. Your database may have minimal impact on total
    query time, under normal load, but under spike load it may turn into a
    bottleneck, magnifying the effect of the spike on the application servers.
    CouchDB can minimize this by dedicating an Erlang process to each
    connection, ensuring that all clients are handled, even if latency goes up
    a bit.</para></sect1><sect1 id="I_sect14_d1e10851"><title>High Performance CouchDB</title><para>Now that you see database performance is only a small part of
    overall web performance, we’ll give you some tips to squeeze the most out
    of CouchDB.</para><para>CouchDB is designed from the ground up to service highly concurrent
    use cases, which make up the majority of web application load. However,
    sometimes we need to import a large batch of data into CouchDB or initiate
    transforms across an entire database. Or maybe we’re building a custom
    Erlang application that needs to link into CouchDB at a lower level than
    HTTP.</para><sect2><title>Hardware</title><para>Invariably people will want to know what type of disk they should
      use, how much RAM, what sort of CPU, etc. The real answer is that
      CouchDB is flexible enough to run on everything from a smart phone to a
      cluster, so the answers will vary.<indexterm id="I_indexterm4_d1e10863" significance="normal"><primary>hardware, performance and</primary></indexterm><indexterm id="I_indexterm4_d1e10866" significance="normal"><primary>performance</primary><secondary>hardware</secondary></indexterm></para><para>More RAM is better because CouchDB makes heavy use of the
      filesystem cache. CPU cores are more important for building views than
      serving documents. Solid State Drives (SSDs) are pretty sweet because
      they can append to a file while loading old blocks, with a minimum of
      overhead. As they get faster and cheaper, they’ll be really handy for
      CouchDB.<indexterm id="I_indexterm4_d1e10873" significance="normal"><primary>RAM for CouchDB</primary></indexterm></para></sect2><sect2><title>An Implementation Note</title><para>We’re not going to rehash append-only B-trees here, but
      understanding CouchDB’s data format is key to gaining an intuition about
      which strategies yield the best performance. Each time an update is
      made, CouchDB loads from disk the B-tree nodes that point to the updated
      documents or the key range where a new document’s <literal moreinfo="none">_id</literal>
      would be found.<indexterm id="I_indexterm4_d1e10884" significance="normal"><primary>performance</primary><secondary>data format and</secondary></indexterm><indexterm id="I_indexterm4_d1e10889" significance="normal"><primary>B-trees</primary><secondary>performance and</secondary></indexterm><indexterm id="I_indexterm4_d1e10894" significance="normal"><primary>data format, performance and</primary></indexterm></para><para>This loading will normally come from the filesystem cache, except
      when updates are made to documents in regions of the tree that have not
      been touched in a long time. In those cases, the disk has to seek, which
      can block writing and have other ripple effects. Preventing these disk
      seeks is the name of the game in CouchDB performance.</para><para>We’ll use some numbers in this chapter that come from a JavaScript
      test suite. It’s not the most accurate, but the strategy it uses
      (counting the number of documents that can be saved in 10 seconds) makes
      up for the JavaScript overhead. The hardware the benchmarks were run on
      is modest: just an old white MacBook Intel Core 2 Duo (<phrase role="keep-together">remember</phrase> those?).</para><para>You can run the benchmarks yourself by changing to the
      <filename moreinfo="none">bench/</filename> directory of CouchDB’s trunk and running
      <filename moreinfo="none">./runner.sh</filename> while CouchDB is running on port
      5984.</para></sect2></sect1><sect1 id="I_sect14_d1e10912"><title>Bulk Inserts and Mostly Monotonic DocIDs</title><para>Bulk inserts are the best way to have seekless writes. Random IDs
    force seeking after the file is bigger than can be cached. Random IDs also
    make for a bigger file because in a large database you’ll rarely have
    multiple documents in one B-tree leaf.<indexterm id="I_indexterm4_d1e10917" significance="normal"><primary>document IDs</primary><secondary>monotonic, bulk inserts and</secondary></indexterm><indexterm id="I_indexterm4_d1e10922" significance="normal"><primary>bulk inserts</primary></indexterm><indexterm id="I_indexterm4_d1e10925" significance="normal"><primary>performance</primary><secondary>bulk inserts and monotonic document IDs</secondary></indexterm></para><sect2><title>Optimized Examples: Views and Replication</title><para>If you’re curious what a good performance profile is for CouchDB,
      look at how views and replication are done. Triggered replication
      applies updates to the database in large batches to minimize disk
      chatter. Currently the 0.11.0 development trunk boasts an additional
      3–5x speed increase over 0.10’s view generation.<indexterm id="I_indexterm4_d1e10935" significance="normal"><primary>replication</primary><secondary>performance optimization</secondary></indexterm><indexterm id="I_indexterm4_d1e10940" significance="normal"><primary>views</primary><secondary>performance optimization</secondary></indexterm></para><para>Views load a batch of updates from disk, pass them through the
      view engine, and then write the view rows out. Each batch is a few
      hundred documents, so the writer can take advantage of the bulk
      efficiencies we see in the next section.</para></sect2></sect1><sect1 id="I_sect14_d1e10947"><title>Bulk Document Inserts</title><para>The fastest mode for importing data into CouchDB via HTTP is the
    <literal moreinfo="none">_bulk_docs</literal> endpoint. The bulk documents API accepts a
    collection of documents in a single <literal moreinfo="none">POST</literal> request and
    stores them all to CouchDB in a single index operation.<indexterm id="I_indexterm4_d1e10958" significance="normal"><primary>performance</primary><secondary>bulk document inserts</secondary></indexterm><indexterm id="I_indexterm4_d1e10963" significance="normal"><primary sortas="bulk docs endpoint">_bulk_docs endpoint</primary></indexterm><indexterm id="I_indexterm4_d1e10966" significance="normal"><primary>bulk inserts</primary><secondary>bulk document inserts into CouchDB</secondary></indexterm></para><para>Bulk docs is the API to use when you are importing a corpus of data
    using a scripting language. It can be 10 to 100 times faster than
    individual bulk updates and is just as easy to work with from most
    languages.</para><para>The main factor that influences performance of bulk operations is
    the size of the update, both in terms of total data transferred as well as
    the number of documents included in an update.</para><para>Here are sequential bulk document inserts at four different
    granularities, from an array of 100 documents, up through 1,000, 5,000,
    and 10,000:</para><screen format="linespecific">bulk_doc_100
4400 docs
437.37574552683895 docs/sec</screen><screen format="linespecific">bulk_doc_1000
17000 docs
1635.4016354016355 docs/sec</screen><screen format="linespecific">bulk_doc_5000
30000 docs
2508.1514923501377 docs/sec</screen><screen format="linespecific">bulk_doc_10000
30000 docs
2699.541078016737 docs/sec</screen><para>You can see that larger batches yield better performance, with an
    upper limit in this test of 2,700 documents/second. With larger documents,
    we might see that smaller batches are more useful. For references, all the
    documents look like this: <literal moreinfo="none">{"foo":"bar"}</literal></para><para>Although 2,700 documents per second is fine, we want more power!
    Next up, we’ll explore running bulk documents in parallel.</para><para>With a different script (using bash and <emphasis>cURL</emphasis>
    with <filename moreinfo="none">benchbulk.sh</filename> in the same directory), we’re
    inserting large batches of documents in parallel to CouchDB. With batches
    of 1,000 docs, 10 at any given time, averaged over 10 rounds, I see about
    3,650 documents per second on a MacBook Pro. Benchbulk also uses
    sequential IDs.</para><para>We see that with proper use of bulk documents and sequential IDs, we
    can insert more than 3,000 docs per second just using scripting
    languages.</para></sect1><sect1 id="I_sect14_d1e11002"><title>Batch Mode</title><para>To avoid the indexing and disk sync overhead associated with
    individual document writes, there is an option that allows CouchDB to
    build up batches of documents in memory, flushing them to disk when a
    certain threshold has been reached or when triggered by the user. The
    batch option does not give the same data integrity guarantees that normal
    updates provide, so it should only be used when the potential loss of
    recent updates is acceptable.<indexterm id="I_indexterm4_d1e11007" significance="normal"><primary>performance</primary><secondary>using batch mode</secondary></indexterm><indexterm id="I_indexterm4_d1e11012" significance="normal"><primary>batch mode</primary></indexterm></para><para>Because batch mode only stores updates in memory until a flush
    occurs, updates that are saved to CouchDB directly proceeding a crash can
    be lost. By default, CouchDB flushes the in-memory updates once per
    second, so in the worst case, data loss is still minimal. To reflect the
    reduced integrity guarantees when <literal moreinfo="none">batch=ok</literal> is used, the
    HTTP response code is 202 Accepted, as opposed to 201 Created.</para><para>The ideal use for batch mode is for logging type applications, where
    you have many distributed writers each storing discrete events to CouchDB.
    In a normal logging scenario, losing a few updates on rare occasions is
    worth the trade-off for increased storage throughput.</para><para>There is a pattern for reliable storage using batch mode. It’s the
    same pattern as is used when data needs to be stored reliably to multiple
    nodes before acknowledging success to the saving client. In a nutshell,
    the application server (or remote client) saves to Couch A using
    <literal moreinfo="none">batch=ok</literal>, and then watches update notifications from
    Couch B, only considering the save successful when Couch B’s
    <literal moreinfo="none">_changes</literal> stream includes the relevant update. We
    covered this pattern in detail in <xref linkend="replication"/>.</para><screen format="linespecific">batch_ok_doc_insert
4851 docs
485.00299940011996 docs/sec</screen><para>This JavaScript benchmark only gets around 500 documents per second,
    six times slower than the bulk document API. However, it has the advantage
    that clients don’t need to build up bulk batches.</para></sect1><sect1 id="I_sect14_d1e11036"><title>Single Document Inserts</title><para>Normal web app load for CouchDB comes in the form of single document
    inserts. Because each insert comes from a distinct client, and has the
    overhead of an entire HTTP request and response, it generally has the
    lowest throughput for writes.<indexterm id="I_indexterm4_d1e11041" significance="normal"><primary>performance</primary><secondary>single document inserts</secondary></indexterm><indexterm id="I_indexterm4_d1e11046" significance="normal"><primary>single document inserts</primary></indexterm><indexterm id="I_indexterm4_d1e11049" significance="normal"><primary>inserts, single document</primary></indexterm></para><para>Probably the slowest possible use case for CouchDB is the case of a
    writer that has to make many serialized writes against the database.
    Imagine a case where each write depends on the result of the previous
    write so that only one writer can run. This sounds like a bad case from
    the description alone. If you find yourself in this position, there are
    probably other problems to address as well.</para><para>We can write about 258 documents per second with a single writer in
    serial (pretty much the worst-case scenario writer).<indexterm id="I_indexterm4_d1e11056" significance="normal"><primary>single document inserts</primary><seealso>bulk inserts</seealso></indexterm><indexterm id="I_indexterm4_d1e11061" significance="normal"><primary>inserts, single document</primary><seealso>bulk inserts</seealso></indexterm></para><screen format="linespecific">single_doc_insert
2584 docs
257.9357157117189 docs/sec</screen><para>Delayed commit (along with sequential UUIDs) is probably the most
    important CouchDB configuration setting for performance. When it is set to
    true (the default), CouchDB allows operations to be run against the disk
    without an explicit fsync after each operation. Fsync operations take time
    (the disk may have to seek, on some platforms the hard disk cache buffer
    is flushed, etc.), so requiring an fsync for each update deeply limits
    CouchDB’s performance for non-bulk writers.<indexterm id="I_indexterm4_d1e11070" significance="normal"><primary>commit</primary><secondary>delayed</secondary></indexterm><indexterm id="I_indexterm4_d1e11075" significance="normal"><primary>UUIDs (universally unique identifiers)</primary><secondary>sequential, performance and</secondary></indexterm></para><para>Delayed commit should be left set to <literal moreinfo="none">true</literal> in the
    configuration settings, unless you are in an environment where you
    absolutely need to know when updates have been received (such as when
    CouchDB is running as part of a larger transaction). It is also possible
    to trigger an fsync (e.g., after a few operations) using the <literal role="keep-together" moreinfo="none">_ensure_full_commit</literal> API.<indexterm id="I_indexterm4_d1e11088" significance="normal"><primary>commit</primary><secondary>full</secondary></indexterm><indexterm id="I_indexterm4_d1e11093" significance="normal"><primary>full commit</primary></indexterm><indexterm id="I_indexterm4_d1e11096" significance="normal"><primary>fsync, triggering</primary></indexterm><indexterm id="I_indexterm4_d1e11099" significance="normal"><primary sortas="ensure full commit API">_ensure_full_commit
        API</primary></indexterm></para><para>When delayed commit is disabled, CouchDB writes data to the actual
    disk before it responds to the client (except in
    <literal moreinfo="none">batch=ok</literal> mode). It’s a simpler code path, so it has
    less overhead when running at high throughput levels. However, for
    individual clients, it can seem slow. Here’s the same benchmark in full
    commit mode:</para><screen format="linespecific">single_doc_insert
46 docs
4.583042741855135 docs/sec</screen><para>Look at how slow <literal moreinfo="none">single_doc_insert</literal> is with
    full-commit enabled—four or five documents per second! That’s 100% a
    result of the fact that Mac OS X has a real fsync, so be thankful! Don’t
    worry; the full commit story gets better as we move into bulk <phrase role="keep-together">operations</phrase>.</para><para>On the other hand, we’re getting better times for large bulks with
    delayed commit off, which lets us know that <emphasis>tuning for your
    application</emphasis> will always bring better results than following a
    cookbook.</para></sect1><sect1 id="I_sect14_d1e11122"><title>Hovercraft</title><para>Hovercraft is a library for accessing CouchDB from within Erlang.
    Hovercraft benchmarks should show the fastest possible performance of
    CouchDB’s disk and index subsystems, as it avoids all HTTP connection and
    JSON conversion overhead.<indexterm id="I_indexterm4_d1e11127" significance="normal"><primary>performance</primary><secondary>using Hovercraft library</secondary></indexterm><indexterm id="I_indexterm4_d1e11132" significance="normal"><primary>Erlang</primary><secondary>assessing CouchDB from within, using Hovercraft</secondary></indexterm><indexterm id="I_indexterm4_d1e11137" significance="normal"><primary>Hovercraft</primary></indexterm></para><para>Hovercraft is useful primarily when the HTTP interface doesn’t allow
    for enough control, or is otherwise redundant. For instance, persisting
    Jabber instant messages to CouchDB might use ejabberd and Hovercraft. The
    easiest way to create a <phrase role="keep-together">failure-</phrase>tolerant message queue is probably a
    combination of RabbitMQ and Hovercraft.<indexterm id="I_indexterm4_d1e11145" significance="normal"><primary>message queue, failure-tolerant</primary></indexterm></para><para>Hovercraft was extracted from a client project that used CouchDB to
    store massive amounts of email as document attachments. HTTP doesn’t have
    an easy mechanism to allow a combination of bulk updates with binary
    attachments, so we used Hovercraft to connect an Erlang SMTP server
    directly to CouchDB, to stream attachments directly to disk while
    maintaining the efficiency of bulk index updates.</para><para>Hovercraft includes a basic benchmarking feature, and we see that we
    can get many documents per second.<indexterm id="I_indexterm4_d1e11152" significance="normal"><primary>benchmarks</primary><secondary>Hovercraft benchmarking feature</secondary></indexterm></para><screen format="linespecific">&gt; hovercraft:lightning().
Inserted 100000 docs in 9.37 seconds with batch size of 1000.
(10672 docs/sec)</screen></sect1><sect1 id="I_sect14_d1e11159"><title>Trade-Offs</title><para>Tool X might give you 5 ms response times, an order of magnitude
    faster than anything else on the market. Programming is all about
    trade-offs, and everybody is bound by the same laws.<indexterm id="I_indexterm4_d1e11164" significance="normal"><primary>performance</primary><secondary>trade-offs, expense for speed</secondary></indexterm></para><para>On the outside, it might appear that everybody who is not using Tool
    X is a fool. But speed and latency are only part of the picture. We
    already established that going from 5 ms to 50 ms might not even be
    noticeable by anyone using your product. Speed may come at the expense of
    other things, such as:</para><variablelist><varlistentry><term>Memory</term><listitem><para>Instead of doing computations over and over, Tool X might have
          a cute caching layer that saves recomputation by storing results in
          memory. If you are CPU bound, that might be good; if you are memory
          bound, it might not. A trade-off.<indexterm id="I_indexterm4_d1e11178" significance="normal"><primary>memory, performance and</primary></indexterm></para></listitem></varlistentry><varlistentry><term>Concurrency</term><listitem><para>The clever data structures in Tool X are extremely fast when
          only one request at a time is processed, and because it is so fast
          most of the time, it appears as if it would process multiple
          requests in parallel. Eventually, though, a high number of
          concurrent requests fill up the request queue and response time
          suffers. A variation on this is that Tool X might work exceptionally
          well on a single CPU or core, but not on many, leaving your beefy
          servers idling.<indexterm id="I_indexterm4_d1e11187" significance="normal"><primary>concurrency, performance and</primary></indexterm></para></listitem></varlistentry><varlistentry><term>Reliability</term><listitem><para>Making sure data is actually stored is an expensive operation.
          Making sure a data store is in a consistent state and not corrupted
          is another. There are two trade-offs here. First, buffers store data
          in memory before committing it to disk to ensure a higher data
          throughput. In the event of a power loss or crash (of hard- or
          software), the data is gone. This may or may not be acceptable for
          your application. Second, a consistency check is required to run
          after a failure, and if you have a lot of data, this can take days.
          If you can afford to be offline, that’s OK, but maybe you can’t
          afford it.<indexterm id="I_indexterm4_d1e11196" significance="normal"><primary>reliability, performance and</primary></indexterm></para></listitem></varlistentry></variablelist><para>Make sure to understand what requirements you have and pick the tool
    that complies instead of picking the one that has the prettiest numbers.
    Who’s the fool when your web application is offline for a fixup for a day
    while your customers impatiently wait to get their jobs done or, worse,
    you lose their data?</para><sect2><title>But…My Boss Wants Numbers!</title><para>You want to know which one of these databases, caches, programming
      languages, language constructs, or tools is faster, harder, or stronger.
      Numbers are cool—you can draw pretty graphs that management types can
      compare and make decisions from.</para><para>But the first thing a good executive knows is that she is
      operating on insufficient data, as diagrams drawn from numbers are a
      very distilled view of reality. And graphs from numbers that are made up
      by bad profiling are effectively fantasies.</para><para>If you are going to produce numbers, make sure you understand how
      much information is and isn’t covered by your results. Before passing
      the numbers on, make sure the receiving person knows it too. Again, the
      best thing to do is test with something as close to real-world load as
      possible. And that isn’t easy.</para></sect2><sect2><title>A Call to Arms</title><para>We’re in the market for databases and key/value stores. Every
      solution has a sweet spot in terms of data, hardware, setup, and
      operation, and there are enough permutations that you can pick the one
      that is closest to your problem. But how to find out? Ideally, you
      download and install all possible candidates, create a profiling test
      suite with proper testing data, make extensive tests, and compare the
      results. This can easily take weeks, and you might not have that much
      time.</para><para>We would like to ask developers of storage systems to compile a
      set of profiling suites that simulate different usage patterns of their
      systems (read-heavy and write-heavy loads, fault tolerance, distributed
      operation, and many more). A fault-tolerance suite should include the
      steps necessary to get data live again, such as any rebuild or checkup
      time. We would like users of these systems to help their developers find
      out how to reliably measure different scenarios.</para><para>We are working on CouchDB, and we’d like very much to have such a
      suite! Even better, developers could agree (a far-fetched idea, to be
      sure) on a set of benchmarks that objectively measure performance for
      easy comparison. We know this is a lot of work and the results may still
      be questionable, but it’ll help our users a great deal when figuring out
      what to use.<indexterm id="I_indexterm4_d1e11219" class="endofrange" startref="ch23_performance" significance="normal"/></para></sect2></sect1></chapter><chapter id="recipes"><title>Recipes</title><para>This chapter shows some common tasks and how to solve them with
  CouchDB using best practices and easy-to-follow step-by-step
  instructions.<indexterm id="I_indexterm5_d1e11225" significance="normal"><primary>recipes</primary><see>tasks and solutions using CouchDB</see></indexterm><indexterm class="startofrange" id="ch24_tasks" significance="normal"><primary>tasks and solutions using CouchDB</primary></indexterm></para><sect1 id="I_sect15_d1e11233"><title>Banking</title><para>Banks are serious business. They need serious databases to store
    serious transactions and serious account information. They can’t lose any
    money. Ever. They also can’t create money. A bank must be in balance. All
    the time.<indexterm class="startofrange" id="ch24_banking" significance="normal"><primary>banking, using CouchDB</primary></indexterm><indexterm class="startofrange" id="ch24_tasksbanking" significance="normal"><primary>tasks and solutions using CouchDB</primary><secondary>banking</secondary></indexterm></para><para>Conventional wisdom says a database needs to support
    <emphasis>transactions</emphasis> to be taken seriously. CouchDB does not
    support transactions in the traditional sense (although it works
    transactionally), so you could conclude CouchDB is not well suited to
    store bank data. Besides, would you trust your money to a couch? Well, we
    would. This chapter explains why.<indexterm id="I_indexterm5_d1e11251" significance="normal"><primary>transactions</primary></indexterm></para><sect2><title>Accountants Don’t Use Erasers</title><para>Say you want to give $100 to your cousin Paul for the New York
      cheesecake he sent to you. Back in the day, you had to travel all the
      way to New York and hand Paul the money, or you could send it via
      (paper) mail. Both methods were considerably inconvenient, so people
      started looking for alternatives. At one point, banks offered to take
      care of the money and make sure it arrived at Paul’s bank safely without
      headaches. Of course, they’d charge for the convenience, but you’d be
      happy to pay a little fee if it could save a trip to New York. Behind
      the scenes, the bank would send somebody with your money to give it to
      Paul’s bank—the same procedure, but another person was dealing with the
      trouble. Banks could also batch money transfers; instead of sending each
      order on its own, they could collect all transfers to New York for a
      week and send them all at once. In case of any problems—say, the
      recipient was no longer a customer of the bank (remember, it used to
      take weeks to travel from one coast to the other)—the money was sent
      back to the originating account.</para><para>Eventually, the modern banking system was put in place and the
      actual sending of money back and forth could be stopped (much to the
      disdain of highwaymen). Banks had money <emphasis>on paper</emphasis>,
      which they could send around without actually sending valuables. The old
      concept is stuck in our heads though. To send somebody money from our
      bank account, the bank needs to take the notes out of the account and
      bring them to the receiving account. But nowadays we’re used to things
      happen instantaneously. It takes just a few clicks to order goods from
      Amazon and have them placed into the mail, so why should a banking
      transaction take any longer?</para><para>Banks are all electronic these days (and have been for a while).
      When we issue a money transfer, we expect it to go through immediately,
      and we expect it to work in the way it worked back in the day: take
      money from my account, add it to Paul’s account, and if anything goes
      wrong, put it back in my account. While this is logically what happens,
      that’s not quite how it works behind the scenes, and hasn’t since way
      before computers were used for banking.</para><para>When you go to your bank and ask it to send money to Paul, the
      accountant will <emphasis>start a transaction</emphasis> by noting down
      that you ordered the sending of the money. The transaction will include
      the date, amount, and recipient. Remember that banks always need to be
      in balance. The money taken from your account cannot vanish. The
      accountant will move the money into an <emphasis>in-transit</emphasis>
      account that the bank maintains for you. Your account balance at this
      point is an aggregation of your current balance and the transactions in
      the in-transit account. Now the bank checks whether Paul’s account is
      what you say it is and whether the money could arrive there safely. If
      that’s the case, the money is moved in another single transaction from
      the in-transit account to Paul’s account. Everything is in balance.
      Notice how there are multiple independent transactions, not one big
      transaction that combines a number of actions.</para><para>Now let’s consider an error case: say Paul’s account no longer
      exists. The bank finds this out while performing the batch operation of
      all the in-transit transactions that need to be performed. A second
      transaction is generated that moves the money back from the in-transit
      account to your bank account. Note that the transaction that moved the
      money out of your account is <emphasis>not</emphasis> undone. Rather, a
      second transaction that does the reverse action is created.</para><para>Here’s another error case: say you don’t have sufficient funds to
      send $100 to Paul. This will be checked by the accountant (or software)
      before the bank creates any money-deducting <phrase role="keep-together">transaction.</phrase> For accountability, a bank
      cannot pretend an action didn’t happen; it has to record every action
      minutely in a log. Undoing is done explicitly by performing a reverse
      action, not by reverting or removing an existing transaction.
      “Accountants don’t use erasers” is a quote from Pat Helland, a senior
      architect of transactional systems who worked at Microsoft and
      Amazon.</para><para>To rehash, a <emphasis>transaction</emphasis> can succeed or fail,
      but nothing in between. The only operation that CouchDB guarantees to
      have succeed or fail is a single document write. All operations that
      comprise a transaction need to be combined into a single document. If
      business logic detects that an error occurred (e.g., not enough funds),
      a reverse transaction needs to be created.<indexterm id="I_indexterm5_d1e11289" significance="normal"><primary>transactions</primary><secondary>modeling smaller transactions using CouchDB</secondary></indexterm></para><para>Let’s look at a CouchDB example. We mentioned earlier that your
      account balance is an aggregated value. If we stick to this picture,
      things become downright easy. Instead of updating the balance of two
      accounts (yours and Paul’s, or yours and the in-transit account), we
      simply create a single transaction document that describes what we’re
      doing and use a view to aggregate your account balance.</para><para>Let’s consider a bunch of transactions:</para><programlisting id="I_programlisting5_d1e11298" language="javascript" linenumbering="unnumbered" format="linespecific">...
{"from":"Jan","to":"Paul","amount":100}
{"from":"Paul","to":"Steve","amount":20}
{"from":"Work","to":"Jan","amount":200}
...</programlisting><para>Single document writes in CouchDB are atomic. Querying a view
      forces an update to the view index with all changes to all documents.
      The view result is always consistent with the data in our documents.
      This guarantees that our bank is always in balance. There are many more
      transactions, of course, but these will do for illustration
      purposes.</para><para>How do we read the current account balance? Easy—create a
      MapReduce view:<indexterm id="I_indexterm5_d1e11305" significance="normal"><primary>views</primary><secondary>reading account balance</secondary></indexterm></para><programlisting id="I_programlisting5_d1e11310" language="javascript" linenumbering="unnumbered" format="linespecific">function(transaction) {
  emit(transaction.from, transaction.amount * -1);
  emit(transaction.to, transaction.amount);
}</programlisting><programlisting id="I_programlisting5_d1e11312" language="javascript" linenumbering="unnumbered" format="linespecific">function(keys, values) {
  return sum(values);
}</programlisting><para>Doesn’t look too hard, does it? We’ll store this in a view
      <literal moreinfo="none">balance</literal> in a <literal moreinfo="none">_design/account</literal>
      document. Let’s find out Jan’s balance:</para><screen format="linespecific">curl 'http://127.0.0.1:5984/bank/_design/account/_view/balance?key="Jan"'</screen><para>CouchDB replies:</para><programlisting id="I_programlisting5_d1e11326" language="javascript" linenumbering="unnumbered" format="linespecific">{"rows":[
{"key":null,"value":100}
]}</programlisting><para>Looks good! Now let’s see if our bank is actually in balance. The
      sum of all transactions should be zero:</para><screen format="linespecific">curl http://127.0.0.1:5984/bank/_design/account/_view/balance</screen><para>CouchDB replies:</para><programlisting id="I_programlisting5_d1e11335" language="javascript" linenumbering="unnumbered" format="linespecific">{"rows":[
{"key":null,"value":0}
]}</programlisting></sect2><sect2><title>Wrapping Up</title><para>This should explain that applications with strong consistency
      requirements can use CouchDB if it is possible to break up bigger
      transactions into smaller ones. A bank is a good enough approximation of
      a serious business, so you can be safe modeling your important business
      logic into small CouchDB transactions.<indexterm id="I_indexterm5_d1e11342" class="endofrange" startref="ch24_tasksbanking" significance="normal"/><indexterm id="I_indexterm5_d1e11343" class="endofrange" startref="ch24_banking" significance="normal"/></para></sect2></sect1><sect1 id="I_sect15_d1e11344"><title>Ordering Lists</title><para>Views let you sort things by any value of your data—even complex
    JSON keys are possible, as we’ve seen in earlier chapters. Sorting by date
    is very useful for allowing users to find things quickly; a name is much
    easier to find in a list of names that is sorted alphabetically. Humans
    naturally resort to a divide-and-conquer algorithm (sound familiar?) and
    don’t consider a large part of the input set because they know the name
    won’t show up there. Likewise, sorting by number and date helps a great
    deal to let users manage their ever-increasing amounts of data.<indexterm class="startofrange" id="ch24_orderedlists" significance="normal"><primary>ordered lists</primary></indexterm><indexterm class="startofrange" id="ch24_listsordering" significance="normal"><primary>lists, ordering</primary></indexterm><indexterm id="I_indexterm5_d1e11355" significance="normal"><primary>tasks and solutions using CouchDB</primary><secondary>ordering lists</secondary></indexterm></para><para>There’s another sorting type that is a little more fuzzy. Search
    engines show you results in order of relevance. That relevance is what the
    search engine thinks is most relevant to you given your search term (and
    potential search and surfing history). There are other systems trying to
    infer from earlier data what is most relevant to you, but they have the
    near-to-impossible task of guessing what a user is interested in.
    Computers are notoriously bad at guessing.</para><para>The easiest way for a computer to figure out what’s most relevant
    for a user is to let the user prioritize things. Take a to-do application:
    it allows users to reorder to-do items so they know what they need to work
    on next. The underlying problem—keeping a user-defined sorting order—can
    be found in a number of other places.</para><sect2><title>A List of Integers</title><para>Let’s stick with the to-do application example. The naïve approach
      is pretty easy: with each to-do item we store an integer that specifies
      the location in a list. We use a view to get all to-do items in the
      right order.<indexterm id="I_indexterm5_d1e11369" significance="normal"><primary>ordered lists</primary><secondary>list of integers</secondary></indexterm><indexterm id="I_indexterm5_d1e11374" significance="normal"><primary>lists, ordering</primary><secondary>integers</secondary></indexterm><indexterm id="I_indexterm5_d1e11379" significance="normal"><primary>integers, ordered list of</primary></indexterm></para><para>First, we need some example documents:</para><programlisting id="I_programlisting5_d1e11384" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "title":"Remember the Milk",
  "date":"2009-07-22T09:53:37",
  "sort_order":2
}

{
  "title":"Call Fred",
  "date":"2009-07-21T19:41:34",
  "sort_order":3
}

{
  "title":"Gift for Amy",
  "date":"2009-07-19T17:33:29",
  "sort_order":4
}

{
  "title":"Laundry",
  "date":"2009-07-22T14:23:11",
  "sort_order":1
}</programlisting><para>Next, we create a view with a simple map function that emits rows
      that are then sorted by the <literal moreinfo="none">sort_order</literal> field of our
      documents. The view’s result looks like we’d expect:</para><programlisting id="I_programlisting5_d1e11391" language="javascript" linenumbering="unnumbered" format="linespecific">function(todo) {
  if(todo.sort_order &amp;&amp; todo.title) {
    emit(todo.sort_order, todo.title);
  }
}</programlisting><programlisting id="I_programlisting5_d1e11393" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "total_rows": 4,
  "offset": 0,
  "rows": [
    {
      "key":1,
      "value":"Laundry",
      "id":"..."
    },
    {
      "key":2,
      "value":"Remember the Milk",
      "id":"..."
    },
    {
      "key":3,
      "value":"Call Fred",
      "id":"..."
    },
    {
      "key":4,
      "value":"Gift for Amy",
      "id":"..."
    }
  ]
}</programlisting><para>That looks reasonably easy, but can you spot the problem? Here’s a
      hint: what do you have to do if getting a gift for Amy becomes a higher
      priority than remembering the milk? Conceptually, the work required is
      simple:</para><orderedlist numeration="arabic" inheritnum="ignore" continuation="restarts"><listitem><para>Assign “Gift for Amy” the <literal moreinfo="none">sort_order</literal> of
          “Remember the Milk.”</para></listitem><listitem><para>Increment the <literal moreinfo="none">sort_order</literal> of “Remember the
          Milk” and <emphasis>all</emphasis> items that follow by one.</para></listitem></orderedlist><para>Under the hood, this is a lot of work. With CouchDB you’d have to
      load every document, increment the <literal moreinfo="none">sort_order</literal>, and
      save it back. If you have a lot of to-do items (I do), then this is some
      significant work. Maybe there’s a better approach.</para></sect2><sect2><title>A List of Floats</title><para>The fix is simple: instead of using an integer to specify the sort
      order, we use a float:<indexterm id="I_indexterm5_d1e11423" significance="normal"><primary>ordered lists</primary><secondary>list of floats</secondary></indexterm><indexterm id="I_indexterm5_d1e11428" significance="normal"><primary>lists, ordering</primary><secondary>floats</secondary></indexterm><indexterm id="I_indexterm5_d1e11433" significance="normal"><primary>floats, ordered list of</primary></indexterm></para><programlisting id="I_programlisting5_d1e11436" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "title":"Remember the Milk",
  "date":"2009-07-22T09:53:37",
  "sort_order":0.2
}

{
  "title":"Call Fred",
  "date":"2009-07-21T19:41:34",
  "sort_order":0.3
}

{
  "title":"Gift for Amy",
  "date":"2009-07-19T17:33:29",
  "sort_order":0.4
}

{
  "title":"Laundry",
  "date":"2009-07-22T14:23:11",
  "sort_order":0.1
}</programlisting><para>The view stays the same. Reading this is as easy as the previous
      approach. Reordering becomes much easier now. The application frontend
      can keep a copy of the <literal moreinfo="none">sort_order</literal> values around, so
      when we move an item and store the move, we not only have available the
      new position, but also the <literal moreinfo="none">sort_order</literal> value for the
      two new surrounding items.</para><para>Let’s move “Gift for Amy” so it’s above “Remember the Milk.” The
      surrounding <literal moreinfo="none">sort_order</literal>s in the target position are
      <literal moreinfo="none">0.1</literal> and <literal moreinfo="none">0.2</literal>. To store “Gift for
      Amy” with the correct <literal moreinfo="none">sort_order</literal>, we simply use the
      median of the two surrounding values: <literal moreinfo="none">(0.1 + 0.2) / 2 = 0.3 / 2
      = 0.15</literal>.</para><para>If we query the view again, we now get the desired result:</para><programlisting id="I_programlisting5_d1e11465" language="javascript" linenumbering="unnumbered" format="linespecific">{
  "total_rows": 4,
  "offset": 0,
  "rows": [
    {
      "key":0.1,
      "value":"Laundry",
      "id":"..."
    },
    {
      "key":0.15,
      "value":"Gift for Amy",
      "id":"..."
    },
    {
      "key":0.2,
      "value":"Remember the Milk",
      "id":"..."
    },
    {
      "key":0.3,
      "value":"Call Fred",
      "id":"..."
    }
  ]
}</programlisting><para>The downside of this approach is that with an increasing number of
      reorderings, float precision can become an issue as digits “grow”
      infinitely. One solution is not to care and expect that a single user
      will not exceed any limits. Alternatively, an administrative task can
      reset the whole list to single decimals when a user is not
      active.</para><para>The advantage of this approach is that you have to touch only a
      single document, which is efficient for storing the new ordering of a
      list and updating the view that maintains the ordered index since only
      the changed document has to be incorporated into the index.<indexterm id="I_indexterm5_d1e11471" class="endofrange" startref="ch24_orderedlists" significance="normal"/><indexterm id="I_indexterm5_d1e11472" class="endofrange" startref="ch24_listsordering" significance="normal"/></para></sect2></sect1><sect1 id="I_sect15_d1e11473"><title>Pagination</title><para>This recipe explains how to paginate over view results. Pagination
    is a user interface (UI) pattern that allows the display of a large number
    of rows (the <emphasis>result set</emphasis>) without loading all the rows
    into the UI at once. A fixed-size subset, the <emphasis>page</emphasis>,
    is displayed along with <emphasis>next</emphasis> and
    <emphasis>previous</emphasis> links or buttons that can move the
    <emphasis>viewport</emphasis> over the result set to an adjacent
    page.<indexterm id="I_indexterm5_d1e11494" significance="normal"><primary>result set</primary></indexterm><indexterm class="startofrange" id="ch24_pagination" significance="normal"><primary>pagination</primary></indexterm><indexterm class="startofrange" id="ch24_taskspagination" significance="normal"><primary>tasks and solutions using CouchDB</primary><secondary>pagination</secondary></indexterm></para><para>We assume you’re familiar with creating and querying documents and
    views as well as the multiple view query options.</para><sect2><title>Example Data</title><para>To have some data to work with, we’ll create a list of bands, one
      document per band:<indexterm id="I_indexterm5_d1e11512" significance="normal"><primary>pagination</primary><secondary>example data for</secondary></indexterm></para><programlisting id="I_programlisting5_d1e11517" language="javascript" linenumbering="unnumbered" format="linespecific">{ "name":"Biffy Clyro" }

{ "name":"Foo Fighters" }

{ "name":"Tool" }

{ "name":"Nirvana" }

{ "name":"Helmet" }

{ "name":"Tenacious D" }

{ "name":"Future of the Left" }

{ "name":"A Perfect Circle" }

{ "name":"Silverchair" }

{ "name":"Queens of the Stone Age" }

{ "name":"Kerub" }</programlisting></sect2><sect2><title>A View</title><para>We need a simple map function that gives us an alphabetical list
      of band names. This should be easy, but we’re adding extra smarts to
      filter out “The” and “A” in front of band names to put them into the
      right position:<indexterm id="I_indexterm5_d1e11524" significance="normal"><primary>pagination</primary><secondary>creating a view</secondary></indexterm><indexterm id="I_indexterm5_d1e11529" significance="normal"><primary>views</primary><secondary>creating alphabetic list of band names</secondary></indexterm></para><programlisting id="I_programlisting5_d1e11534" language="javascript" linenumbering="unnumbered" format="linespecific">function(doc) {
  if(doc.name) {
    var name = doc.name.replace(/^(A|The) /, "");
    emit(name, null);
  }
}</programlisting><para>The views result is an alphabetical list of band names. Now say we
      want to display band names five at a time and have a link pointing to
      the next five names that make up one page, and a link for the previous
      five, if we’re not on the first page.<indexterm id="I_indexterm5_d1e11538" significance="normal"><primary>map functions</primary><secondary>creating alphabetic list of bands (example)</secondary></indexterm></para><para>We learned how to use the <literal moreinfo="none">startkey</literal>,
      <literal moreinfo="none">limit</literal>, and <literal moreinfo="none">skip</literal> parameters in
      earlier chapters. We’ll use these again here. First, let’s have a look
      at the full result set:<indexterm id="I_indexterm5_d1e11554" significance="normal"><primary>limit query parameter</primary></indexterm><indexterm id="I_indexterm5_d1e11557" significance="normal"><primary>skip query parameter</primary></indexterm><indexterm id="I_indexterm5_d1e11560" significance="normal"><primary>startkey, limit, and skip query parameters</primary></indexterm></para><programlisting id="I_programlisting5_d1e11563" language="javascript" linenumbering="unnumbered" format="linespecific">{"total_rows":11,"offset":0,"rows":[
  {"id":"a0746072bba60a62b01209f467ca4fe2","key":"Biffy Clyro","value":null},
  {"id":"b47d82284969f10cd1b6ea460ad62d00","key":"Foo Fighters","value":null},
  {"id":"45ccde324611f86ad4932555dea7fce0","key":"Tenacious D","value":null},
  {"id":"d7ab24bb3489a9010c7d1a2087a4a9e4","key":"Future of the Left","value":null},
  {"id":"ad2f85ef87f5a9a65db5b3a75a03cd82","key":"Helmet","value":null},
  {"id":"a2f31cfa68118a6ae9d35444fcb1a3cf","key":"Nirvana","value":null},
  {"id":"67373171d0f626b811bdc34e92e77901","key":"Kerub","value":null},
  {"id":"3e1b84630c384f6aef1a5c50a81e4a34","key":"Perfect Circle","value":null},
  {"id":"84a371a7b8414237fad1b6aaf68cd16a","key":"Queens of the Stone Age",
"value":null},
  {"id":"dcdaf08242a4be7da1a36e25f4f0b022","key":"Silverchair","value":null},
  {"id":"fd590d4ad53771db47b0406054f02243","key":"Tool","value":null}
]}</programlisting></sect2><?dbfo-need height=”2in”
?><sect2><title>Setup</title><para>The mechanics of paging are very simple:<indexterm id="I_indexterm5_d1e11571" significance="normal"><primary>pagination</primary><secondary>set up</secondary></indexterm></para><itemizedlist><listitem><para>Display first page.</para></listitem><listitem><para>If there are more rows to show, show <emphasis>next</emphasis>
          link.</para></listitem><listitem><para>Draw subsequent page</para></listitem><listitem><para>If this is not the first page, show a
          <emphasis>previous</emphasis> link.</para></listitem><listitem><para>If there are more rows to show, show <emphasis>next</emphasis>
          link.</para></listitem></itemizedlist><para>Or in a pseudo-JavaScript snippet:</para><programlisting id="I_programlisting5_d1e11603" language="javascript" linenumbering="unnumbered" format="linespecific">var result = new Result();
var page = result.getPage();

page.display();

if(result.hasPrev()) {
  page.display_link('prev');
}

if(result.hasNext()) {
  page.display_link('next');
}</programlisting></sect2><sect2><title>Slow Paging (Do Not Use)</title><para>Don’t use this method! We just show it because it might seem
      natural to use, and you need to know why it is a bad idea. To get the
      first five rows from the view result, you use the
      <literal moreinfo="none">?limit=5</literal> query parameter:<indexterm id="I_indexterm5_d1e11613" significance="normal"><primary>limit query parameter</primary><secondary sortas="slow paging">in slow paging</secondary></indexterm><indexterm id="I_indexterm5_d1e11618" significance="normal"><primary>pagination</primary><secondary>slow paging</secondary></indexterm></para><screen format="linespecific">curl -X GET http://127.0.0.1:5984/artists/_design/artists/_view/by-name?limit=5</screen><para>The result:</para><programlisting id="I_programlisting5_d1e11627" language="javascript" linenumbering="unnumbered" format="linespecific">{"total_rows":11,"offset":0,"rows":[
  {"id":"a0746072bba60a62b01209f467ca4fe2","key":"Biffy Clyro","value":null},
  {"id":"b47d82284969f10cd1b6ea460ad62d00","key":"Foo Fighters","value":null},
  {"id":"45ccde324611f86ad4932555dea7fce0","key":"Tenacious D","value":null},
  {"id":"d7ab24bb3489a9010c7d1a2087a4a9e4","key":"Future of the Left","value":null},
  {"id":"ad2f85ef87f5a9a65db5b3a75a03cd82","key":"Helmet","value":null}
]}</programlisting><para>By comparing the <literal moreinfo="none">total_rows</literal> value to our
      <literal moreinfo="none">limit</literal> value, we can determine if there are more pages
      to display. We also know by the <literal moreinfo="none">offset</literal> member that we
      are on the first page. We can calculate the value for
      <literal moreinfo="none">skip=</literal> to get the results for the next page:</para><screen format="linespecific">var rows_per_page = 5;
var page = (offset / rows_per_page) + 1; // == 1
var skip = page * rows_per_page; // == 5 for the first page, 10 for the second ...</screen><?dbfo-need height=”1in”
?><para>So we query CouchDB with:</para><screen format="linespecific">curl -X GET 
'http://127.0.0.1:5984/artists/_design/artists/_view/by-name?limit=5&amp;skip=5'</screen><para>Note we have to use <literal moreinfo="none">'</literal> (single quotes) to escape
      the <literal moreinfo="none">&amp;</literal> character that is special to the shell we
      execute <literal moreinfo="none">curl</literal> in.</para><para>The result:</para><programlisting id="I_programlisting5_d1e11664" language="javascript" linenumbering="unnumbered" format="linespecific">{"total_rows":11,"offset":5,"rows":[
  {"id":"a2f31cfa68118a6ae9d35444fcb1a3cf","key":"Nirvana","value":null},
  {"id":"67373171d0f626b811bdc34e92e77901","key":"Kerub","value":null},
  {"id":"3e1b84630c384f6aef1a5c50a81e4a34","key":"Perfect Circle","value":null},
  {"id":"84a371a7b8414237fad1b6aaf68cd16a","key":"Queens of the Stone Age",
"value":null},
  {"id":"dcdaf08242a4be7da1a36e25f4f0b022","key":"Silverchair","value":null}
]}</programlisting><para>Implementing the <literal moreinfo="none">hasPrev()</literal> and
      <literal moreinfo="none">hasNext()</literal> method is pretty straightforward:<indexterm id="I_indexterm5_d1e11674" significance="normal"><primary>hasPrev( ) and hasNext( ) methods</primary></indexterm></para><programlisting id="I_programlisting5_d1e11677" language="javascript" linenumbering="unnumbered" format="linespecific">function hasPrev()
{
  return page &gt; 1;
}

function hasNext()
{
  var last_page = Math.floor(total_rows / rows_per_page) +
    (total_rows % rows_per_page);
  return page != last_page;
}</programlisting><sect3><title>The dealbreaker</title><para>This all looks easy and straightforward, but it has one fatal
        flaw. Remember how view results are generated from the underlying
        B-tree index: CouchDB jumps to the first row (or the first row that
        matches <literal moreinfo="none">startkey</literal>, if provided) and reads one row
        after the other from the index until there are no more rows (or
        <literal moreinfo="none">limit</literal> or <literal moreinfo="none">endkey</literal> match, if
        provided).<indexterm id="I_indexterm5_d1e11693" significance="normal"><primary>skip query parameter</primary><secondary>problems in slow paging</secondary></indexterm><indexterm id="I_indexterm5_d1e11698" significance="normal"><primary>startkey, limit, and skip query parameters</primary><secondary>problems with skip in slow paging</secondary></indexterm></para><para>The <literal moreinfo="none">skip</literal> argument works like this: in
        addition to going to the first row and starting to read,
        <literal moreinfo="none">skip</literal> will skip as many rows as specified, but
        CouchDB will still read from the first row; it just won’t return any
        values for the skipped rows. If you specify
        <literal moreinfo="none">skip=100</literal>, CouchDB will read 100 rows and not create
        output for them. This doesn’t sound too bad, but it is
        <emphasis>very</emphasis> bad, when you use <literal moreinfo="none">1000</literal> or
        even <literal moreinfo="none">10000</literal> as <literal moreinfo="none">skip</literal> values.
        CouchDB will have to look at a lot of rows unnecessarily.</para><para>As a rule of thumb, <literal moreinfo="none">skip</literal> should be used only
        with single digit values. While it’s possible that there are
        legitimate use cases where you specify a larger value, they are a good
        indicator for potential problems with your solution. Finally, for the
        calculations to work, you need to add a reduce function and make two
        calls to the view per page to get all the numbering right, and there’s
        still a potential for error.</para></sect3></sect2><sect2><title>Fast Paging (Do Use)</title><para>The correct solution is not much harder. Instead of slicing the
      result set into equally sized pages, we look at 10 rows at a time and
      use <literal moreinfo="none">startkey</literal> to jump to the next 10 rows. We even use
      <literal moreinfo="none">skip</literal>, but only with the value
      <literal moreinfo="none">1</literal>.<indexterm id="I_indexterm5_d1e11746" significance="normal"><primary>startkey, limit, and skip query parameters</primary><secondary sortas="fast paging">in fast paging</secondary></indexterm><indexterm id="I_indexterm5_d1e11751" significance="normal"><primary>fast paging</primary></indexterm><indexterm id="I_indexterm5_d1e11754" significance="normal"><primary>pagination</primary><secondary>fast paging</secondary></indexterm></para><para>Here is how it works:</para><itemizedlist><listitem><para>Request <literal moreinfo="none">rows_per_page</literal> + 1 rows from the
          view</para></listitem><listitem><para>Display <literal moreinfo="none">rows_per_page</literal> rows, store + 1 row
          as <literal moreinfo="none">next_startkey</literal> and
          <literal moreinfo="none">next_startkey_docid</literal></para></listitem><listitem><para>As <emphasis>page information</emphasis>, keep
          <literal moreinfo="none">startkey</literal> and
          <literal moreinfo="none">next_startkey</literal></para></listitem><listitem><para>Use the <literal moreinfo="none">next_*</literal> values to create the
          <emphasis>next</emphasis> link, and use the others to create the
          <emphasis>previous</emphasis> link</para></listitem></itemizedlist><para>The trick to finding the next page is pretty simple. Instead of
      requesting 10 rows for a page, you request 11 rows, but display only 10
      and use the values in the 11th row as the <literal moreinfo="none">startkey</literal>
      for the next page. Populating the link to the previous page is as simple
      as carrying the current <literal moreinfo="none">startkey</literal> over to the next
      page. If there’s no previous <literal moreinfo="none">startkey</literal>, we are on the
      first page. We stop displaying the link to the next page if we get
      <literal moreinfo="none">rows_per_page</literal> or less rows back. This is called
      <emphasis>linked list pagination</emphasis>, as we go from page to page,
      or list item to list item, instead of jumping directly to a pre-computed
      page. There is one caveat, though. Can you spot it?<indexterm id="I_indexterm5_d1e11820" significance="normal"><primary>linked list pagination</primary></indexterm></para><para>CouchDB view keys do not have to be unique; you can have multiple
      index entries <emphasis>read</emphasis>. What if you have more index
      entries for a key than rows that should be on a page?
      <literal moreinfo="none">startkey</literal> jumps to the first row, and you’d be screwed
      if CouchDB didn’t have an additional parameter for you to use. All view
      keys with the same value are internally sorted by
      <literal moreinfo="none">docid</literal>, that is, the ID of the document that created
      that view row. You can use the <literal moreinfo="none">startkey_docid</literal> and
      <literal moreinfo="none">endkey_docid</literal> parameters to get subsets of these rows.
      For pagination, we still don’t need <literal moreinfo="none">endkey_docid</literal>, but
      <literal moreinfo="none">startkey_docid</literal> is very handy. In addition to
      <literal moreinfo="none">startkey</literal> and <literal moreinfo="none">limit</literal>, you also use
      <literal moreinfo="none">startkey_docid</literal> for pagination if, and only if, the
      extra row you fetch to find the next page has the same key as the
      current <literal role="keep-together" moreinfo="none">startkey</literal>.<indexterm id="I_indexterm5_d1e11860" significance="normal"><primary sortas="key query parameters">*key query
          parameters</primary></indexterm></para><para>It is important to note that the <literal moreinfo="none">*_docid</literal>
      parameters only work <emphasis>in addition</emphasis> to the
      <literal moreinfo="none">*key</literal> parameters and are only useful to further narrow
      down the result set of a view for a single key. They do not work on
      their own (the one exception being the built-in
      _<literal moreinfo="none">all_docs</literal> view that already sorts by document
      ID).</para><para>The advantage of this approach is that all the key operations can
      be performed on the super-fast B-tree index behind the view. Looking up
      a page doesn’t include scanning through hundreds and thousands of rows
      unnecessarily.</para></sect2><sect2><title>Jump to Page</title><para>One drawback of the linked list style pagination is that you can’t
      pre-compute the rows for a particular page from the page number and the
      rows per page. Jumping to a specific page doesn’t really work. Our gut
      reaction, if that concern is raised, is, “Not even Google is doing
      that!” and we tend to get away with it. Google always pretends on the
      first page to find 10 more pages of results. Only if you click on the
      second page (something very few people actually do) might Google display
      a reduced set of pages. If you page through the results, you get links
      for the previous and next 10 pages, but no more. Pre-computing the
      necessary <literal moreinfo="none">startkey</literal> and
      <literal moreinfo="none">startkey_docid</literal> for 20 pages is a feasible operation
      and a pragmatic optimization to know the rows for every page in a result
      set that is potentially tens of thousands of rows long, or
      more.<indexterm id="I_indexterm5_d1e11890" significance="normal"><primary>jump to page</primary></indexterm><indexterm id="I_indexterm5_d1e11893" significance="normal"><primary>pagination</primary><secondary>jump to page</secondary></indexterm></para><para>If you really do need to jump to a page over the full range of
      documents (we have seen applications that require that), you can still
      maintain an integer value index as the view index and take a hybrid
      approach at solving pagination.<indexterm id="I_indexterm5_d1e11900" class="endofrange" startref="ch24_taskspagination" significance="normal"/><indexterm id="I_indexterm5_d1e11901" class="endofrange" startref="ch24_pagination" significance="normal"/><indexterm id="I_indexterm5_d1e11902" class="endofrange" startref="ch24_tasks" significance="normal"/></para></sect2></sect1></chapter></part><part id="part6"><title>Appendixes</title><appendix id="installingonunixlikesystems"><title>Installing on Unix-like Systems</title><sect1 id="I_sect1_d1e11909"><title>Debian GNU/Linux</title><para>You can install the CouchDB package by running:<indexterm id="I_indexterm_d1e11914" significance="normal"><primary>Unix-like systems, installing CouchDB</primary></indexterm><indexterm id="I_indexterm_d1e11917" significance="normal"><primary>installing CouchDB</primary><secondary>on Unix-like systems</secondary></indexterm><indexterm id="I_indexterm_d1e11922" significance="normal"><primary>Linux</primary><secondary>installing CouchDB</secondary></indexterm></para><programlisting id="I_programlisting_d1e11927" format="linespecific">sudo aptitude install couchdb</programlisting><para>When this completes, you should have a copy of CouchDB running on
    your machine. Be sure to read through the Debian-specific system
    documentation that can be found under
    <filename moreinfo="none">/usr/share/couchdb</filename>.</para><para>Starting with Ubuntu 9.10 (“Karmic”), CouchDB comes preinstalled
    with every desktop system.</para></sect1><sect1 id="I_sect1_d1e11936"><title>Ubuntu</title><para>You can install the CouchDB package by running:</para><programlisting id="I_programlisting_d1e11941" format="linespecific">sudo aptitude install couchdb</programlisting><para>When this completes, you should have a copy of CouchDB running on
    your machine. Be sure to read through the Ubuntu-specific system
    documentation that can be found under
    <filename moreinfo="none">/usr/share/couchdb</filename>.</para></sect1><sect1 id="I_sect1_d1e11948"><title>Gentoo Linux</title><para>Enable the development ebuild of CouchDB by running:</para><programlisting id="I_programlisting_d1e11953" format="linespecific">sudo echo dev-db/couchdb &gt;&gt; /etc/portage/package.keywords</programlisting><para>Check the CouchDB ebuild by running:</para><programlisting id="I_programlisting_d1e11957" format="linespecific">emerge -pv couchdb</programlisting><para>Build and install the CouchDB ebuild by running:</para><programlisting id="I_programlisting_d1e11961" format="linespecific">sudo emerge couchdb</programlisting><para>When this completes, you should have a copy of CouchDB running on
    your machine.</para></sect1><sect1 id="I_sect1_d1e11965"><title>Problems</title><para>See <xref linkend="installingfromsource"/> if your distribution
    doesn’t have a CouchDB package.</para></sect1></appendix><appendix id="installingonmacosx"><title>Installing on Mac OS X</title><sect1 id="I_sect1_d1e11975"><title>CouchDBX</title><para>The easiest way to get started with CouchDB on Mac OS X is by
    downloading <ulink url="http://janl.github.com/couchdbx/">CouchDBX</ulink>. This unofficial
    application doesn’t install anything to your system and can be run with a
    single double-click. Note, however, that for more serious use, it is
    recommended that you do a traditional installation with something like
    <ulink url="http://github.com/mxcl/homebrew/">Homebrew</ulink>.<indexterm id="I_indexterm_d1e11986" significance="normal"><primary>installing CouchDB</primary><secondary>on Mac OS X</secondary></indexterm><indexterm id="I_indexterm_d1e11991" significance="normal"><primary>Mac OS X</primary><secondary>installing CouchDB</secondary></indexterm></para></sect1><sect1 id="I_sect1_d1e11996"><title>Homebrew</title><para>Homebrew is a recent addition to the software management tools on
    Mac OS X. Its premise is zero configuration, heavy optimizations, and a
    beer theme. Get Homebrew from <ulink url="http://github.com/mxcl/homebrew">http://github.com/mxcl/homebrew</ulink>.
    The installation instructions are minimal. Once you are set up,
    run:</para><programlisting id="I_programlisting_d1e12004" format="linespecific">brew install couchdb</programlisting><para>in the Terminal and wait until it is done. To start CouchDB, simply
    run:</para><programlisting id="I_programlisting_d1e12008" format="linespecific">couchdb</programlisting><para>to see all the startup options available to you, run:</para><programlisting id="I_programlisting_d1e12012" format="linespecific">couchdb -h</programlisting><para>This tells you how to run CouchDB in the background, among other
    useful hints.</para><para>To verify that CouchDB is indeed running, open your browser and
    visit <ulink url="http://127.0.0.1:5984/_utils/index.html">http://127.0.0.1:5984/_utils/index.html</ulink>.</para></sect1><sect1 id="I_sect1_d1e12021"><title>MacPorts</title><para>MacPorts is the de facto package management tool for Mac OS X. While
    not an official part of the operating system, it can be used to simplify
    the process of installing FLOSS software on your machine. Before you can
    install CouchDB with MacPorts, you need to download and install <ulink url="http://www.macports.org/install.php">MacPorts</ulink>.<indexterm id="I_indexterm_d1e12029" significance="normal"><primary>MacPorts package</primary></indexterm></para><para>Make sure your MacPorts installation is up-to-date by
    running:</para><programlisting id="I_programlisting_d1e12034" format="linespecific">sudo port selfupdate</programlisting><para>You can install CouchDB with MacPorts by running:</para><programlisting id="I_programlisting_d1e12038" format="linespecific">sudo port install couchdb</programlisting><para>This command will install all of the necessary dependencies for
    CouchDB. If a dependency was already installed, MacPorts will not take
    care of upgrading the dependency to the newest version. To make sure that
    all of the dependencies are up-to-date, you should also run:</para><programlisting id="I_programlisting_d1e12042" format="linespecific">sudo port upgrade couchdb</programlisting><para>Mac OS X has a service management framework called
    <literal moreinfo="none">launchd</literal> that can be used to start, stop, or manage
    system daemons. You can use this to start CouchDB automatically when the
    system boots up. If you want to add CouchDB to your
    <literal moreinfo="none">launchd</literal> configuration, you should run:</para><programlisting id="I_programlisting_d1e12052" format="linespecific">sudo launchctl load -w 
/opt/local/Library/LaunchDaemons/org.apache.couchdb.plist</programlisting><para>After running this command, CouchDB should be available at:</para><simplelist type="vert"><member><ulink url="http://127.0.0.1:5984/_utils/index.html"/></member></simplelist><para>CouchDB will also be started and stopped along with the operating
    system.</para></sect1></appendix><appendix id="installingonwindows"><title>Installing on Windows</title><para>CouchDB does not officially support Windows. CouchDB intends to
  provide an official Windows installer at some point in the future, so this
  may change. At the time this book is going to print, there is, however, an
  <ulink url="http://people.apache.org/~mhammond/dist/">unofficial binary
  installer</ulink>.<indexterm id="I_indexterm_d1e12070" significance="normal"><primary>installing CouchDB</primary><secondary>on Windows</secondary></indexterm><indexterm id="I_indexterm_d1e12075" significance="normal"><primary>Windows, installing CouchDB</primary></indexterm></para><para>This is unofficial software, so please remember to exercise additional
  caution when downloading or installing it, as it may damage your system.
  Imagine a fearsomely comprehensive disclaimer of author liability. Now fear,
  comprehensively.</para><para>We recommend that you ask on the CouchDB mailing lists for further
  help.</para><para>CouchDB will have official Windows support as part of the 1.0
  release.</para></appendix><appendix id="installingfromsource"><title>Installing from Source</title><para>Generally speaking, you should avoid installing from source. Many
  operating systems provide package managers that will allow you to download
  and install CouchDB with a single command. These package managers usually
  take care of setting things up correctly, handling security, and making sure
  that the CouchDB database is started and stopped correctly by your system.
  The first few appendixes showed you how to install CouchDB packages for
  Unix-like, Mac OS X, and Windows operating systems. If you are unable to
  follow those instructions, or you need to install by hand for other reasons,
  this chapter is for you.<indexterm class="startofrange" id="appd_installsource" significance="normal"><primary>installing CouchDB</primary><secondary>from source</secondary></indexterm></para><sect1 id="I_sect1_d1e12094"><title>Dependencies</title><para>To build and install CouchDB, you will need to install a collection
    of other software that CouchDB depends on. Without this software properly
    installed on your system, CouchDB will refuse to work. You’ll need to
    download and install the following:<indexterm id="I_indexterm_d1e12099" significance="normal"><primary>dependencies for CouchDB installed from source</primary></indexterm></para><itemizedlist><listitem><para><ulink url="http://erlang.org/">Erlang OTP</ulink>
        (&gt;=R12B)</para></listitem><listitem><para><ulink url="http://icu.sourceforge.net/">ICU</ulink></para></listitem><listitem><para><ulink url="http://www.openssl.org/">OpenSSL</ulink></para></listitem><listitem><para><ulink url="http://www.mozilla.org/js/spidermonkey/">Mozilla
        SpiderMonkey</ulink></para></listitem><listitem><para><ulink url="http://curl.haxx.se/libcurl/">libcurl</ulink></para></listitem><listitem><para><ulink url="http://www.gnu.org/software/make/">GNU
        Make</ulink></para></listitem><listitem><para><ulink url="http://gcc.gnu.org/">GNU Compiler
        Collection</ulink></para></listitem></itemizedlist><para>It is recommended that you install Erlang OTP R12B-5 or above if
    possible.</para><para>Each of these software packages should provide custom installation
    instructions, either on the website or in the archive you download. If
    you’re lucky, however, you may be able to use a package manager to install
    these dependencies.<indexterm id="I_indexterm_d1e12136" significance="normal"><primary>Linux</primary><secondary>installing CouchDB</secondary><tertiary>from source</tertiary></indexterm></para><sect2><title>Debian-Based (Including Ubuntu) Systems</title><para>You can install the dependencies by running:</para><screen format="linespecific">apt-get install build-essential erlang libicu-dev libmozjs-dev libcurl4-openssl-dev</screen><para>If you get an error about any of these packages, be sure to check
      for the current version offered by your distribution. It may be the case
      that a newer version has been released and the package name has been
      changed. For example, you can search for the newest ICU package by
      running:</para><screen format="linespecific">apt-cache search libicu</screen><para>Select and install the highest version from the list
      available.</para></sect2><sect2><title>Mac OS X</title><para>You will need to install the Xcode Tools metapackage by
      running:<indexterm id="I_indexterm_d1e12161" significance="normal"><primary>Mac OS X</primary><secondary>installing CouchDB</secondary><tertiary>from source</tertiary></indexterm></para><screen format="linespecific">open /Applications/Installers/Xcode\ Tools/XcodeTools.mpkg</screen><para>If this is unavailable on your system, you will need to install it
      from your Mac OS X installation CD. Alternatively, you can <ulink url="http://developer.apple.com/TOOLS/Xcode/">download a
      copy</ulink>.</para><para>You can then install the other dependencies using MacPorts by
      running:</para><screen format="linespecific">port install icu erlang spidermonkey curl</screen><para>See <xref linkend="installingonmacosx"/> for more details.</para></sect2></sect1><sect1 id="I_sect1_d1e12183"><title>Installing</title><para>Once you have installed all of the dependencies, you should download
    a copy of the <ulink url="http://couchdb.apache.org/downloads.html">CouchDB source</ulink>.
    This should give you an archive that you’ll need to unpack. Open up a
    terminal and change directory to your newly unpacked archive.<indexterm id="I_indexterm_d1e12191" significance="normal"><primary>installing CouchDB</primary><secondary>from source</secondary><tertiary>installation</tertiary></indexterm></para><para>Configure the source by running:</para><screen format="linespecific">./configure</screen><para>We’re going to be installing CouchDB into
    <filename moreinfo="none">/usr/local</filename>, which is the default location for
    user-installed software. A ton of options are available for this command,
    and you can customize everything from the installation location, such as
    your home directory, to the location of your Erlang or SpiderMonkey
    installation.</para><para>To see what’s available, you can run:</para><screen format="linespecific">./configure --help</screen><para>Generally, you can ignore this step if you didn’t get any errors the
    first time you ran it. You’ll only need to pass extra options if your
    setup is a bit weird and the script is having trouble finding one of the
    dependencies you installed in the last section.</para><para>If everything was successful, you should see the following
    message:</para><screen format="linespecific">You have configured Apache CouchDB, time to relax.</screen><para>Relax.</para><para>Build and install the source by running:</para><screen format="linespecific">make &amp;&amp; sudo make install</screen><para>If you changed the installation location to somewhere temporary, you
    may not want to use the <literal moreinfo="none">sudo</literal> command here. If you are
    having problems running <literal moreinfo="none">make</literal>, you may want to try
    running <literal moreinfo="none">gmake</literal> if it is available on your system. More
    options can be found by reading the <literal moreinfo="none">INSTALL</literal>
    file.</para></sect1><sect1 id="I_sect1_d1e12238"><title>Security Considerations</title><para>It is not advisable to run the CouchDB server as the super user. If
    the CouchDB server is compromised by an attacker while it is being run by
    a super user, the attacker will get super user access to your entire
    system. That’s not what we want!</para><para>We strongly recommend that you create a specific user for CouchDB.
    This user should have as few privileges on your system as possible,
    preferably the bare minimum needed to run the CouchDB server, read the
    configuration files, and write to the data and log directories.<indexterm id="I_indexterm_d1e12245" significance="normal"><primary>installing CouchDB</primary><secondary>from source</secondary><tertiary>security considerations</tertiary></indexterm><indexterm id="I_indexterm_d1e12252" significance="normal"><primary>security</primary><secondary>considerations for CouchDB installed from
        source</secondary></indexterm></para><para>You can use whatever tool your system provides to create a new
    <literal moreinfo="none">couchdb</literal> user.</para><para>On many Unix-like systems you can run:</para><screen format="linespecific">adduser --system \
        --home /usr/local/var/lib/couchdb --no-create-home \
        --shell /bin/bash \
        --group --gecos "CouchDB" couchdb</screen><para>Mac OS X provides the standard Accounts option from the System
    Preferences application, or you can use the Workgroup Manager application,
    which can be downloaded as part of the <ulink url="http://www.apple.com/support/downloads/serveradmintools1047.html">Server
    Admin Tools</ulink>.</para><para>You should make sure that the <literal moreinfo="none">couchdb</literal> user has a
    working login shell. You can test this by logging into a terminal as the
    <literal moreinfo="none">couchdb</literal> user. You should also make sure to set the home
    directory to <filename moreinfo="none">/usr/local/var/lib/couchdb</filename>, which is the
    CouchDB database directory.</para><para>Change the ownership of the CouchDB directories by running:</para><screen format="linespecific">chown -R couchdb:couchdb /usr/local/etc/couchdb
chown -R couchdb:couchdb /usr/local/var/lib/couchdb
chown -R couchdb:couchdb /usr/local/var/log/couchdb
chown -R couchdb:couchdb /usr/local/var/run/couchdb</screen><para>Change the permission of the CouchDB directories by running:</para><screen format="linespecific">chmod -R 0770 /usr/local/etc/couchdb
chmod -R 0770 /usr/local/var/lib/couchdb
chmod -R 0770 /usr/local/var/log/couchdb
chmod -R 0770 /usr/local/var/run/couchdb</screen><para>This isn’t the final word in securing your CouchDB setup. If you’re
    deploying CouchDB on the Web, or any place where untrusted parties can
    access your sever, it behooves you to research the recommended security
    measures for your operating system and take any additional steps needed.
    Keep in mind the network security adage that the only way to properly
    secure a computer system is to unplug it from the network.</para></sect1><sect1 id="I_sect1_d1e12293"><title>Running Manually</title><para>You can start the CouchDB server by running:<indexterm id="I_indexterm_d1e12298" significance="normal"><primary>manually running CouchDB</primary></indexterm><indexterm id="I_indexterm_d1e12301" significance="normal"><primary>installing CouchDB</primary><secondary>from source</secondary><tertiary>running manually</tertiary></indexterm></para><screen format="linespecific">sudo -i -u couchdb couchdb -b</screen><para>This uses the <literal moreinfo="none">sudo</literal> command to run the
    <literal moreinfo="none">couchdb</literal> command as the <literal moreinfo="none">couchdb</literal>
    user.</para><para>When CouchDB starts, it should eventually display the following
    message:</para><screen format="linespecific">Apache CouchDB has started, time to relax.</screen><para>Relax.</para><para>To check that everything has worked, point your web browser
    to:</para><screen format="linespecific">http://127.0.0.1:5984/_utils/index.html</screen><para>This is Futon, the CouchDB web administration console. We covered
    the basics of Futon in our early chapters. Once you have it loaded, you
    should select and run the CouchDB Test Suite from the righthand menu. This
    will make sure that everything is behaving as expected, and it may save
    you some serious headaches if things turn out to be a bit wonky.</para></sect1><sect1 id="I_sect1_d1e12333"><title>Running As a Daemon</title><para>Once you’ve got CouchDB running nicely, you’ll probably want to run
    it as daemon. A daemon is a software application that runs continually in
    the background, waiting to handle requests. This is how most production
    database servers run, and you can configure CouchDB to run like this,
    too.<indexterm class="startofrange" id="appd_daemon" significance="normal"><primary>daemon, running CouchDB as</primary></indexterm><indexterm class="startofrange" id="appd_installsourcedaemon" significance="normal"><primary>installing CouchDB</primary><secondary>from source</secondary><tertiary>running CouchDB as daemon</tertiary></indexterm></para><para>When you run CouchDB as a daemon, it logs to a number of files that
    you’ll want to clean up from time to time. Letting your log files fill up
    a disk is a good way to break your server! Some operating systems come
    with software that does this for you, and it is important for you to
    research your options and take the necessary steps to make sure that this
    doesn’t become a problem. CouchDB ships with a
    <literal moreinfo="none">logrotate</literal> configuration that may be useful.</para><sect2><title>SysV/BSD-Style Systems</title><para>Depending on your operating system, the <literal moreinfo="none">couchdb</literal>
      daemon script could be installed into a directory called
      <filename moreinfo="none">init.d</filename> (for SysV-style systems) or
      <filename moreinfo="none">rc.d</filename> (for BSD-style systems) under the
      <filename moreinfo="none">/usr/local/etc</filename> directory. The following examples
      use <literal moreinfo="none">[init.d|rc.d]</literal> to indicate this choice, and you
      must replace it with your actual directory before running any of these
      commands.<indexterm id="I_indexterm_d1e12374" significance="normal"><primary>SysV/BSD-style systems, running CouchDB as daemon</primary></indexterm></para><para>You can start the CouchDB daemon by running:</para><screen format="linespecific">sudo /usr/local/etc/[init.d|rc.d]/couchdb start</screen><para>You can stop the CouchDB daemon by running:</para><screen format="linespecific">sudo /usr/local/etc/[init.d|rc.d]/couchdb stop</screen><para>You can get the status of the CouchDB daemon by running:</para><screen format="linespecific">sudo /usr/local/etc/[init.d|rc.d]/couchdb status</screen><para>If you want to configure how the daemon script works, you will
      find a bunch of options you can edit in the
      <filename moreinfo="none">/usr/local/etc/default/couchdb</filename> file.</para><para>If you want to run the script without the <literal moreinfo="none">sudo</literal>
      command, you will need to remove the <literal moreinfo="none">COUCHDB_USER</literal>
      setting from this file.</para><para>Your operating system will probably provide a way to control the
      CouchDB daemon automatically, starting and stopping it as a system
      service. To do this, you will need to copy the daemon script into your
      system <filename moreinfo="none">/etc/[init.d|rc.d]</filename> directory, and run a
      command such as:</para><screen format="linespecific">sudo update-rc.d couchdb defaults</screen><para>Consult your system documentation for more information.</para></sect2><sect2><title>Mac OS X</title><para>You can use the <literal moreinfo="none">launchd</literal> system to control the
      CouchDB daemon.<indexterm id="I_indexterm_d1e12420" significance="normal"><primary>Mac OS X</primary><secondary>running CouchDB as daemon</secondary></indexterm></para><para>You can load the <literal moreinfo="none">launchd</literal> configuration by
      running:</para><screen format="linespecific">sudo launchctl load /usr/local/Library/LaunchDaemons/org.apache.couchdb.plist</screen><para>You can unload the <literal moreinfo="none">launchd</literal> configuration by
      running:</para><screen format="linespecific">sudo launchctl unload /usr/local/Library/LaunchDaemons/org.apache.couchdb.plist</screen><para>You can start the CouchDB daemon by running:</para><screen format="linespecific">sudo launchctl start org.apache.couchdb</screen><?dbfo-need height=”1in”
?><para>You can stop the CouchDB daemon by running:</para><screen format="linespecific">sudo launchctl stop org.apache.couchdb</screen><para>The <literal moreinfo="none">launchd</literal> system can control the CouchDB
      daemon automatically, starting and stopping it as a system service. To
      do this, you will need to copy the plist file into your system
      <filename moreinfo="none">/Library/LaunchDaemons</filename> directory.</para><para>Consult the <literal moreinfo="none">launchd</literal> documentation for more
      information.<indexterm id="I_indexterm_d1e12462" class="endofrange" startref="appd_daemon" significance="normal"/><indexterm id="I_indexterm_d1e12463" class="endofrange" startref="appd_installsourcedaemon" significance="normal"/></para></sect2></sect1><sect1 id="I_sect1_d1e12464"><title>Troubleshooting</title><para>Software being software, you can count on something going wrong
    every now and then. No need to panic; CouchDB has a great community full
    of people who will be able to answer your questions and help you get
    started. Here are a few resources to help you on your way:<indexterm id="I_indexterm_d1e12469" significance="normal"><primary>installing CouchDB</primary><secondary>from source</secondary><tertiary>troubleshooting</tertiary></indexterm></para><itemizedlist><listitem><para>If you’re getting a weird error message, see the <ulink url="http://wiki.apache.org/couchdb/Error_messages">Error Messages
        wiki page</ulink>.</para></listitem><listitem><para>For general troubleshooting, try out the <ulink url="http://wiki.apache.org/couchdb/Troubleshooting">Troubleshooting
        steps</ulink>.</para></listitem><listitem><para>For other general support, you should visit the <ulink url="http://couchdb.apache.org/community/lists.html">mailing
        lists</ulink>.</para></listitem></itemizedlist><para>Don’t forget to use your favorite search engine when diagnosing
    problems. If you look around a bit, you’re likely to find something. It’s
    very possible that a bunch of other people have had exactly the same
    problem as you and a solution has been posted somewhere on the Web. Good
    luck, and remember to relax!<indexterm id="I_indexterm_d1e12497" class="endofrange" startref="appd_installsource" significance="normal"/></para></sect1></appendix><appendix id="jsonprimer"><title>JSON Primer</title><para>CouchDB uses <emphasis>JavaScript Object Notation</emphasis> (JSON)
  for data storage, a lightweight format based on a subset of JavaScipt
  syntax. One of the best bits about JSON is that it’s easy to read and write
  by hand, much more so than something like XML. We can parse it naturally
  with JavaScript because it shares part of the same syntax. This really comes
  in handy when we’re building dynamic web applications and we want to fetch
  some data from the server.<indexterm class="startofrange" id="appe_JSON" significance="normal"><primary>JSON (JavaScript Object Notation)</primary></indexterm></para><para>Here’s a sample JSON document:</para><programlisting id="I_programlisting_d1e12511" language="javascript" linenumbering="unnumbered" format="linespecific">{
    "Subject": "I like Plankton",
    "Author": "Rusty",
    "PostedDate": "2006-08-15T17:30:12-04:00",
    "Tags": [
        "plankton",
        "baseball",
        "decisions"
    ],
    "Body": "I decided today that I don't like baseball. I like plankton."
}</programlisting><para>You can see that the general structure is based around key/value pairs
  and lists of things.</para><sect1 id="I_sect1_d1e12515"><title>Data Types</title><para>JSON has a number of basic data types you can use. We’ll cover them
    all here.<indexterm class="startofrange" id="appe_datatypes" significance="normal"><primary>data types</primary><secondary>JSON</secondary></indexterm><indexterm class="startofrange" id="appe_JSONtypes" significance="normal"><primary>JSON (JavaScript Object Notation)</primary><secondary>data types</secondary></indexterm></para><sect2><title>Numbers</title><para>You can have positive integers: <literal moreinfo="none">"Count":
      253</literal><indexterm id="I_indexterm_d1e12537" significance="normal"><primary>numeric types (JSON)</primary></indexterm><indexterm id="I_indexterm_d1e12540" significance="normal"><primary>data types</primary><secondary>JSON</secondary><tertiary>numbers</tertiary></indexterm></para><para>Or negative integers: <literal moreinfo="none">"Score": -19</literal></para><para>Or floating-point numbers: <literal moreinfo="none">"Area":
      456.31</literal></para><warning><para>There is a subtle but important difference between
        floating-point numbers and decimals. When you use a number like
        <literal moreinfo="none">15.7</literal>, this will be interpreted as
        <literal moreinfo="none">15.699999999999999</literal> by most clients, which may be
        problematic for your application. For this reason, currency values are
        usually better represented as strings in JSON. A string like
        <literal moreinfo="none">"15.7"</literal> will be interpreted as
        <literal moreinfo="none">"15.7"</literal> by every JSON client.</para></warning><para>Or scientific notation: <literal moreinfo="none">"Density":
      5.6e+24</literal></para></sect2><sect2><title>Strings</title><para>You can use strings for values:<indexterm id="I_indexterm_d1e12579" significance="normal"><primary>data types</primary><secondary>JSON</secondary><tertiary>strings</tertiary></indexterm><indexterm id="I_indexterm_d1e12586" significance="normal"><primary>strings</primary></indexterm></para><programlisting id="I_programlisting_d1e12589" language="javascript" linenumbering="unnumbered" format="linespecific">"Author": "Rusty"</programlisting><para>You have to escape some special characters, like tabs or
      newlines:<footnote><para>The <ulink url="http://www.json.org">JSON site</ulink> has
          details on what needs to be escaped.</para></footnote></para><programlisting id="I_programlisting_d1e12599" language="javascript" linenumbering="unnumbered" format="linespecific">"poem": "May I compare thee to some\n\tsalty plankton."</programlisting></sect2><sect2><title>Booleans</title><para>You can have boolean true values:<indexterm id="I_indexterm_d1e12606" significance="normal"><primary>data types</primary><secondary>JSON</secondary><tertiary>booleans</tertiary></indexterm><indexterm id="I_indexterm_d1e12613" significance="normal"><primary>booleans</primary></indexterm></para><programlisting id="I_programlisting_d1e12616" language="javascript" linenumbering="unnumbered" format="linespecific">"Draft": true</programlisting><para>Or boolean false values:</para><programlisting id="I_programlisting_d1e12620" language="javascript" linenumbering="unnumbered" format="linespecific">"Draft": false</programlisting></sect2><sect2><title>Arrays</title><para>An array is a list of values:<indexterm id="I_indexterm_d1e12627" significance="normal"><primary>data types</primary><secondary>JSON</secondary><tertiary>arrays</tertiary></indexterm><indexterm id="I_indexterm_d1e12634" significance="normal"><primary>arrays</primary></indexterm></para><programlisting id="I_programlisting_d1e12637" language="javascript" linenumbering="unnumbered" format="linespecific">"Tags": ["plankton", "baseball", "decisions"]</programlisting><para>An array can contain any other data type, including arrays:</para><programlisting id="I_programlisting_d1e12641" language="javascript" linenumbering="unnumbered" format="linespecific">"Context": ["dog", [1, true], {"Location": "puddle"}]</programlisting></sect2><sect2><title>Objects</title><para>An object is a list of key/value pairs:<indexterm id="I_indexterm_d1e12648" significance="normal"><primary>data types</primary><secondary>JSON</secondary><tertiary>objects</tertiary></indexterm><indexterm id="I_indexterm_d1e12655" significance="normal"><primary>objects</primary></indexterm></para><programlisting id="I_programlisting_d1e12658" language="javascript" linenumbering="unnumbered" format="linespecific">{"Subject": "I like Plankton", "Author": "Rusty"}</programlisting></sect2><sect2><title>Nulls</title><para>You can have null values:<indexterm id="I_indexterm_d1e12665" significance="normal"><primary>data types</primary><secondary>JSON</secondary><tertiary>nulls</tertiary></indexterm><indexterm id="I_indexterm_d1e12672" significance="normal"><primary>null values</primary></indexterm></para><programlisting id="I_programlisting_d1e12675" language="javascript" linenumbering="unnumbered" format="linespecific">"Surname": null<indexterm id="I_indexterm_d1e12677" class="endofrange" startref="appe_datatypes" significance="normal"/><indexterm id="I_indexterm_d1e12678" class="endofrange" startref="appe_JSONtypes" significance="normal"/><indexterm id="I_indexterm_d1e12679" class="endofrange" startref="appe_JSON" significance="normal"/></programlisting></sect2></sect1></appendix><appendix id="thepowerofbtrees"><title>The Power of B-trees</title><para>CouchDB uses a data structure called a B-tree to index its documents
  and views. We’ll look at B-trees enough to understand the types of queries
  they support and how they are a good fit for CouchDB.<indexterm class="startofrange" id="appf_BTrees" significance="normal"><primary>B-trees</primary><secondary>power of</secondary></indexterm></para><para>This is our first foray into CouchDB internals. To use CouchDB, you
  don’t need to know what’s going on under the hood, but if you understand how
  CouchDB performs its magic, you’ll be able to pull tricks of your own.
  Additionally, if you understand the consequences of the ways you are using
  CouchDB, you will end up with smarter <phrase role="keep-together">systems</phrase>.</para><para>If you weren’t looking closely, CouchDB would appear to be a B-tree
  manager with an HTTP interface.</para><note><para>CouchDB is actually using a B+ tree, which is a slight variation of
    the B-tree that trades a bit of (disk) space for speed. When we say
    <emphasis>B-tree</emphasis>, we mean CouchDB’s <emphasis>B+
    tree</emphasis>.</para></note><para>A B-tree is an excellent data structure for storing huge amounts of
  data for fast retrieval. When there are millions and billions of items in a
  B-tree, that’s when they get fun. B-trees are usually a shallow but wide
  data structure. While other trees can grow very high, a typical B-tree has a
  single-digit height, even with millions of entries. This is particularly
  interesting for CouchDB, where the leaves of the tree are stored on a slow
  medium such as a hard drive. Accessing any part of the tree for reading or
  writing requires visiting only a few nodes, which translates to a few head
  seeks (which are what make a hard drive slow), and because the operating
  system is likely to cache the upper tree nodes anyway, only the seek to the
  final leaf node is needed.</para><blockquote><attribution>Dr. Rudolf Bayer, inventor of the B-tree</attribution><para>From a practical point of view, B-trees, therefore, guarantee an
    access time of less than 10 ms even for extremely large datasets.</para></blockquote><para>CouchDB’s B-tree implementation is a bit different from the original.
  While it maintains all of the important properties, it adds Multi-Version
  Concurrency Control (MVCC) and an append-only design. B-trees are used to
  store the main database file as well as view indexes. One database is one
  B-tree, and one view index is one B-tree.</para><para>MVCC allows concurrent reads and writes without using a locking
  system. Writes are serialized, allowing only one write operation at any
  point in time for any single database. Write operations do not block reads,
  and there can be any number of read operations at any time. Each read
  operation is guaranteed a consistent view of the database. How this is
  accomplished is at the core of CouchDB’s storage model.</para><para>The short answer is that because CouchDB uses append-only files, the
  B-tree root node must be rewritten every time the file is updated. However,
  old portions of the file will never change, so every old B-tree root, should
  you happen to have a pointer to it, will also point to a consistent snapshot
  of the database.</para><para>Early in the book we explained how the MVCC system uses the document’s
  <literal moreinfo="none">_rev</literal> value to ensure that only one person can change a
  document version. The B-tree is used to look up the existing
  <literal moreinfo="none">_rev</literal> value for comparison. By the time a write is
  accepted, the <phrase role="keep-together">B-tree</phrase> can expect it to
  be an authoritative version.</para><para>Since old versions of documents are not overwritten or deleted when
  new versions come in, requests that are reading a particular version do not
  care if new ones are written at the same time. With an often changing
  document, there could be readers reading three different versions at the
  same time. Each version was the latest one when a particular client started
  reading it, but new versions were being written. From the point when a new
  version is <emphasis>committed</emphasis>, new readers will read the new
  version while old readers keep reading the old version.</para><para>In a B-tree, data is kept only in leaf nodes. CouchDB B-trees append
  data only to the database file that keeps the B-tree on disk and grows only
  at the end. Add a new document? The file grows at the end. Delete a
  document? That gets recorded at the end of the file. The consequence is a
  robust database file. Computers fail for plenty of reasons, such as power
  loss or failing hardware. Since CouchDB does not overwrite any existing
  data, it cannot corrupt anything that has been written and
  <emphasis>committed</emphasis> to disk already. See <xref linkend="figure_f-1"/>.</para><para>Committing is the process of updating the database file to reflect
  changes. This is done in the file footer, which is the last 4k of the
  database file. The footer is 2k in size and written twice in succession.
  First, CouchDB appends any changes to the file and then records the file’s
  new length in the first database footer. It then force-flushes all changes
  to disk. It then copies the first footer over to the second 2k of the file
  and force-flushes again.</para><figure float="none" id="figure_f-1"><title>Flat B-tree and append-only</title><mediaobject id="I_mediaobject_d1e12748"><imageobject role="print"><imagedata fileref="figs/print/codb_af01.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/codb_af01.png" format="PNG"/></imageobject></mediaobject></figure><para>If anywhere in this process a problem occurs—say, power is cut off and
  CouchDB is restarted later—the database file is in a consistent state and
  doesn’t need a checkup. CouchDB starts reading the database file backward.
  When it finds a footer pair, it makes some checks: if the first 2k are
  corrupt (a footer includes a checksum), CouchDB replaces it with the second
  footer and all is well. If the second footer is corrupt, CouchDB copies the
  first 2k over and all is well again. Only once both footers are flushed to
  disk successfully will CouchDB acknowledge that a write operation was
  successful. Data is never lost, and data on disk is never corrupted. This
  design is the reason for CouchDB having no <emphasis>off</emphasis> switch.
  You just terminate it when you are done.</para><para>There’s a lot more to say about B-trees in general, and if and how
  SSDs change the runtime behavior. The Wikipedia article on <ulink url="http://en.wikipedia.org/wiki/B-tree">B-trees</ulink> is a good starting
  point for further investigations. Scholarpedia includes <ulink url="http://www.scholarpedia.org/article/B-tree_and_UB-tree">notes</ulink>
  by Dr. Rudolf Bayer, inventor of the B-tree.<indexterm id="I_indexterm_d1e12766" class="endofrange" startref="appf_BTrees" significance="normal"/></para></appendix></part><index/><colophon id="colophon"><title>Colophon</title><para>The animal on the cover of <citetitle>CouchDB: The Definitive
  Guide</citetitle> is a Pomeranian dog (<emphasis>Canis
  familiaris</emphasis>), a small variety of the generally larger German Spitz
  breed, named for the Baltic region of Pomerania (today spilt between
  northeastern Germany and northern Poland) where it was first bred.</para><para>Originally, Pomeranians were closer in size to their German Spitz
  relatives—weighing 30–50 pounds—and were bred as herding dogs because of
  their intelligence, energy, and loyalty. From the late 19th century,
  however, breeders began to favor increasingly smaller dogs, a move caused in
  large part by Queen Victoria’s affinity for that variety. Today, Pomeranians
  are classed as “toy dogs,” weighing only 4–7 pounds, and are particularly
  kept as small pets and show dogs.</para><para>The Pomeranian exhibits many of the physical and behavioral
  characteristics of its larger ancestors and relatives. It has a short,
  pointed muzzle, upright and pointed ears, a large bushy tail carried curled
  over the back, and is especially spirited and friendly. Pomeranians are also
  particularly noted for their double coat—a soft and dense undercoat and a
  long, straight and harshly textured outer coat—and come in a wide variety of
  colors, including white, black, brown, red, orange, sable, spotted, or any
  combination thereof. Because of their small size, Pomeranians are able to
  exercise <phrase role="keep-together">sufficiently</phrase> in small indoor
  spaces if taken for a daily walk, and consequently make <phrase role="keep-together">excellent</phrase> apartment pets.</para><para>The cover image is from Lydekker’s <emphasis>Royal Natural
  History</emphasis>. The cover font is Adobe ITC Garamond. The text font is
  Linotype Birka; the heading font is Adobe Myriad Condensed; and the code
  font is LucasFont’s TheSansMonoCondensed.</para></colophon></book>